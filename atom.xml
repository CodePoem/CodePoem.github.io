<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>梦半觉-CodePoem</title>
  
  <subtitle>大梦谁先觉，平生我自知~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://codepoem.github.io/"/>
  <updated>2021-06-10T14:43:03.000Z</updated>
  <id>https://codepoem.github.io/</id>
  
  <author>
    <name>CodePoem</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小记-第一次报告 Android 官方文档错误</title>
    <link href="https://codepoem.github.io/post/%E5%B0%8F%E8%AE%B0-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8A%A5%E5%91%8A%20Android%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%94%99%E8%AF%AF/"/>
    <id>https://codepoem.github.io/post/小记-第一次报告 Android 官方文档错误/</id>
    <published>2021-06-10T14:43:00.000Z</published>
    <updated>2021-06-10T14:43:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在阅读 Android 官方文档<a href="https://developer.android.com/jetpack/guide">《应用架构指南》</a>一篇，在实操过程中发现示例代码的一处错误。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><a href="https://developer.android.com/jetpack/guide#connect-viewmodel-repository">UserProfileViewModel</a> 的示例代码中</p><p>代码行：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> user = LiveData&lt;User&gt; = _user<br></code></pre></td></tr></table></figure><p>应该为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> user :LiveData&lt;User&gt; = _user<br></code></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本次发现也已向 Google 提交了 <a href="https://issuetracker.google.com/issues/190329948">issue</a>，并得到了反馈。</p><p>虽然只是一处简单的文档笔误，但是也见证了我仔细阅读文档并实操的过程。</p><hr><p>另外，这是我第一次对 Android 官方文档反馈问题，算是拿到“一血”，仅此记录一下~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在阅读 Android 官方文档&lt;a href=&quot;https://developer.android.com/jetpack/guide
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="小计" scheme="https://codepoem.github.io/tags/%E5%B0%8F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Android适配-文件存储</title>
    <link href="https://codepoem.github.io/post/Android%E9%80%82%E9%85%8D-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/"/>
    <id>https://codepoem.github.io/post/Android适配-文件存储/</id>
    <published>2021-05-05T23:36:56.000Z</published>
    <updated>2021-05-07T00:06:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FileProvider"><a href="#FileProvider" class="headerlink" title="FileProvider"></a>FileProvider</h2><p>历史问题：File Uri 访问控制需要开放底层文件系统权限，开放的权限直到下次关闭之对任何 App 应用都可用。这种级别的访问从根本上说是不安全的。</p><p>解决方案：FileProvider</p><p>Content Uri 访问控制，“路由映射”设计，无需修改开放底层文件系统权限，只需授予运行时级别的临时权限。</p><ol><li><p>AndroidManifest 中声明 FileProvider。考虑到与依赖代码的兼容，不建议直接使用 FileProvider，建议自定义类继承 FileProvider，并制定唯一的 android:authorities 属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleFileProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FileProvider</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>AndroidManifest.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">provider</span></span><br><span class="hljs-tag">     <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.XXX.XXX.sample.AppleFileProvider&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;$&#123;applicationId&#125;.file.provider&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">android:grantUriPermissions</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><br> <span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>android:name 属性为 FileProvider 组件名。</li><li>android:authorities 属性为控制域，一般是由包名+自定义的标识构成。</li><li>android:exported 属性设置为 false; FileProvider 不需要公开。</li><li>android:grantUriPermissions 属性设置为 true，以允许授予对文件的临时访问权限。</li></ul></li><li><p>定义“路由映射”关系，即指定 android.support.FILE_PROVIDER_PATHS &lt;meta-data&gt; 元素.</p><p>参考官方文档<a href="https://developer.android.google.cn/reference/androidx/core/content/FileProvider#SpecifyFiles">Specifying Available Files</a></p><p>AndroidManifest.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">provider</span></span><br><span class="hljs-tag">     <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.XXX.XXX.sample.AppleFileProvider&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;$&#123;applicationId&#125;.file.provider&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">android:grantUriPermissions</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><br>     <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><br><span class="hljs-tag">         <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">android:resource</span>=<span class="hljs-string">&quot;@xml/apple_file_provider&quot;</span>/&gt;</span><br><br> <span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span><br></code></pre></td></tr></table></figure><p>apple_file_provider.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">paths</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">files-path</span></span><br><span class="hljs-tag">         <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;.&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;files_temp&quot;</span> /&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">cache-path</span></span><br><span class="hljs-tag">         <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;.&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cache_temp&quot;</span> /&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">external-path</span></span><br><span class="hljs-tag">         <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;.&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;external_temp&quot;</span> /&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">external-cache-path</span></span><br><span class="hljs-tag">         <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;.&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;external_cache_temp&quot;</span> /&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">external-files-path</span></span><br><span class="hljs-tag">         <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;.&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;external_files_temp&quot;</span> /&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">external-media-path</span></span><br><span class="hljs-tag">         <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;.&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;external-media_temp&quot;</span> /&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">root-path</span></span><br><span class="hljs-tag">         <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;.&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;root_content_temp&quot;</span> /&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">paths</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>files-path 表示应用程序内部存储区域子目录中的文件。对应 API Context.getFilesDir()。</li><li>cache-path 表示应用程序内部存储区域的缓存子目录中的文件。对应 API Context.getCacheDir()。</li><li>external-path 表示外部存储区根目录下的文件。对应 API Environment.getExternalStorageDirectory()。</li><li>external-files-path 表示应用程序外部存储区域根目录中的文件。对应 API ContextCompat.getExternalFilesDirs(context, null)。</li><li>external-cache-path 表示应用程序外部缓存区域根目录中的文件。对应 API ContextCompat.getExternalCacheDirs(context)。</li><li>external-media-path 表示应用程序外部媒体区域根目录中的文件。对应 API Context.getExternalMediaDirs()。（API 21+）</li></ul><p>注意：root-path 表示设备根目录，可以获取到外置 SD 卡文件。root-path 官方文档里没有提到，但在 FileProvider 源码里有涉及。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ContentProvider</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG_ROOT_PATH = <span class="hljs-string">&quot;root-path&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG_FILES_PATH = <span class="hljs-string">&quot;files-path&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG_CACHE_PATH = <span class="hljs-string">&quot;cache-path&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG_EXTERNAL = <span class="hljs-string">&quot;external-path&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG_EXTERNAL_FILES = <span class="hljs-string">&quot;external-files-path&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG_EXTERNAL_CACHE = <span class="hljs-string">&quot;external-cache-path&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG_EXTERNAL_MEDIA = <span class="hljs-string">&quot;external-media-path&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体“路由映射”逻辑可自行查看 FileProvider 源码中 parsePathStrategy 方法的实现。</p></li><li><p>运行时获取 content uri。</p><p>FileProvider.getUriForFile() 即可将 file Uri 转换为传输时所需的 content Uri。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Uri <span class="hljs-title">getContentUri</span><span class="hljs-params">(Context context, String authority, File file)</span> </span>&#123;<br>    Uri contentUri;<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;<br>        contentUri = FileProvider.getUriForFile(context, authority, file);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        contentUri = Uri.fromFile(file);<br>    &#125;<br>    <span class="hljs-keyword">return</span> contentUri;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="分区存储"><a href="#分区存储" class="headerlink" title="分区存储"></a>分区存储</h2><p>存储目录可以参考之前写的文章 <a href="https://codepoem.fun/2019/05/05/Android%E5%AD%98%E5%82%A8%E7%9B%AE%E5%BD%95/">Android 存储目录.md</a>。</p><p>历史问题：App 开发者未遵循规范，滥用公有存储目录，导致用户相册等公有目录下文件混乱不堪。</p><p>解决方案：分区存储。</p><p>在分区存储的强制规范下，媒体文件要存放到公有目录，就必须直接或间接地使用 MediaStore 的 API 来统一存储到媒体库。</p><p>两个规则强制执行，来规范 App 开发者存储文件行为。</p><ol><li>强制要求指定相对路径，可以理解为子目录，且必须是公有目录默认媒体目录分类（DCIM、Picture、Music、Video、Download、Document）中的一个。</li><li>Android 11 强制执行分区存储，即使申请了外部空间读写权限，直接通过 File Uri 来读写也会抛出异常。</li></ol><p>适配方案：</p><ul><li><p>操作私有目录（包括内部存储私有目录和外部存储私有目录）。<br>使用 Context 相关 API，无需权限。</p></li><li><p>操作外部存储公有目录。</p><ol><li>SAF （全称 Storage Access Framework，存储访问框架），无需权限即可访问自己或其他 App 的公有媒体文件。SAF 的缺点是界面单调、操作不便、不可定制交互。</li><li>根据 API 适配。<ol><li>Android 4.4 - 10 仍旧使用 File API Environment.getExternalStorageDirectory()。<br>Android 6、0 需要动态申请外部存储权限。<br>Android 10 须通过在 manifest 的 Application 节点添加 requestLegacyExternalStorage = true 来声明对 File Api 方式的兼容。</li><li>Android 11 使用 MediaStore 读写，访问自己 App 的文件无需权限。读取其他 App 媒体文件需要 READ_EXTERNAL_STORAGE 权限，写入其他 App 媒体文件需要 MANAGE_EXTERNAL_STORAGE 权限。</li></ol></li></ol></li></ul><hr><p>相关文章：<br><a href="https://codepoem.fun/2019/05/05/Android%E5%AD%98%E5%82%A8%E7%9B%AE%E5%BD%95/">Android 存储目录.md</a><br><a href="https://codepoem.fun/2019/11/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1Android7.0%E9%80%82%E9%85%8DFileProvider%E8%B8%A9%E5%9D%91/">记录一次 Android7.0 适配 FileProvider 踩坑.md</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;FileProvider&quot;&gt;&lt;a href=&quot;#FileProvider&quot; class=&quot;headerlink&quot; title=&quot;FileProvider&quot;&gt;&lt;/a&gt;FileProvider&lt;/h2&gt;&lt;p&gt;历史问题：File Uri 访问控制需要开放底层文件系统权限
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="Android适配" scheme="https://codepoem.github.io/tags/Android%E9%80%82%E9%85%8D/"/>
    
      <category term="文件存储" scheme="https://codepoem.github.io/tags/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>厚薄</title>
    <link href="https://codepoem.github.io/post/%E5%8E%9A%E8%96%84/"/>
    <id>https://codepoem.github.io/post/厚薄/</id>
    <published>2021-03-28T12:16:39.000Z</published>
    <updated>2021-07-28T11:58:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>所谓厚薄，<br>书从厚读到薄，从薄读到厚，<br>厚积薄发。</p><p>重拾基础，备忘备战~</p><ul><li><p>数据结构与算法</p><p><a href="https://github.com/CodePoem/VAlgorithm">VAlgorithm</a> -&gt; <a href="https://codepoem.fun/VAlgorithm">go to browse</a></p></li><li><p>设计模式</p><p><a href="https://github.com/CodePoem/VDesignPatterns">VDesignPatterns</a> -&gt; <a href="https://codepoem.fun/VDesignPatterns">go to browse</a></p></li><li><p>Android 知识体系</p><p><a href="https://github.com/CodePoem/VAndroidReview">VAndroidReview</a> -&gt; <a href="https://codepoem.fun/VAndroidReview">go to browse</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;所谓厚薄，&lt;br&gt;书从厚读到薄，从薄读到厚，&lt;br&gt;厚积薄发。&lt;/p&gt;
&lt;p&gt;重拾基础，备忘备战~&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据结构与算法&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CodePoem/VAlgorithm&quot;&gt;VAlgori
      
    
    </summary>
    
      <category term="厚薄" scheme="https://codepoem.github.io/categories/%E5%8E%9A%E8%96%84/"/>
    
    
      <category term="Base" scheme="https://codepoem.github.io/tags/Base/"/>
    
      <category term="厚薄" scheme="https://codepoem.github.io/tags/%E5%8E%9A%E8%96%84/"/>
    
  </entry>
  
  <entry>
    <title>优雅Intent ActivityResult</title>
    <link href="https://codepoem.github.io/post/%E4%BC%98%E9%9B%85Intent%20ActivityResult/"/>
    <id>https://codepoem.github.io/post/优雅Intent ActivityResult/</id>
    <published>2020-12-13T12:49:21.000Z</published>
    <updated>2020-12-13T12:49:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ActivityResult-新时代"><a href="#ActivityResult-新时代" class="headerlink" title="ActivityResult 新时代"></a>ActivityResult 新时代</h2><p>跳转 Activity 获取返回值，我们怎么做?</p><p>AndroidX Activity 1.2.0-alpha02 和 Fragment 1.3.0-alpha02 是新旧时代的划分线。</p><p>调用方假设为 IntentsActivity，被调用方假设为 IntentResultActivity。</p><ul><li><p>旧石器时代：</p><p>调用方：</p><ol><li>调用 startActivityForResult 传入请求码，传输数据（可选）。</li><li>覆写 onActivityResult 方法，根据请求码和结果码获取返回结果信息。</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntentsConstants</span> </span>&#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> REQUEST_CODE_OLD = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> RESULT_CODE_OLD = <span class="hljs-number">100</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> EXTRA_RESULT_OLD_REQUEST = <span class="hljs-string">&quot;extra_result_old_request&quot;</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> EXTRA_RESULT_OLD_RESULT = <span class="hljs-string">&quot;extra_result_old_result&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">val</span> intent = Intent(<span class="hljs-keyword">this</span><span class="hljs-symbol">@IntentsActivity</span>, IntentResultActivity::<span class="hljs-keyword">class</span>.java)<br>  <span class="hljs-keyword">val</span> bundle = Bundle()<br>  bundle.putString(EXTRA_RESULT_OLD_REQUEST, <span class="hljs-string">&quot;OLD&quot;</span>)<br>  intent.putExtras(bundle)<br>  startActivityForResult(<br>      intent,<br>      IntentsConstants.REQUEST_CODE_OLD<br>  )<br>&#125;<br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityResult</span><span class="hljs-params">(requestCode: <span class="hljs-type">Int</span>,   resultCode: <span class="hljs-type">Int</span>, <span class="hljs-keyword">data</span>: <span class="hljs-type">Intent</span>?)</span></span> &#123;<br>  <span class="hljs-keyword">super</span>.onActivityResult(requestCode, resultCode, <span class="hljs-keyword">data</span>)<br>  <span class="hljs-keyword">if</span> (requestCode == IntentsConstants.REQUEST_CODE_OLD &amp;&amp; resultCode == IntentsConstants.RESULT_CODE_OLD) &#123;<br>      <span class="hljs-keyword">val</span> result = <span class="hljs-keyword">data</span>?.extras?.getString(IntentsConstants.EXTRA_RESULT_OLD_RESULT)<br>      Toast.makeText(<span class="hljs-keyword">this</span><span class="hljs-symbol">@IntentsActivity</span>, <span class="hljs-string">&quot;result: <span class="hljs-variable">$result</span>&quot;</span>, Toast.LENGTH_SHORT).show()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>被调用方：</p><ol><li>finish 前 调用 setResult，传入结果码，返回数据（可选）。</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBackPressed</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> resultIntent = Intent()<br>    <span class="hljs-keyword">val</span> resultBundle = Bundle()<br>    resultBundle.putString(IntentsConstants.EXTRA_RESULT_OLD_RESULT, <span class="hljs-string">&quot;resultold&quot;</span>)<br>    resultIntent.putExtras(resultBundle)<br><br>    setResult(IntentsConstants.RESULT_CODE_OLD, resultIntent)<br>    <span class="hljs-keyword">super</span>.onBackPressed()<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>新石器时代</p><ol><li>引入依赖 AndroidX Activity 1.2.0-alpha02 和 Fragment 1.3.0-alpha02 或以上版本。</li><li>定义协议</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">implementation <span class="hljs-string">&#x27;androidxactivity:activity-ktx:1.2.0-beta02&#x27;</span><br>implementation <span class="hljs-string">&#x27;androidxfragment:fragment-ktx:1.3.0-beta02&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntentResultContract</span> : <span class="hljs-type">ActivityResultContract</span>&lt;<span class="hljs-type">String, String</span>&gt;</span>() &#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createIntent</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>, input: <span class="hljs-type">String</span>?)</span></span>: Intent &#123;<br>      <span class="hljs-keyword">return</span> Intent(context, IntentResultActivity::<span class="hljs-keyword">class</span>.java).apply &#123;<br>          putExtras(Bundle().apply &#123;<br>              putString(EXTRA_RESULT_NEW_REQUEST, <span class="hljs-string">&quot;NEW&quot;</span>)<br>          &#125;)<br>      &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">parseResult</span><span class="hljs-params">(resultCode: <span class="hljs-type">Int</span>, intent: <span class="hljs-type">Intent</span>?)</span></span>: String? &#123;<br>      <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = intent?.extras?.getString(EXTRA_RESULT_NEW_RESULT)<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (resultCode == RESULT_CODE_NEW &amp;&amp; <span class="hljs-keyword">data</span> != <span class="hljs-literal">null</span>) <span class="hljs-keyword">data</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span><br>  &#125;<br><br>  <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>      <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> RESULT_CODE_NEW = <span class="hljs-number">200</span><br><br>      <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> EXTRA_RESULT_NEW_REQUEST = <span class="hljs-string">&quot;extra_result_new_request&quot;</span><br>      <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> EXTRA_RESULT_NEW_RESULT = <span class="hljs-string">&quot;extra_result_new_result&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用方：</p><ol><li>注册协议</li><li>启动协议</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> intentsActivityLauncher =<br>registerForActivityResult(IntentResultContract()) &#123; result -&gt;<br>    Toast.makeText(<span class="hljs-keyword">this</span><span class="hljs-symbol">@IntentsActivity</span>, <span class="hljs-string">&quot;result: <span class="hljs-variable">$result</span>&quot;</span>, Toast.LENGTH_SHORT).show()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span> &#123;<br>  intentsActivityLauncher.launch(<span class="hljs-string">&quot;NEW&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>被调用方：</p><ol><li>finish 前 调用 setResult，传入结果码，返回数据（可选）。</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBackPressed</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">val</span> resultIntent = Intent()<br>  <span class="hljs-keyword">val</span> resultBundle = Bundle()<br>  resultBundle.putString(IntentsConstants.EXTRA_RESULT_NEW_RESULT, <span class="hljs-string">&quot;resultnew&quot;</span>)<br>  resultIntent.putExtras(resultBundle)<br><br>  setResult(IntentsConstants.RESULT_CODE_NEW, resultIntent)<br>  <span class="hljs-keyword">super</span>.onBackPressed()<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul><li>ActivityResultContract：协议，定义了如何传递数据和如何处理返回的数据。</li><li>ActivityResultLauncher： 启动器，调用 ActivityResultLauncher 的 launch 方法来启动页面跳转，作用相当于原来的 startActivity()。</li></ul><h3 id="库中默认已实现-Contract"><a href="#库中默认已实现-Contract" class="headerlink" title="库中默认已实现 Contract"></a>库中默认已实现 Contract</h3><p>库中默认已实现的 Contract 都定义在 androidx.activity.result.contract.ActivityResultContracts 中。</p><ul><li><p>StartActivityForResult: 通用的 Contract，不做任何转换，Intent 作为输入，ActivityResult 作为输出，这也是最常用的一个协定。</p></li><li><p>RequestMultiplePermissions： 用于请求一组权限。</p></li><li><p>RequestPermission: 用于请求单个权限。</p></li><li><p>TakePicturePreview: 调用 MediaStore.ACTION_IMAGE_CAPTURE 拍照，返回值为 Bitmap 图片。</p></li><li><p>TakePicture: 调用 MediaStore.ACTION_IMAGE_CAPTURE 拍照，并将图片保存到给定的 Uri 地址，返回 true 表示保存成功。</p></li><li><p>TakeVideo: 调用 MediaStore.ACTION_VIDEO_CAPTURE 拍摄视频，保存到给定的 Uri 地址，返回一张缩略图。</p></li><li><p>PickContact: 从通讯录 APP 获取联系人。</p></li><li><p>GetContent: 提示用选择一条内容，返回一个通过 ContentResolver#openInputStream(Uri) 访问原生数据的 Uri 地址（content://形式） 。默认情况下，它增加了 Intent#CATEGORY_OPENABLE, 返回可以表示流的内容。</p></li><li><p>CreateDocument: 提示用户选择一个文档，返回一个(file:/http:/content:)开头的 Uri。</p></li><li><p>OpenMultipleDocuments: 提示用户选择文档（可以选择多个），分别返回它们的 Uri，以 List 的形式。</p></li><li><p>OpenDocumentTree: 提示用户选择一个目录，并返回用户选择的作为一个 Uri 返回，应用程序可以完全管理返回目录中的文档。</p></li></ul><h2 id="ActivityResult-新时代优势"><a href="#ActivityResult-新时代优势" class="headerlink" title="ActivityResult 新时代优势"></a>ActivityResult 新时代优势</h2><ol><li><p>以回调的方式获取返回值，而不是覆写方法。个人认为覆写方法获取返回值有一种“割裂”的感觉。</p></li><li><p>减少了样板代码，自定义 Contract 可以复用传值和解析值的逻辑。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ActivityResult-新时代&quot;&gt;&lt;a href=&quot;#ActivityResult-新时代&quot; class=&quot;headerlink&quot; title=&quot;ActivityResult 新时代&quot;&gt;&lt;/a&gt;ActivityResult 新时代&lt;/h2&gt;&lt;p&gt;跳转 Act
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="Intent" scheme="https://codepoem.github.io/tags/Intent/"/>
    
      <category term="ActivityResult" scheme="https://codepoem.github.io/tags/ActivityResult/"/>
    
  </entry>
  
  <entry>
    <title>译-viewlifecycleowner与this对比</title>
    <link href="https://codepoem.github.io/post/%E8%AF%91-viewlifecycleowner%E4%B8%8Ethis%E5%AF%B9%E6%AF%94/"/>
    <id>https://codepoem.github.io/post/译-viewlifecycleowner与this对比/</id>
    <published>2020-11-24T05:03:26.000Z</published>
    <updated>2020-11-24T05:03:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>哈喽，Android 小伙伴们~</p><p>这篇文章将提到 Fragment 中的两种 lifecycleowners。因为作为一个 Android 开发者，我们能够简单地使用 Fragment 作为 lifecycle owner，但某些情境下这可能会使你烦恼。</p><p>让我们先来看一下 Fragment 的生命周期：</p><center><p><img src="/assert/img/lifecycle/fragment_lifecycle.png" alt="FragmentLifecycle"></p></center><p>从图中我们可以看到 onCreate 和 onDestroy 只调用了一次。这些是 Fragment 的主要的生命周期方法。 onCreateView 和 onDestroyView 根据 Fragment 的状态来被调用，因为它们是 Fragment 中 View 的主要生命周期方法。</p><p>因此，如果我们在 onCreate 中绑定 LiveData ，仅仅注册一次似乎是很合适很健康的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">liveData.observe(<span class="hljs-keyword">this</span>, observer)<br></code></pre></td></tr></table></figure><p>然而当我们跳转到另一个 Fragment 并且改变 LiveData 的值后再回到之前的 Fragment 时会发生什么呢?</p><p>返回到之前的 Fragment 时，我们不能获取到 LiveData 最新的数据，需要去请求它。</p><p>因此似乎使用 View 的 LifeCycle 方法是更有用的。在这种条件下，我们可能犯的一个共同的错误是使用 Fragment 作为 LifeCycle owner。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 在 onViewCreated, onCreateView, onActivityCreated 中调用</span><br><span class="hljs-comment">// 错误!!! 它可能造成重复观察或其他问题</span><br>liveData.observe(<span class="hljs-keyword">this</span>, observer)<br></code></pre></td></tr></table></figure><p>我们应该使用 viewLifecycleOwner :</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 在 onViewCreated, onCreateView, onActivityCreated 中调用</span><br>liveData.observe(viewLifecycleOwner, observer)<br></code></pre></td></tr></table></figure><hr><p><a href="https://medium.com/@cs.ibrahimyilmaz/viewlifecycleowner-vs-this-a8259800367b">原文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;哈喽，Android 小伙伴们~&lt;/p&gt;
&lt;p&gt;这篇文章将提到 Fragment 中的两种 lifecycleowners。因为作为一个 Android 开发者，我们能够简单地使用 Fragment 作为 lifecycle owner，但某些情境下这可能会使你烦恼。&lt;/p
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="译文" scheme="https://codepoem.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="lifecycle" scheme="https://codepoem.github.io/tags/lifecycle/"/>
    
  </entry>
  
  <entry>
    <title>优雅FindViewById</title>
    <link href="https://codepoem.github.io/post/%E4%BC%98%E9%9B%85FindViewById/"/>
    <id>https://codepoem.github.io/post/优雅FindViewById/</id>
    <published>2020-04-18T05:06:23.000Z</published>
    <updated>2020-11-22T18:39:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="findBiewById"><a href="#findBiewById" class="headerlink" title="findBiewById"></a>findBiewById</h2><p>findBiewById 是 Android 开发中在布局中查找 View 元素的 Api。</p><h3 id="findBiewById-基本使用"><a href="#findBiewById-基本使用" class="headerlink" title="findBiewById 基本使用"></a>findBiewById 基本使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br>  TextView mTextDemo;<br><br>  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    setContentView(R.layout.activity_demo);<br>    mTextDemo = (TextView) findViewById(R.id.tv_demo);<br>    mTextDemo.setText(<span class="hljs-string">&quot;Demo&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为写起来很繁琐（而且还需要手动强转类型），所以逐渐出现了各种简化或者代替它的方式。</p><h3 id="省略强转"><a href="#省略强转" class="headerlink" title="省略强转"></a>省略强转</h3><p>从 <a href="https://developer.android.google.cn/topic/libraries/support-library/rev-archive.html">Android Support Library 26.0.0 Beta 1</a> 开始 findViewById 将不再需要强转了。</p><p>findViewById() 方法的所有实例现在会返回 &lt;T extends View&gt; T，而不是 View。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br>  TextView mTextDemo;<br><br>  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    setContentView(R.layout.activity_demo);<br>    mTextDemo = findViewById(R.id.tv_demo);<br>    mTextDemo.setText(<span class="hljs-string">&quot;Demo&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="findBiewById-原理"><a href="#findBiewById-原理" class="headerlink" title="findBiewById 原理"></a>findBiewById 原理</h3><p>findBiewById 原理实质上是递归遍历查找匹配 Id 的 View。</p><p>Activity 中 findViewId 方法会调用获取 Window -&gt; DecoreView -&gt; View 的 findBiewById 方法。</p><p>最终会调用到 View 中的 findViewTraversal 方法。方法名看上去是遍历操作，在 View 类中找不到遍历逻辑；<br>实际上 ViewGroup 覆写了 View 的 findViewTraversal 方法，实现了递归遍历查找匹配 View 的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">View</span> </span>&#123;<br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;T extends View&gt; <span class="hljs-function">T <span class="hljs-title">findViewById</span><span class="hljs-params">(<span class="hljs-meta">@IdRes</span> <span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (id == NO_ID) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> findViewTraversal(id);<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> &lt;T extends View&gt; <span class="hljs-function">T <span class="hljs-title">findViewTraversal</span><span class="hljs-params">(<span class="hljs-meta">@IdRes</span> <span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (id == mID) &#123;<br>            <span class="hljs-keyword">return</span> (T) <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewGroup</span> </span>&#123;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * &#123;<span class="hljs-doctag">@hide</span>&#125;</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">protected</span> &lt;T extends View&gt; <span class="hljs-function">T <span class="hljs-title">findViewTraversal</span><span class="hljs-params">(<span class="hljs-meta">@IdRes</span> <span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (id == mID) &#123;<br>            <span class="hljs-keyword">return</span> (T) <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">final</span> View[] where = mChildren;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> len = mChildrenCount;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            View v = where[i];<br><br>            <span class="hljs-keyword">if</span> ((v.mPrivateFlags &amp; PFLAG_IS_ROOT_NAMESPACE) == <span class="hljs-number">0</span>) &#123;<br>                v = v.findViewById(id);<br><br>                <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> (T) v;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ButterKnife"><a href="#ButterKnife" class="headerlink" title="ButterKnife"></a><a href="https://jakewharton.github.io/butterknife/">ButterKnife</a></h2><p>ButterKnife 是 jakewharton 大神开源作品，用于替代 findViewById ，避免繁琐的写法。</p><h3 id="ButterKnife-基本使用"><a href="#ButterKnife-基本使用" class="headerlink" title="ButterKnife 基本使用"></a>ButterKnife 基本使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br>  <span class="hljs-meta">@BindView(R.id.tv_demo)</span><br>  TextView mTextDemo;<br><br>  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    setContentView(R.layout.activity_demo);<br>    ButterKnife.bind(<span class="hljs-keyword">this</span>);<br>    mTextDemo.setText(<span class="hljs-string">&quot;Demo&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ButterKnife-原理"><a href="#ButterKnife-原理" class="headerlink" title="ButterKnife 原理"></a>ButterKnife 原理</h3><p>注解编译时生成绑定类，代替我们完成 FindViewById 的操作。</p><p>PS：ButterKnife Github ReadMe 中说明已不推荐使用，推荐下文提到的 Android 官方提供的 <a href="https://developer.android.com/topic/libraries/view-binding">ViewBinding</a></p><h2 id="Data-Binding-Library"><a href="#Data-Binding-Library" class="headerlink" title="Data Binding Library"></a><a href="https://developer.android.google.cn/topic/libraries/data-binding/index.html">Data Binding Library</a></h2><h3 id="Data-Binding-基本使用"><a href="#Data-Binding-基本使用" class="headerlink" title="Data Binding 基本使用"></a>Data Binding 基本使用</h3><p>布局需要使用 &lt;layout&gt; 标签包裹。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    setContentView(R.layout.demo_activity);<br>    ActivityDemoBinding binding = DataBindingUtil.setContentView(<span class="hljs-keyword">this</span>, R.layout.activity_demo);<br>    binding.tvDemo.setText(<span class="hljs-string">&quot;Demo&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Data-Binding-原理"><a href="#Data-Binding-原理" class="headerlink" title="Data Binding 原理"></a>Data Binding 原理</h3><p>自动查找所有 View 并缓存到 binding 实例中以供访问。性能超过手写的 findViewById，因为它只遍历了一遍 XML 布局，而 findViewById 每次都会去遍历 XML 布局；include 布局中的 view 也能同样能访问，并且保留结构。</p><h2 id="Kotlin-Android-Extensions"><a href="#Kotlin-Android-Extensions" class="headerlink" title="Kotlin Android Extensions"></a>Kotlin Android Extensions</h2><p>直接生成对应的 View 作为属性，不需要 findViewById，不需要定义变量，直接使用。使用时需要注意访问的 View 属于哪个 Layout，因为智能提示的候选项会提供所有布局中的 View 供你选择，然后帮你 import 对应包以便你访问这个 View；假如 import 的多个同一层级的 layout 中具有相同的 id，则这个 id 对应的 View 将无法访问。</p><h3 id="Kotlin-Android-Extensions-synthetic-基本使用"><a href="#Kotlin-Android-Extensions-synthetic-基本使用" class="headerlink" title="Kotlin Android Extensions synthetic 基本使用"></a>Kotlin Android Extensions synthetic 基本使用</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-keyword">import</span> kotlinx.android.synthetic.main.activity_demo.*<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() &#123; &#123;<br><br>  <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> void onCreate(Bundle savedInstanceState) &#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    setContentView(R.layout.demo_activity);<br>    tvDemo.setText(<span class="hljs-string">&quot;Demo&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Kotlin-Android-Extensions-synthetic-原理"><a href="#Kotlin-Android-Extensions-synthetic-原理" class="headerlink" title="Kotlin Android Extensions synthetic 原理"></a>Kotlin Android Extensions synthetic 原理</h3><p>Kotlin 会自动生成类似 findViewById() 的方法：findCachedViewById()，在这个方法里面创建一个 HashMap 缓存每次查找到的 View，避免每次调用 View 的属性或方法时都会重新调用 findCachedViewById() 进行查找。</p><p>PS：在 <a href="https://github.com/JetBrains/kotlin/releases/tag/v1.4.20-M2">Kotlin 1.4.20-M2</a> 中，JetBrain s 废弃了 Kotlin Android Extensions 编译插件。推荐使用 ViewBinding。</p><h2 id="推荐使用-ViewBinding"><a href="#推荐使用-ViewBinding" class="headerlink" title="(推荐使用)ViewBinding"></a>(推荐使用)<a href="https://developer.android.com/topic/libraries/view-binding">ViewBinding</a></h2><h3 id="ViewBinding-基本使用"><a href="#ViewBinding-基本使用" class="headerlink" title="ViewBinding 基本使用"></a>ViewBinding 基本使用</h3><p>Android Studio 3.6 Canary 11 及更高版本中可用。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle">android &#123;<br>  ...<br>  viewBinding &#123;<br>      enabled = <span class="hljs-keyword">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() &#123; &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> binding: ActivityDemoBinding<br><br>  <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> void onCreate(Bundle savedInstanceState) &#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    binding = ActivityDemoBinding.inflate(layoutInflater)<br>    setContentView(binding.root)<br>    binding.tvDemo.setText(<span class="hljs-string">&quot;Demo&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ViewBinding-原理"><a href="#ViewBinding-原理" class="headerlink" title="ViewBinding 原理"></a>ViewBinding 原理</h3><h3 id="ViewBinding-优缺点"><a href="#ViewBinding-优缺点" class="headerlink" title="ViewBinding 优缺点"></a>ViewBinding 优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><p>Null 安全：由于视图绑定会创建对视图的直接引用，因此不存在因视图 ID 无效而引发 Null 指针异常的风险。此外，如果视图仅出现在布局的某些配置中，则绑定类中包含其引用的字段会使用 @Nullable 标记。</p></li><li><p>类型安全：每个绑定类中的字段均具有与它们在 XML 文件中引用的视图相匹配的类型。这意味着不存在发生类转换异常的风险。</p></li><li><p>更快的编译速度：视图绑定不需要处理注释，因此编译时间更短。</p></li><li><p>易于使用：视图绑定不需要特别标记的 XML 布局文件，因此在应用中采用速度更快。在模块中启用视图绑定后，它会自动应用于该模块的所有布局。</p></li></ul><h4 id="缺点与限制"><a href="#缺点与限制" class="headerlink" title="缺点与限制"></a>缺点与限制</h4><ul><li>布局和代码之间的不兼容性可能会导致编译版本在编译时（而非运行时）失败。</li><li>视图绑定不支持布局变量或布局表达式，因此不能用于直接在 XML 布局文件中声明动态界面内容。</li><li>视图绑定不支持双向数据绑定。</li></ul><hr><p>相关文章</p><p><a href="https://juejin.im/post/5e69cb55e51d4526d87c8610#heading-4">使用视图绑定替代 findViewById</a><br><a href="https://juejin.im/post/5dd407066fb9a020366f85fa#heading-5">你好, View Binding! 再次再见, findViewById!</a><br><a href="https://juejin.im/entry/5d8caedd518825093a3579b0">Kotlin 干掉了 findViewById，但用不好也会有性能问题</a><br><a href="https://proandroiddev.com/migrating-the-deprecated-kotlin-android-extensions-compiler-plugin-to-viewbinding-d234c691dec7">Migrating the deprecated Kotlin Android Extensions compiler plugin</a><br><a href="https://blog.csdn.net/qq_17766199/article/details/109557820">【译】迁移被废弃的 Kotlin Android Extensions 插件</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;findBiewById&quot;&gt;&lt;a href=&quot;#findBiewById&quot; class=&quot;headerlink&quot; title=&quot;findBiewById&quot;&gt;&lt;/a&gt;findBiewById&lt;/h2&gt;&lt;p&gt;findBiewById 是 Android 开发中在布局中
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="FindViewById" scheme="https://codepoem.github.io/tags/FindViewById/"/>
    
  </entry>
  
  <entry>
    <title>Fragment可见性</title>
    <link href="https://codepoem.github.io/post/Fragmnet%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    <id>https://codepoem.github.io/post/Fragmnet可见性/</id>
    <published>2020-03-05T14:40:14.000Z</published>
    <updated>2020-05-27T15:17:32.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fragment</span></span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 当fragment与viewpager、FragmentPagerAdapter一起使用时，切换页面时会调用此方法</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> isVisibleToUser 是否对用户可见</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserVisibleHint</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isVisibleToUser)</span> </span>&#123;<br>            <span class="hljs-keyword">boolean</span> change = isVisibleToUser != getUserVisibleHint();<br>            <span class="hljs-keyword">super</span>.setUserVisibleHint(isVisibleToUser);<br>            <span class="hljs-comment">// 在viewpager中，创建fragment时就会调用这个方法，但这时还没有resume，为了避免重复调用visible和invisible，</span><br>            <span class="hljs-comment">// 只有当fragment状态是resumed并且初始化完毕后才进行visible和invisible的回调</span><br>            <span class="hljs-keyword">if</span> (isResumed() &amp;&amp; change) &#123;<br>                <span class="hljs-keyword">if</span> (getUserVisibleHint()) &#123;<br>                    onVisible();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    onInvisible();<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 当使用show/hide方法时，会触发此回调</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> hidden fragment是否被隐藏</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onHiddenChanged</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> hidden)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.onHiddenChanged(hidden);<br>            <span class="hljs-keyword">if</span> (hidden) &#123;<br>                onInvisible();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                onVisible();<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.onResume();<br>            <span class="hljs-comment">// onResume并不代表fragment可见</span><br>            <span class="hljs-comment">// 如果是在viewpager里，就需要判断getUserVisibleHint，不在viewpager时，getUserVisibleHint默认为true</span><br>            <span class="hljs-comment">// 如果是其它情况，就通过isHidden判断，因为show/hide时会改变isHidden的状态</span><br>            <span class="hljs-comment">// 所以，只有当fragment原来是可见状态时，进入onResume就回调onVisible</span><br>            <span class="hljs-keyword">if</span> (getUserVisibleHint() &amp;&amp; !isHidden()) &#123;<br>                onVisible();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPause</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.onPause();<br>            <span class="hljs-comment">// onPause时也需要判断，如果当前fragment在viewpager中不可见，就已经回调过了，onPause时也就不需要再次回调onInvisible了</span><br>            <span class="hljs-comment">// 所以，只有当fragment是可见状态时进入onPause才加调onInvisible</span><br>            <span class="hljs-keyword">if</span> (getUserVisibleHint() &amp;&amp; !isHidden()) &#123;<br>                onInvisible();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onInvisible</span><span class="hljs-params">()</span> </span>&#123;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onVisible</span><span class="hljs-params">()</span> </span>&#123;<br>            initData();<br>        &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>补充 ：</p><p>setUserVisibleHint 为什么只在 Viewpager 有效？</p><p>实际上查看 setUserVisibleHint 的实际调用方，只有 FragmentPagerAdapter 和 FragmentStatePagerAdapter，也即 ViewPager 的适配器有调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Fragment" scheme="https://codepoem.github.io/tags/Fragment/"/>
    
      <category term="可见性" scheme="https://codepoem.github.io/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>ViewPager下Fragment预加载与懒加载</title>
    <link href="https://codepoem.github.io/post/ViewPager%E4%B8%8BFragment%E9%A2%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <id>https://codepoem.github.io/post/ViewPager下Fragment预加载与懒加载/</id>
    <published>2020-01-11T03:16:48.000Z</published>
    <updated>2020-01-11T03:16:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>ViewPager 控件有一个预加载机制，即默认情况下当前页面左右两侧的 1 个页面会被预加载，以方便用户滑动切换到相邻的界面时，更流畅地加载界面（节省了初始化时间）。</p><p>从源码里可以看到，ViewPager 的预加载机制是不可取消的，预加载数量 limit 至少为 1，如果外部设置小于 1，内部会自动置为 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewPager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewGroup</span> </span>&#123;<br><br>    <span class="hljs-comment">// 省略其他代码</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOffscreenPageLimit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> limit)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (limit &lt; <span class="hljs-number">1</span>) &#123;<br>            Log.w(<span class="hljs-string">&quot;ViewPager&quot;</span>, <span class="hljs-string">&quot;Requested offscreen page limit &quot;</span> + limit + <span class="hljs-string">&quot; too small; defaulting to &quot;</span> + <span class="hljs-number">1</span>);<br>            limit = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (limit != <span class="hljs-keyword">this</span>.mOffscreenPageLimit) &#123;<br>            <span class="hljs-keyword">this</span>.mOffscreenPageLimit = limit;<br>            <span class="hljs-keyword">this</span>.populate();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>在 ViewPager 预加载的机制下，ViewPager 本身比较难以实现 Fragment 实例化懒加载。既然 Fragment 的实例化难以懒加载，那么退而求其次，只要求实现 Fragment 请求数据的懒加载。</p><p>我们需要从 Fragment 本身入手。</p><p>主要用到 Fragment 两个方法：</p><ul><li>public void onViewCreated(View view, @Nullable Bundle savedInstanceState)</li><li>public void setUserVisibleHint(boolean isVisibleToUser)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseFragment</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> isViewCreated;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> isVisibleToUser;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> isDataInitiated;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewCreated</span><span class="hljs-params">(View view, <span class="hljs-meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onViewCreated(view, savedInstanceState);<br>        isViewCreated = <span class="hljs-keyword">true</span>;<br>        lazyLoad();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserVisibleHint</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isVisibleToUser)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.setUserVisibleHint(isVisibleToUser);<br>        <span class="hljs-keyword">this</span>.isVisibleToUser = isVisibleToUser;<br>        <span class="hljs-keyword">if</span> (isVisibleToUser) &#123;<br>            lazyLoad();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lazyLoad</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> lazyLoad(<span class="hljs-keyword">false</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lazyLoad</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> forceRefresh)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (isVisibleToUser &amp;&amp; isViewCreated &amp;&amp; (!isDataInitiated || forceRefresh)) &#123;<br>            fetchData();<br>            isDataInitiated = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fetchData</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;预加载&quot;&gt;&lt;a href=&quot;#预加载&quot; class=&quot;headerlink&quot; title=&quot;预加载&quot;&gt;&lt;/a&gt;预加载&lt;/h2&gt;&lt;p&gt;ViewPager 控件有一个预加载机制，即默认情况下当前页面左右两侧的 1 个页面会被预加载，以方便用户滑动切换到相邻的界面时，更
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Fragment" scheme="https://codepoem.github.io/tags/Fragment/"/>
    
      <category term="ViewPager" scheme="https://codepoem.github.io/tags/ViewPager/"/>
    
      <category term="预加载" scheme="https://codepoem.github.io/tags/%E9%A2%84%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="懒加载" scheme="https://codepoem.github.io/tags/%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>记录一次Android7.0适配FileProvider踩坑</title>
    <link href="https://codepoem.github.io/post/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1Android7.0%E9%80%82%E9%85%8DFileProvider%E8%B8%A9%E5%9D%91/"/>
    <id>https://codepoem.github.io/post/记录一次Android7.0适配FileProvider踩坑/</id>
    <published>2019-11-16T03:25:23.000Z</published>
    <updated>2019-11-16T03:25:27.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>FileProvider 重复</li></ul><p>自定义 FileProvider 继承 FileProvider。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleFileProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FileProvider</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>AndroidManifest.xml 中 application 节点下添加 provider 节点。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">provider</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.XXX.XXX.sample.AppleFileProvider&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;$&#123;applicationId&#125;.file.provider&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:grantUriPermissions</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:resource</span>=<span class="hljs-string">&quot;@xml/apple_file_provider&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>多个 FileProvider authorities 重复</li></ul><p>authorities 一般是由包名+自定义的标识构成。</p><p>Uri uri = FileProvider.getUriForFile(getContext(), context.getPackageName() + “.file.provider”, file);</p><p>例子：</p><p>AppleFileProvider 和 BoyFileProvider 的 authorities 重复了，都为${applicationId}.file.provider。<br>默认会取 apk 中合并后的 AndroidManifest.xml 的第一个 authorities 匹配的 FileProvider。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">provider</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.XXX.XXX.sample.AppleFileProvider&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;$&#123;applicationId&#125;.file.provider&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:grantUriPermissions</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:resource</span>=<span class="hljs-string">&quot;@xml/apple_file_provider&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">provider</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.XXX.XXX.sample.BoyFileProvider&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;$&#123;applicationId&#125;.file.provider&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:grantUriPermissions</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:resource</span>=<span class="hljs-string">&quot;@xml/boy_file_provider&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此时 Uri uri = FileProvider.getUriForFile(getContext(), context.getPackageName() + “.file.provider”, file);会与 AppleFileProvider 匹配，也就会去取 apple_file_provider.xml 中的配置。<br>如果 AppleFileProvider 与 BoyFileProvider 在 AndroidManifest 的顺序互换一下，那么就会与 BoyFileProvider 匹配，也就会去取 boy_file_provider.xml 中的配置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;FileProvider 重复&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自定义 FileProvider 继承 FileProvider。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="FileProvider" scheme="https://codepoem.github.io/tags/FileProvider/"/>
    
  </entry>
  
  <entry>
    <title>简析LeakCanary</title>
    <link href="https://codepoem.github.io/post/%E7%AE%80%E6%9E%90LeakCanary/"/>
    <id>https://codepoem.github.io/post/简析LeakCanary/</id>
    <published>2019-10-19T03:25:23.000Z</published>
    <updated>2021-08-01T03:31:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>添加依赖（release 有 no-op 版）然后在 Application 初始化。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">dependencies</span> &#123;<br>  debugImplementation <span class="hljs-string">&#x27;com.squareup.leakcanary:leakcanary-android:1.X&#x27;</span><br>  releaseImplementation <span class="hljs-string">&#x27;com.squareup.leakcanary:leakcanary-android-no-op:1.X&#x27;</span><br>  <span class="hljs-comment">// Optional, if you use support library fragments:</span><br>  debugImplementation <span class="hljs-string">&#x27;com.squareup.leakcanary:leakcanary-support-fragment:1.X&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onCreate();<br>    <span class="hljs-keyword">if</span> (LeakCanary.isInAnalyzerProcess(<span class="hljs-keyword">this</span>)) &#123;<br>        <span class="hljs-comment">// This process is dedicated to LeakCanary for heap analysis.</span><br>        <span class="hljs-comment">// You should not init your app in this process.</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    LeakCanary.install(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-comment">// Normal app init code...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h3><p>Activity：</p><p>application.registerActivityLifecycleCallbacks 覆写 onActivityDestroyed</p><p>watch（）使用 WeakReference + ReferenceQueue 监听对象回收情况</p><p>watchedObjects（LinkedHashMap&lt;key, KeyedWeakReference&gt;） watch() 方法传进来的引用，尚未判定为泄露<br>queue（ReferenceQueue） 怀疑泄漏的对象列表</p><p>以 UUID.randomUUID().toString() 为 key 构造 KeyedWeakReference（关联 ReferenceQueue） 存入 watchedObjects。</p><p><strong><em>弱引用一旦变得弱可达，就会立即入队 ReferenceQueue。这将在 finalization 或者 GC 之前发生。</em></strong></p><p>watch 方法最后会调用 moveToRetained（）</p><h3 id="Dump"><a href="#Dump" class="headerlink" title="Dump"></a>Dump</h3><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>计算了到 GC Roots 的最短强引用路径。</p><h2 id="2-0-版本"><a href="#2-0-版本" class="headerlink" title="2.0 版本"></a>2.0 版本</h2><h3 id="不需要在-Application-初始化"><a href="#不需要在-Application-初始化" class="headerlink" title="不需要在 Application 初始化"></a>不需要在 Application 初始化</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">dependencies</span> &#123;<br>  debugImplementation <span class="hljs-string">&#x27;com.squareup.leakcanary:leakcanary-android:2.X&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ContentProvider-实现"><a href="#ContentProvider-实现" class="headerlink" title="ContentProvider 实现"></a>ContentProvider 实现</h4><p>leakcanary-android-process 模块的 AndroidManifest.xml 文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;com.squareup.leakcanary&quot;</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">application</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">service</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;leakcanary.internal.HeapAnalyzerService&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:process</span>=<span class="hljs-string">&quot;:leakcanary&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">provider</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;leakcanary.internal.AppWatcherInstaller$LeakCanaryProcess&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;$&#123;applicationId&#125;.leakcanary-process.installer&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:process</span>=<span class="hljs-string">&quot;:leakcanary&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><p>看看 AppWatcherInstaller 干了啥：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppWatcherInstaller</span> : <span class="hljs-type">ContentProvider</span></span>() &#123;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * [MainProcess] automatically sets up the LeakCanary code that runs in the main app process.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainProcess</span> : <span class="hljs-type">AppWatcherInstaller</span></span>()<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * When using the `leakcanary-android-process` artifact instead of `leakcanary-android`,</span><br><span class="hljs-comment">   * [LeakCanaryProcess] automatically sets up the LeakCanary code</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeakCanaryProcess</span> : <span class="hljs-type">AppWatcherInstaller</span></span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>      <span class="hljs-keyword">super</span>.onCreate()<br>      AppWatcher.config = AppWatcher.config.copy(enabled = <span class="hljs-literal">false</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;<br><br>   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">val</span> application = context!!.applicationContext <span class="hljs-keyword">as</span> Application<br>    InternalAppWatcher.install(application)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用加载顺序实现自动注入：</p><p>Application-&gt;attachBaseContext =====&gt; ContentProvider-&gt;onCreate =====&gt; Application-&gt;onCreate =====&gt; Activity-&gt;onCreate</p><p>优点：实现”免侵入”集成，不需要手动初始化。<br>缺点：无法更改初始化时机（App 启动优化按需延迟初始化第三方库对这样的集成方式就无能为力了）。考虑到 LeakCanary 是开发 debug 阶段使用的，也无可厚非。一般的 SDK 还是不建议使用这种方式。</p><h3 id="添加默认对-Fragment-的支持"><a href="#添加默认对-Fragment-的支持" class="headerlink" title="添加默认对 Fragment 的支持"></a>添加默认对 Fragment 的支持</h3><p>Fragment：</p><p>Android O 版本 androidx 都具备对 Fragment 生命周期的监听功能。</p><p>application.registerActivityLifecycleCallbacks 覆写 onActivityCreated<br>然后 fragmentManager.registerFragmentLifecycleCallbacks 覆写 onFragmentViewDestroyed() onFragmentDestroyed()</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h2&gt;&lt;p&gt;添加依赖（release 有 no-op 版）然后在 Application 初始化。&lt;/p&gt;
&lt;figure class=&quot;highlig
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="LeakCanary" scheme="https://codepoem.github.io/tags/LeakCanary/"/>
    
      <category term="内存" scheme="https://codepoem.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>简析OkHttp</title>
    <link href="https://codepoem.github.io/post/%E7%AE%80%E6%9E%90OkHttp/"/>
    <id>https://codepoem.github.io/post/简析OkHttp/</id>
    <published>2019-10-18T03:25:23.000Z</published>
    <updated>2021-08-01T03:31:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>是对 Socket 的封装。URLConnection 在 4.4 以后底层也使用了 OkHttp。</p><p>Android 源码中 /external/okhttp/jarjar-rules.txt 中表示 com.squareup 开关的包会在编译时打包成 com.android 开头的包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">rule com.squareup.** com.android.@1<br>rule okio.** com.android.okio.@1<br></code></pre></td></tr></table></figure><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">String url = <span class="hljs-string">&quot;http://www.xxx.com&quot;</span>;<br><span class="hljs-comment">//  生成 OkHttpClient 实例对象</span><br>OkHttpClient okHttpClient = <span class="hljs-keyword">new</span> OkHttpClient();<br><span class="hljs-comment">//  生成 Request 对象</span><br>Request request = <span class="hljs-keyword">new</span> Request.Builder()<br>    .url(url)<br>    .post(RequestBody.create(MediaType.parse(<span class="hljs-string">&quot;application/json; charset=utf-8&quot;</span>),<span class="hljs-string">&quot;test content&quot;</span>))<br>    .build();<br><span class="hljs-comment">//  生成 Call 对象</span><br>Call call = okHttpClient.newCall(request);<br><br>call.enqueue(<span class="hljs-keyword">new</span> Callback() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Call call, <span class="hljs-meta">@NonNull</span> IOException e)</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Call call, <span class="hljs-meta">@NonNull</span> Response response)</span>  </span>&#123;<br><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li><p>创建请求对象。 (url, method, headers, body, tags)–&gt; Request–&gt; Call</p></li><li><p>线程池分发请求。同步使用 call.excute(),异步使用 call.enqueue()请求事件队列, 都交给 Dispatcher 分发， enqueue–&gt;Runnable–&gt;ThreadPoolExecutor</p></li><li><p>递归 Interceptor 拦截器，发送请求。 getResponseWithInterceptorChain()，InterceptorChain</p></li><li><p>请求回调，数据解析。 Respose –&gt; (code,message,requestBody)</p></li></ol><p>不管是异步还是同步，都是一样的三部曲:</p><ol><li>加入到 Dispatche r 里面的同步(或异步)队列。</li><li>执行 getResponseWithInterceptorChain 方法。（只不过同步操作是直接运行了 getResponseWithInterceptorChain 方法，而异步是通过线程池执行 R unnabl e 再去执行 getResponseWithInterceptorChain 方法）</li><li>从 Dispatcher 里面的同步(或异步)队列移除。</li></ol><p>Dispatcher 内部维护 3 个队列及 1 个线程池:</p><ul><li>readyAsyncCalls</li></ul><p>待访问请求队列，里面存储准备执行的请求。</p><ul><li>runningSyncCalls</li></ul><p>同步请求队列，正在执行的请求，包含已经取消但是还没有结束的请求。</p><ul><li>runningAsyncCalls</li></ul><p>异步请求队列，里面存储正在执行，包含已经取消但是还没有结束的请求。</p><ul><li>ExecutorService</li></ul><p>线程池，最小 0，最大 Max 的线程池。</p><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h3><p>重试与重定向拦截器。</p><p>通过 while (true) 的死循环来进行对异常结果或者响应结果判断是否要进行重新请求。</p><h3 id="BirdgeInterceptor"><a href="#BirdgeInterceptor" class="headerlink" title="BirdgeInterceptor"></a>BirdgeInterceptor</h3><p>桥接拦截器。</p><p>为用户构建的一个 Request 请求转化为能够进行网络访问的请求，同时将网络请求回来的响应 Response 转化为用户可用的 Response。初始化信息，添加请求头等，比如涉及的网络文件的类型和网页的编码，返回的数据的解压处理等等。</p><h3 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h3><p>缓存拦截器。</p><p>根据 OkHttpClient 对象的配置以及缓存策略对请求值进行缓存。</p><p>内部有 Cache 类，处理缓存操作，intercache 内部类，disklrucache 算法等<br>重点是不缓存非 get 的请求。<br>CacheStrategy 缓存策略类，通过工厂模式获取。</p><h3 id="ConnectionInterceptor"><a href="#ConnectionInterceptor" class="headerlink" title="ConnectionInterceptor"></a>ConnectionInterceptor</h3><p>网络连接拦截器。</p><p>底层是通过 SOCKET 的方式于服务端进行连接的，并且在连接建立之后会通过 OKIO 获取通向 server 端的输入流 Source 和输出流 Sink。</p><h3 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h3><p>服务请求的拦截器。</p><p>负责与服务器建立 Socket 连接，并且创建了一个 HttpStream 它包括通向服务器的输入流和输出流。</p><h3 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h3><h4 id="Application-Interceptor"><a href="#Application-Interceptor" class="headerlink" title="Application Interceptor"></a>Application Interceptor</h4><p>在 retryAndFollowUpInterceptor 之前，处于拦截器第一个位置。</p><p>它是第一个触发拦截的，这里拦截到的 url 请求的信息都是最原始的信息。所以我们可以在该拦截器中添加一些我们请求中需要的通用信息，打印一些我们需要的日志。可以定义多个这样的拦截器，例如一个处理 header 信息，一个处理 接口请求的 加解密 。</p><h4 id="NetwrokInterceptor"><a href="#NetwrokInterceptor" class="headerlink" title="NetwrokInterceptor"></a>NetwrokInterceptor</h4><p>在 ConnectInterceptor 和 CallServerInterceptor 之间，处于拦截器倒数第二个位置。</p><p>会经过 RetryAndFollowIntercptor 进行重定向并且也会通过 BridgeInterceptor 进行 request 请求头和 响应 resposne 的处理，因此这里可以得到的是更多的信息。在打印结果可以看到它内部重定向操作和失败重试，这里会有比 Application Interceptor 更多的日志。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;是对 Socket 的封装。URLConnection 在 4.4 以后底层也使用了 OkHttp。&lt;/p&gt;
&lt;p&gt;Android 源码中 /external/okhttp/jarjar-rules.txt 中表示 com.squareup 开关的包会在编译时打包成 com
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="OkHttp" scheme="https://codepoem.github.io/tags/OkHttp/"/>
    
      <category term="网络" scheme="https://codepoem.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>简析Glide</title>
    <link href="https://codepoem.github.io/post/%E7%AE%80%E6%9E%90Glide/"/>
    <id>https://codepoem.github.io/post/简析Glide/</id>
    <published>2019-10-17T03:25:23.000Z</published>
    <updated>2021-08-01T03:31:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>最简洁的图片加载流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Glide.with(context)<br>    .load(myUrl)<br>    .into(imageView);<br></code></pre></td></tr></table></figure><ol><li>with 传递图片加载上下文，获取图片加载请求管理器（RequestManager）。</li><li>load 传递图片加载数据源，构建图片加载请求建造器（RequestBuilder）。</li><li>into 传递图片加载目标载体，创建图片加载请求（Request），执行图片加载。</li></ol><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>with 支持传递 Context，Activity，Fragment，Glide 4.0.0 版本后 with 还支持传递 View。</p><ol><li>如果是子线程，会使用 ApplicationContext。</li><li>传递 Context 如果是 ContextWrapper 直接会优先向上遍历得到 Activity。</li><li>传递 View ，会优先向上遍历得到 Activity，然后根据得到的 Activity 优先遍历得到 Fragment。</li></ol><h3 id="传入-ApplicationContext"><a href="#传入-ApplicationContext" class="headerlink" title="传入 ApplicationContext"></a>传入 ApplicationContext</h3><p>Application 对象的生命周期即应用程序的生命周期，因此 Glide 并不需要做什么特殊的处理，它自动就是和应用程序的生命周期是同步的。</p><h3 id="传入非-ApplicationContext"><a href="#传入非-ApplicationContext" class="headerlink" title="传入非 ApplicationContext"></a>传入非 ApplicationContext</h3><p>无视图的 Fragment 接管 LifeCycle。</p><h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><h3 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h3><ol><li>根据图片地址，宽高，变换，签名等生成 key。</li><li>根据 key 从活动缓存取图片资源。取到则完成；取不到进行下一步。</li><li>根据 key 从内存缓存（LRU 实现）。取到则将取到的图片资源添加到活动缓存，完成；取不到进行下一步。</li><li>返回 null，表示未取到。</li></ol><ul><li><p>LRU 缓存。LruCache 算法（Least Recently Used），也叫近期最少使用算法。算法原理就是把最近使用的对象用强引用存储在 LinkedHashMap 中，并且把最近最少使用的对象在缓存值达到预设定值之前从内存中移除。</p></li><li><p>活跃缓存。弱引用缓存正在使用的图片，可以保护这些图片不会被 LruCache 算法回收掉。</p></li></ul><p>缓存写入时机：</p><ul><li>图片资源执行完加载解码后，写入活跃缓存。</li><li>图片资源回收且引用数为 0，先从活跃缓存中删除，后写入 LRU 缓存。</li></ul><h3 id="硬盘缓存"><a href="#硬盘缓存" class="headerlink" title="硬盘缓存"></a>硬盘缓存</h3><p>DiskCacheStrategy.NONE： 表示不缓存任何内容。<br>DiskCacheStrategy.SOURCE： 表示只缓存原始图片。<br>DiskCacheStrategy.RESULT： 表示只缓存转换过后的图片（默认选项）。<br>DiskCacheStrategy.ALL ： 表示既缓存原始图片，也缓存转换过后的图片。</p><p>DiskLruCache，journal 文件。</p><p>journal 文件组成：</p><ul><li>libcore.io.DiskLruCache （魔法值，标志着使用 DiskLruCache 技术）</li><li>DiskLruCache 版本号</li><li>应用版本号</li><li>DIRTY 数据行（正在写数据）</li><li>CLEAN 数据行（写入数据成功）</li><li>REMOVE 数据行（写入数据失败）</li><li>READ 数据行（读取数据）</li></ul><h2 id="Bitmap-采样和复用机制"><a href="#Bitmap-采样和复用机制" class="headerlink" title="Bitmap 采样和复用机制"></a>Bitmap 采样和复用机制</h2><h3 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h3><ol><li>计算缩放因子</li><li>获取采样类型 内存优先（比要求的尺寸小）/ 质量优先（比要求的尺寸大）</li><li>计算整型的缩放因子</li><li>将整型的缩放因子转成 2 的幂</li></ol><h3 id="复用机制"><a href="#复用机制" class="headerlink" title="复用机制"></a>复用机制</h3><p>BitmapPool，默认具体实现 LruBitmapPool。</p><p>不光对开销较大的 Bitmap 进行了复用，就连为了复用 Bitmap 时重复申请的 Key 对象都进行了复用，尽可能的减少了对象的创建开销，保证了应用的流畅性。</p><h4 id="复用的前提"><a href="#复用的前提" class="headerlink" title="复用的前提"></a>复用的前提</h4><p>inMutable = true<br>inBitmap 指定复用的 Bitmap</p><p>在 Android 4.4 之前，仅支持相同大小的 bitmap，inSampleSize 必须为 1，而且必须采用 jpeg 或 png 格式。</p><p>在 Android 4.4 之后只有一个限制，就是被复用的 bitmap 尺寸要大于新的 bitmap，简单来说就是大图可以给小图复用。</p><h4 id="复用实现"><a href="#复用实现" class="headerlink" title="复用实现"></a>复用实现</h4><p>根据特定的缓存策略，根据系统版本如判断采用完全匹配或者大小匹配，从缓存池获取到 Dirty 的 Bitmap，使用 reconfigure 和 eraseColor(Color.TRANSPARENT) 来 clean 这个 Bitmap。</p><ol><li>加入复用池时机：外部加载完或者回收调用放入</li><li>获取缓存时机：加载图片前</li><li>删除，每次操作都会判断是否需要删除多余的缓存</li></ol><h2 id="线程池管理"><a href="#线程池管理" class="headerlink" title="线程池管理"></a>线程池管理</h2><ul><li>diskCacheExecutor 本地缓存任务 newDiskCacheBuilder corePoolSize=maximumPoolSize=1</li><li>sourceExecutor 资源获取任务 corePoolSize=maximumPoolSize=处理器数量和固定值 4 之间区最小</li><li>sourceUnlimitedExecutor 资源获取不限制任务 corePoolSize=0 maximumPoolSize=Integer.MAX_VALUE 10ms 超时 SynchronousQueue</li><li>animationExecutor Gif 加载任务 corePoolSize=在处理器数量和固定值 4 之间区最小 maximumPoolSize=1 或 2</li></ul><p>除了 sourceUnlimitedExecutor 都使用了 PriorityBlockingQueue 来作为等待队列。</p><h2 id="使用自定义模块解耦"><a href="#使用自定义模块解耦" class="headerlink" title="使用自定义模块解耦"></a>使用自定义模块解耦</h2><ul><li><p>setMemoryCache()<br>用于配置 Glide 的内存缓存策略，默认配置是 LruResourceCache。</p></li><li><p>setBitmapPool()<br>用于配置 Glide 的 Bitmap 缓存池，默认配置是 LruBitmapPool。</p></li><li><p>setDiskCache()<br>用于配置 Glide 的硬盘缓存策略，默认配置是 InternalCacheDiskCacheFactory。</p></li><li><p>setDiskCacheService()<br>用于配置 Glide 读取缓存中图片的异步执行器，默认配置是 FifoPriorityThreadPoolExecutor，也就是先入先出原则。</p></li><li><p>setResizeService()<br>用于配置 Glide 读取非缓存中图片的异步执行器，默认配置也是 FifoPriorityThreadPoolExecutor。</p></li><li><p>setDecodeFormat()<br>用于配置 Glide 加载图片的解码模式，默认配置是 RGB_565。</p></li></ul><p>Glide 3:</p><ol><li>自定义模块类，实现 GlideModule 。</li><li>AndroidManifest.xml 中配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span>&gt;</span><br><br>    ...<br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">application</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.example.glidetest.MyGlideModule&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:value</span>=<span class="hljs-string">&quot;GlideModule&quot;</span> /&gt;</span><br><br>        ...<br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><p>解析 AndroidManifest.xml 中 value 为 GlideModule 的 meta-data ,反射实例化自定义模块类。Glide 在实例化的时候会先遍历模块列表应用配置。</p><p>Glide 4:</p><ol><li>自定义模块类，继承 AppGlideModule 。</li><li>自定义模块类上添加 @GlideModule 注解。</li></ol><p>注解处理器 auto-service + JavaPoet</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最简洁的图片加载流程：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="图片" scheme="https://codepoem.github.io/tags/%E5%9B%BE%E7%89%87/"/>
    
      <category term="Glide" scheme="https://codepoem.github.io/tags/Glide/"/>
    
  </entry>
  
  <entry>
    <title>简析Bitmap</title>
    <link href="https://codepoem.github.io/post/%E7%AE%80%E6%9E%90Bitmap/"/>
    <id>https://codepoem.github.io/post/简析Bitmap/</id>
    <published>2019-10-16T03:25:23.000Z</published>
    <updated>2019-10-16T03:25:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>基于 9.0（29）简析 Bitmap 类。</p><p>我们只关注 Bitmap 类暴露出来的（即访问权限为 public）东西。</p><ul><li>枚举类 Config</li><li>枚举类 CompressFormat</li><li>若干 createBitmap 静态方法</li><li>其他方法</li></ul><h2 id="枚举类-Config"><a href="#枚举类-Config" class="headerlink" title="枚举类 Config"></a>枚举类 Config</h2><p>可能的 bitmap 配置。bitmap 配置描述像素的存储方式。这会影响质量（颜色深度）以及显示透明/半透明颜色的能力。</p><table><thead><tr><th>Config</th><th>每个像素占用字节数</th><th>表示颜色种数</th><th>说明</th></tr></thead><tbody><tr><td>ALPHA_8</td><td>1 个字节，A 分量占 8 位，不存储颜色信息</td><td>0</td><td>单透明通道</td></tr><tr><td>RGB_565</td><td>两个字节，R 分量占 5 位，G 分量占 6 位，B 分量占 5 位</td><td>2^16(65536)</td><td>简易 RGB 色调</td></tr><tr><td>RGB_888</td><td>三个字节，R、G、B 分量各占 8 位</td><td>2^24(16777216)</td><td>RGB 色调</td></tr><tr><td>ARGB_4444</td><td>两个字节，A、R、G、B 分量各占 4 位</td><td>2^12(4096)</td><td>已弃用，成像效果比较差，并且 v4.4+后如果使用了它会自动转成用 ARGB_8888。</td></tr><tr><td>ARGB_8888</td><td>四个字节，A、R、G、B 分量各占 8 位</td><td>2^24(16777216)</td><td>24 位真彩色，Android 中默认的配置</td></tr><tr><td>RGBA_F16</td><td>八个字节，A、R、G、B 分量各占 16 位</td><td>2^48(281474976710656)</td><td>特别适合于宽色域和 HDR 内容，在 8.0（api 26）引入。</td></tr><tr><td>HARDWARE</td><td>-</td><td>-</td><td>特殊配置。bitmap 始终存储在图形内存中，在 8.0（api 26）引入。</td></tr></tbody></table><h2 id="枚举类-CompressFormat"><a href="#枚举类-CompressFormat" class="headerlink" title="枚举类 CompressFormat"></a>枚举类 CompressFormat</h2><p>指定可以将 bitmap 压缩为的已知格式。</p><ul><li>JPEG</li><li>PNG</li><li>WEBP</li></ul><h2 id="若干-createBitmap-静态方法"><a href="#若干-createBitmap-静态方法" class="headerlink" title="若干 createBitmap 静态方法"></a>若干 createBitmap 静态方法</h2><h3 id="public-static-Bitmap-wrapHardwareBuffer-NonNull-HardwareBuffer-hardwareBuffer-Nullable-ColorSpace-colorSpace"><a href="#public-static-Bitmap-wrapHardwareBuffer-NonNull-HardwareBuffer-hardwareBuffer-Nullable-ColorSpace-colorSpace" class="headerlink" title="public static Bitmap wrapHardwareBuffer(@NonNull HardwareBuffer hardwareBuffer, @Nullable ColorSpace colorSpace)"></a>public static Bitmap wrapHardwareBuffer(@NonNull HardwareBuffer hardwareBuffer, @Nullable ColorSpace colorSpace)</h3><p>创建由 HardwareBuffer 支持的硬件位图。</p><p>传递的 HardwareBuffer 使用标志必须包含 HardwareBuffer.USAGE_GPU_SAMPLED_IMAGE。</p><p>bitmap 将保留对缓冲区的引用，以便调用者可以安全地关闭 HardwareBuffer 而不会影响 bitmap 。但是，在包装 bitmap 访问硬件缓冲区时，不能对其进行修改。这样做将导致不确定的行为。</p><ul><li>HardwareBuffer hardwareBuffer：包装的 HardwareBuffer。</li><li>ColorSpace colorSpace：bitmap 的颜色空间。必须是 ColorSpace.Rgb 颜色空间。如果为 null ，则假定为 SRGB。</li></ul><h3 id="public-static-Bitmap-createScaledBitmap-NonNull-Bitmap-src-int-dstWidth-int-dstHeight-boolean-filter"><a href="#public-static-Bitmap-createScaledBitmap-NonNull-Bitmap-src-int-dstWidth-int-dstHeight-boolean-filter" class="headerlink" title="public static Bitmap createScaledBitmap(@NonNull Bitmap src, int dstWidth, int dstHeight, boolean filter)"></a>public static Bitmap createScaledBitmap(@NonNull Bitmap src, int dstWidth, int dstHeight, boolean filter)</h3><p>如果可能，创建一个新的 bitmap ，从现有的 bitmap 缩放。如果指定的宽度和高度与源位图的当前宽度和高度相同，则返回源位图，并且不创建新的位图。</p><ul><li>Bitmap src：源 bitmap。</li><li>int dstWidth：新 bitmap 的所需宽度</li><li>int dstHeight：新 bitmap 的所需高度</li><li>boolean filter：缩放 bitmap 时是否使用双线性滤波。如果为 true ，则在缩放时将使用双线性滤波，从而以较差的性能为代价来获得更好的图像质量。如果为 false ，则使用邻近采样缩放，这将使图像质量较差，但速度更快。推荐的默认值是将设置为 true，因为双线性滤镜的成本通常很小，并且改善的图像质量非常重要。</li></ul><h3 id="public-static-Bitmap-createBitmap-NonNull-Bitmap-src"><a href="#public-static-Bitmap-createBitmap-NonNull-Bitmap-src" class="headerlink" title="public static Bitmap createBitmap(@NonNull Bitmap src)"></a>public static Bitmap createBitmap(@NonNull Bitmap src)</h3><p>重载 Bitmap createBitmap(@NonNull Bitmap source, int x, int y, int width, int height)</p><p>createBitmap(src, 0, 0, src.getWidth(), src.getHeight());</p><h3 id="public-static-Bitmap-createBitmap-NonNull-Bitmap-source-int-x-int-y-int-width-int-height"><a href="#public-static-Bitmap-createBitmap-NonNull-Bitmap-source-int-x-int-y-int-width-int-height" class="headerlink" title="public static Bitmap createBitmap(@NonNull Bitmap source, int x, int y, int width, int height)"></a>public static Bitmap createBitmap(@NonNull Bitmap source, int x, int y, int width, int height)</h3><p>重载 Bitmap createBitmap(@NonNull Bitmap source, int x, int y, int width, int height, @Nullable Matrix m, boolean filter)</p><p>createBitmap(source, x, y, width, height, null, false);</p><h3 id="public-static-Bitmap-createBitmap-NonNull-Bitmap-source-int-x-int-y-int-width-int-height-Nullable-Matrix-m-boolean-filter"><a href="#public-static-Bitmap-createBitmap-NonNull-Bitmap-source-int-x-int-y-int-width-int-height-Nullable-Matrix-m-boolean-filter" class="headerlink" title="public static Bitmap createBitmap(@NonNull Bitmap source, int x, int y, int width, int height, @Nullable Matrix m, boolean filter)"></a>public static Bitmap createBitmap(@NonNull Bitmap source, int x, int y, int width, int height, @Nullable Matrix m, boolean filter)</h3><p>从源 bitmap 返回一个 bitmap 。新的 bitmap 可能与源 bitmap 是同一对象，或者可能已复制。使用与源 bitmap 相同的密度和色彩空间进行初始化。</p><p>如果源 bitmap 是不可变的，并且所请求的子集与源 bitmsp 本身相同，则返回源 bitmap ，并且不会创建新 bitmap 。</p><p>除非在以下情况下，否则返回的 bitmap 将始终是可变的：<br>（1）在返回源 bitmap 且源 bitmap 不可变的情况下<br>（2）源 bitmap 是硬件 bitmap 。即 getConfig() = Config.HARDWARE 。</p><ul><li>Bitmap source：源 bitmap 。</li><li>int x：源中第一个像素的 x 坐标</li><li>int y：源中第一个像素的 y 坐标</li><li>int width：每行像素数</li><li>int height：行数</li><li>Matrix m：应用于像素的可选矩阵</li><li>boolean filter：是否使用双线性滤波，则为 true。仅在矩阵包含的不仅仅是平移时适用。</li></ul><h3 id="public-static-Bitmap-createBitmap-int-width-int-height-NonNull-Config-config"><a href="#public-static-Bitmap-createBitmap-int-width-int-height-NonNull-Config-config" class="headerlink" title="public static Bitmap createBitmap(int width, int height, @NonNull Config config)"></a>public static Bitmap createBitmap(int width, int height, @NonNull Config config)</h3><p>重载 Bitmap createBitmap(int width, int height, @NonNull Config config, boolean hasAlpha)</p><p>createBitmap(null, width, height, config, hasAlpha)</p><h3 id="public-static-Bitmap-createBitmap-Nullable-DisplayMetrics-display-int-width-int-height-NonNull-Config-config"><a href="#public-static-Bitmap-createBitmap-Nullable-DisplayMetrics-display-int-width-int-height-NonNull-Config-config" class="headerlink" title="public static Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config)"></a>public static Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config)</h3><p>重载 Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config, boolean hasAlpha)</p><p>createBitmap(display, width, height, config, true);</p><h3 id="public-static-Bitmap-createBitmap-int-width-int-height-NonNull-Config-config-boolean-hasAlpha"><a href="#public-static-Bitmap-createBitmap-int-width-int-height-NonNull-Config-config-boolean-hasAlpha" class="headerlink" title="public static Bitmap createBitmap(int width, int height, @NonNull Config config, boolean hasAlpha)"></a>public static Bitmap createBitmap(int width, int height, @NonNull Config config, boolean hasAlpha)</h3><p>重载 Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config, boolean hasAlpha)</p><p>createBitmap(null, width, height, config, hasAlpha);</p><h3 id="public-static-Bitmap-createBitmap-int-width-int-height-NonNull-Config-config-boolean-hasAlpha-NonNull-ColorSpace-colorSpace"><a href="#public-static-Bitmap-createBitmap-int-width-int-height-NonNull-Config-config-boolean-hasAlpha-NonNull-ColorSpace-colorSpace" class="headerlink" title="public static Bitmap createBitmap(int width, int height, @NonNull Config config, boolean hasAlpha, @NonNull ColorSpace colorSpace)"></a>public static Bitmap createBitmap(int width, int height, @NonNull Config config, boolean hasAlpha, @NonNull ColorSpace colorSpace)</h3><p>重载 Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config, boolean hasAlpha, @NonNull ColorSpace colorSpace)</p><p>createBitmap(null, width, height, config, hasAlpha, colorSpace);</p><h3 id="public-static-Bitmap-createBitmap-Nullable-DisplayMetrics-display-int-width-int-height-NonNull-Config-config-boolean-hasAlpha"><a href="#public-static-Bitmap-createBitmap-Nullable-DisplayMetrics-display-int-width-int-height-NonNull-Config-config-boolean-hasAlpha" class="headerlink" title="public static Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config, boolean hasAlpha)"></a>public static Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config, boolean hasAlpha)</h3><p>重载 Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config, boolean hasAlpha, @NonNull ColorSpace colorSpace)</p><p>createBitmap(display, width, height, config, hasAlpha, ColorSpace.get(ColorSpace.Named.SRGB));</p><h3 id="public-static-Bitmap-createBitmap-Nullable-DisplayMetrics-display-int-width-int-height-NonNull-Config-config-boolean-hasAlpha-NonNull-ColorSpace-colorSpace"><a href="#public-static-Bitmap-createBitmap-Nullable-DisplayMetrics-display-int-width-int-height-NonNull-Config-config-boolean-hasAlpha-NonNull-ColorSpace-colorSpace" class="headerlink" title="public static Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config, boolean hasAlpha, @NonNull ColorSpace colorSpace)"></a>public static Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config, boolean hasAlpha, @NonNull ColorSpace colorSpace)</h3><p>返回具有指定宽度和高度的可变 bitmap。它的初始密度由给定的 DisplayMetrics 确定。新创建的 bitmap 位于 ColorSpace.Named.SRGB 颜色空间中。</p><ul><li>DisplayMetrics display：将被绘制的 bitmap 的显示的显示度量。</li><li>int width：bitmap 的宽度。</li><li>int height：bitmap 的高度。</li><li>Config config：创建的 bitmap 的配置。</li><li>boolean hasAlpha：如果 bitmap 是 ARGB_8888 或 RGBA_16F ，则此标志可用于将 bitmap 标记为不透明。这样做将以黑色而不是透明的方式清除 bitmap。</li><li>ColorSpace colorSpace：bitmap 的颜色空间。如果配置为 Config.RGBA_F16 和 ColorSpace.Named.SRGB sRGB 或 ColorSpace.Named.LINEAR_SRGB ，则假定为相应的扩展范围变体。</li></ul><h3 id="public-static-Bitmap-createBitmap-NonNull-ColorInt-int-colors-int-offset-int-stride-int-width-int-height-NonNull-Config-config"><a href="#public-static-Bitmap-createBitmap-NonNull-ColorInt-int-colors-int-offset-int-stride-int-width-int-height-NonNull-Config-config" class="headerlink" title="public static Bitmap createBitmap(@NonNull @ColorInt int[] colors, int offset, int stride, int width, int height, @NonNull Config config)"></a>public static Bitmap createBitmap(@NonNull @ColorInt int[] colors, int offset, int stride, int width, int height, @NonNull Config config)</h3><p>重载 Bitmap createBitmap(@NonNull DisplayMetrics display, @NonNull @ColorInt int[] colors, int offset, int stride, int width, int height, @NonNull Config config)</p><p>createBitmap(null, colors, offset, stride, width, height, config)</p><h3 id="public-static-Bitmap-createBitmap-NonNull-DisplayMetrics-display-NonNull-ColorInt-int-colors-int-offset-int-stride-int-width-int-height-NonNull-Config-config"><a href="#public-static-Bitmap-createBitmap-NonNull-DisplayMetrics-display-NonNull-ColorInt-int-colors-int-offset-int-stride-int-width-int-height-NonNull-Config-config" class="headerlink" title="public static Bitmap createBitmap(@NonNull DisplayMetrics display, @NonNull @ColorInt int[] colors, int offset, int stride, int width, int height, @NonNull Config config)"></a>public static Bitmap createBitmap(@NonNull DisplayMetrics display, @NonNull @ColorInt int[] colors, int offset, int stride, int width, int height, @NonNull Config config)</h3><p>返回具有指定宽度和高度的不可变 bitmap，每个像素值设置为 colors 数组中的相应值。它的初始密度由给定的 DisplayMetrics 确定。新创建的 bitmap 位于 ColorSpace.Named.SRGB 颜色空间中。</p><ul><li>DisplayMetrics display：将被绘制的 bitmap 的显示的显示度量。</li><li>@ColorInt int[] colors：sRGB Color 数组，用于初始化像素。</li><li>int offset：颜色数组中第一个颜色之前要跳过的值数。</li><li>int stride：行之间数组中的颜色数（必须为 &gt;= width 或 &lt;= -width）。</li><li>int width：bitmap 的宽度。</li><li>int height：bitmap 的高度。</li><li>Config config：创建的 bitmap 的配置。如果配置不支持每像素的 alpha（例如 RGB_565），那么 colors []中的 alpha 字节将被忽略（假定为 FF）</li></ul><h3 id="public-static-Bitmap-createBitmap-NonNull-ColorInt-int-colors-int-width-int-height-Config-config"><a href="#public-static-Bitmap-createBitmap-NonNull-ColorInt-int-colors-int-width-int-height-Config-config" class="headerlink" title="public static Bitmap createBitmap(@NonNull @ColorInt int[] colors, int width, int height, Config config)"></a>public static Bitmap createBitmap(@NonNull @ColorInt int[] colors, int width, int height, Config config)</h3><p>重载 Bitmap createBitmap(@NonNull DisplayMetrics display, @NonNull @ColorInt int[] colors, int offset, int stride, int width, int height, @NonNull Config config)</p><p>createBitmap(null, colors, 0, width, width, height, config);</p><h3 id="public-static-Bitmap-createBitmap-Nullable-DisplayMetrics-display-NonNull-ColorInt-int-colors-int-width-int-height-NonNull-Config-config"><a href="#public-static-Bitmap-createBitmap-Nullable-DisplayMetrics-display-NonNull-ColorInt-int-colors-int-width-int-height-NonNull-Config-config" class="headerlink" title="public static Bitmap createBitmap(@Nullable DisplayMetrics display, @NonNull @ColorInt int colors[], int width, int height, @NonNull Config config)"></a>public static Bitmap createBitmap(@Nullable DisplayMetrics display, @NonNull @ColorInt int colors[], int width, int height, @NonNull Config config)</h3><p>重载 Bitmap createBitmap(@NonNull DisplayMetrics display, @NonNull @ColorInt int[] colors, int offset, int stride, int width, int height, @NonNull Config config)</p><p>createBitmap(display, colors, 0, width, width, height, config);</p><h3 id="public-static-NonNull-Bitmap-createBitmap-NonNull-Picture-source"><a href="#public-static-NonNull-Bitmap-createBitmap-NonNull-Picture-source" class="headerlink" title="public static @NonNull Bitmap createBitmap(@NonNull Picture source)"></a>public static @NonNull Bitmap createBitmap(@NonNull Picture source)</h3><p>重载 Bitmap createBitmap(@NonNull Picture source, int width, int height, @NonNull Config config)</p><p>createBitmap(source, source.getWidth(), source.getHeight(), Config.HARDWARE);</p><h3 id="public-static-NonNull-Bitmap-createBitmap-NonNull-Picture-source-int-width-int-height-NonNull-Config-config"><a href="#public-static-NonNull-Bitmap-createBitmap-NonNull-Picture-source-int-width-int-height-NonNull-Config-config" class="headerlink" title="public static @NonNull Bitmap createBitmap(@NonNull Picture source, int width, int height, @NonNull Config config)"></a>public static @NonNull Bitmap createBitmap(@NonNull Picture source, int width, int height, @NonNull Config config)</h3><p>从记录的绘图命令中给定 Picture 源创建 bitmap。</p><p>在给定的宽度和高度下，bitmap 将不可变。如果宽度和高度与图片的宽度和高度不同，则图片将缩放以适应给定的宽度和高度。</p><ul><li>Picture source：记录的绘图命令 Picture 将会被绘制到返回的 bitmap 中</li><li>int width：要创建的 bitmap 的宽度。图片的宽度将根据需要缩放以匹配。</li><li>int height：要创建的 bitmap 的高度。图片的高度将根据需要缩放以匹配。</li><li>Config config：创建的 bitmap 的配置。</li></ul><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><h3 id="int-getDensity"><a href="#int-getDensity" class="headerlink" title="int getDensity()"></a>int getDensity()</h3><p>返回此 bitmap 的密度。</p><p>默认密度与当前显示的密度相同，除非当前应用程序不支持不同的屏幕密度，这种情况下默认密度为 android.util.DisplayMetric.DENSITY_DEFAULT = DENSITY_MEDIUM = 160。请注意，兼容性模式由最初加载到进程中的应用程序确定-共享同一进程的应用程序应该全部具有相同的兼容性，或者确保它们适当地显式设置其 bitmap 的密度。</p><h3 id="void-setDensity-int-density"><a href="#void-setDensity-int-density" class="headerlink" title="void setDensity(int density)"></a>void setDensity(int density)</h3><p>指定此 bitmap 的密度。当 bitmap 绘制到也具有密度的 Canvas 时，它将适当缩放。</p><ul><li>int densit：该 bitmap 使用的密度缩放因子；如果密度未知，则使用 DENSITY_NONE = 0。</li></ul><h3 id="void-reconfigure-int-width-int-height-Config-config"><a href="#void-reconfigure-int-width-int-height-Config-config" class="headerlink" title="void reconfigure(int width, int height, Config config)"></a>void reconfigure(int width, int height, Config config)</h3><p>将 bitmap 修改为具有指定的宽度，高度和 Config ，而不影响该 bitmap 的底层分配。 对于新配置，bitmap 像素数据未重新初始化。</p><p>此方法可用于避免分配新的 bitmap，而是将现有 bitmap 的分配重用于大小等于或小于的新配置。如果 bitmap 的分配不足以支持新配置，则将抛出 IllegalArgumentException，并且 bitmap 将不会被修改。</p><p>getByteCount（）的结果将反映新的配置，而 getAllocationByteCount（）的结果将反映初始的配置。</p><p>注意：这可能会更改 hasAlpha（）的结果。当转换为 565 时，新的 bitmap 将始终被视为不透明的。从 565 转换时，新的 bitmap 将被认为是不透明的，并且将遵循由 setPremultiplied（）设置的值。</p><p>警告：不应在当前正在 view 系统、Canvas 或 AndroidBitmap NDK API 使用的 bitmap 上调用此方法。它不能保证基础像素缓冲区如何重新映射到新配置，而只是保证分配已被重用。此外，view 系统无法确定使用过程中正在修改的 bitmap 属性，例如何时附着在 drawables 上。</p><p>为了安全地确保 view 系统不再使用 bitmap，必须等待正在 invalidate（）的任何在最后的绘制过程中由于硬件加速对绘制命令的缓存已经在之前绘制过此 bitmap 的 view 完成绘制过程。举一个例子，以下是以 ImageView 完成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">ImageView myImageView = ...;<br><span class="hljs-keyword">final</span> Bitmap myBitmap = ...;<br>myImageView.setImageDrawable(<span class="hljs-keyword">null</span>);<br>myImageView.post(<span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// myBitmap is now no longer in use by the ImageView</span><br>        <span class="hljs-comment">// and can be safely reconfigured.</span><br>        myBitmap.reconfigure(...);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="void-setWidth-int-width"><a href="#void-setWidth-int-width" class="headerlink" title="void setWidth(int width)"></a>void setWidth(int width)</h3><p>使用当前已有高度和配置调用 reconfigure（int，int，Config）的便捷方法。</p><p>警告：此方法不应在 view 系统当前使用的 bitmap 上使用，有关更多详细信息，请参见 reconfigure（int，int，Config）。</p><h3 id="void-setHeight-int-height"><a href="#void-setHeight-int-height" class="headerlink" title="void setHeight(int height)"></a>void setHeight(int height)</h3><p>使用当前已有宽度和配置调用 reconfigure（int，int，Config）的便捷方法。</p><p>警告：此方法不应在 view 系统当前使用的 bitmap 上使用，有关更多详细信息，请参见 reconfigure（int，int，Config）。</p><h3 id="void-setConfig-Config-config"><a href="#void-setConfig-Config-config" class="headerlink" title="void setConfig(Config config)"></a>void setConfig(Config config)</h3><p>使用当前已有宽度和高度调用 reconfigure（int，int，Config）的便捷方法。</p><p>警告：此方法不应在 view 系统当前使用的 bitmap 上使用，有关更多详细信息，请参见 reconfigure（int，int，Config）。</p><h3 id="void-setNinePatchChunk-byte-chunk"><a href="#void-setNinePatchChunk-byte-chunk" class="headerlink" title="void setNinePatchChunk(byte[] chunk)"></a>void setNinePatchChunk(byte[] chunk)</h3><p>设置.9 图数据块。</p><ul><li>byte[] chunk .9 图相关定义数据块</li></ul><h3 id="void-recycle"><a href="#void-recycle" class="headerlink" title="void recycle()"></a>void recycle()</h3><p>释放与此 bitmap 关联的 native 对象，并清除对像素数据的引用。这将不会同步释放像素数据。 如果没有其他引用，它只是允许对其进行垃圾回收。bitmap 被标记为“死亡”，这意味着如果 getPixels（）或 setPixels（）被调用，它将抛出异常，并且不会绘制任何内容。 此操作不能撤消，因此只有在确定 bitmap 没有进一步用途时才应调用它。这是一个高级调用，通常不需要，因为当没有更多对该 bitmap 的引用时，正常的 GC 进程将释放此内存。</p><h3 id="boolean-isRecycled"><a href="#boolean-isRecycled" class="headerlink" title="boolean isRecycled()"></a>boolean isRecycled()</h3><p>如果此 bitmap 已被回收，则返回 true。如果是被回收，则尝试访问其像素是一个错误，并且 bitmap 将不会绘制。</p><h3 id="int-getGenerationId"><a href="#int-getGenerationId" class="headerlink" title="int getGenerationId()"></a>int getGenerationId()</h3><p>返回此 bitmap 的生成 ID。只要修改 bitmap，生成 ID 就会改变。这是一个可用于检查 bitmap 是否已更改的高效方法。</p><h3 id="void-copyPixelsToBuffer-Buffer-dst"><a href="#void-copyPixelsToBuffer-Buffer-dst" class="headerlink" title="void copyPixelsToBuffer(Buffer dst)"></a>void copyPixelsToBuffer(Buffer dst)</h3><p>将 bitmap 的像素复制到指定的缓冲区（由调用者分配）。如果缓冲区的大小不足以容纳所有像素（考虑到每个像素的字节数），或者如果 Buffer 子类不是支持类型之一（ByteBuffer，ShortBuffer，IntBuffer），则抛出异常。</p><p>bitmap 的内容按原样复制到缓冲区中。这意味着如果该 bitmap 存储了预乘的像素（请参见 isPremultiplied()），则缓冲区中的值也将被预乘。像素保留在 bitmap 的颜色空间中）。</p><p>返回此方法后，将更新缓冲区的当前位置：位置将增加写入缓冲区的元素数量。</p><h3 id="void-copyPixelsFromBuffer-Buffer-src"><a href="#void-copyPixelsFromBuffer-Buffer-src" class="headerlink" title="void copyPixelsFromBuffer(Buffer src)"></a>void copyPixelsFromBuffer(Buffer src)</h3><p>从当前位置开始，从缓冲区复制像素，覆盖 bitmap 的像素。缓冲区中的数据不会以任何方式更改（不同于 setPixels（），后者会从未预乘的 32bit 转换为 bitmap 的 native 格式。源缓冲区中的像素假定位于 bitmap 的色彩空间中）。</p><p>返回此方法后，将更新缓冲区的当前位置：该位置将增加从缓冲区读取的元素数。如果需要再次从缓冲区读取 bitmap，则必须首先倒带缓冲区。</p><h3 id="Bitmap-copy-Config-config-boolean-isMutable"><a href="#Bitmap-copy-Config-config-boolean-isMutable" class="headerlink" title="Bitmap copy(Config config, boolean isMutable)"></a>Bitmap copy(Config config, boolean isMutable)</h3><p>尝试根据此 bitmap 的尺寸制作一个新的 bitmap，将新 bitmap 的配置设置为指定的配置，然后将该 bitmap 的像素复制到新的位图中。如果不支持转换，或者分配器失败，则返回 NULL 。返回的 bitmap 具有与原始 bitmap 相同的密度和色彩空间，以下情况除外。复制到 Config.ALPHA_8 时，颜色空间将被删除。复制到 Config.RGBA_F16 或从 Config.RGBA_F16 复制时， EXTENDED 或 non-EXTENDED 变体可能会适当调整。</p><ul><li>Config config：生成的 bitmap 所需的配置。</li><li>boolean isMutable：是否结果 bitmap 是可变的（即像素可以修改）。</li></ul><h3 id="byte-getNinePatchChunk"><a href="#byte-getNinePatchChunk" class="headerlink" title="byte[] getNinePatchChunk()"></a>byte[] getNinePatchChunk()</h3><p>返回一个可选的私有数据数组，UI 系统用于一些 bitmap 。不应由应用程序调用。</p><h3 id="boolean-compress-CompressFormat-format-int-quality-OutputStream-stream"><a href="#boolean-compress-CompressFormat-format-int-quality-OutputStream-stream" class="headerlink" title="boolean compress(CompressFormat format, int quality, OutputStream stream)"></a>boolean compress(CompressFormat format, int quality, OutputStream stream)</h3><p>将 bitmap 的压缩版本写入指定的输出流。如果返回 true，则可以通过将相应的输入流传递给 BitmapFactory.decodeStream（）来重构位图。注意：不是所有格式都直接支持所有 bitmap 配置，因此从 BitmapFactory 返回的 bitmap 可能处于不同的位深中，并且/或者 丢失了每个像素的 alpha（例如 JPEG 仅支持不透明像素）。</p><ul><li>CompressFormat format：压缩图像的格式</li><li>int qualit：给压缩器的提示，0-100。 0 表示压缩已获得最低质量，100 表示 ​​ 压缩以获得最高质量。某些格式（例如无损的 PNG）将忽略该质量设置。</li><li>OutputStream stream：写入压缩数据的输出流。</li></ul><h3 id="final-boolean-isMutable"><a href="#final-boolean-isMutable" class="headerlink" title="final boolean isMutable()"></a>final boolean isMutable()</h3><p>返回 bitmap 是否为可变的。</p><h3 id="final-boolean-isPremultiplied"><a href="#final-boolean-isPremultiplied" class="headerlink" title="final boolean isPremultiplied()"></a>final boolean isPremultiplied()</h3><p>指示是否存储在此 bitmap 中的像素被预乘。 当像素预乘时，RGB 分量已乘以 alpha 分量。例如，如果原始颜色为 50％半透明红色（128，255，0，0），则预乘形式为（128，128，0，0）。</p><p>如果 getConfig() 为 Bitmap.Config.RGB_565 ，则方法始终返回 false。</p><p>如果 getConfig() 为 Bitmap.Config.ALPHA_8 ，则方法返回值不确定。</p><p>仅当 hasAlpha() 返回 true 时，此方法才返回 true 。 没有 alpha 通道的 bitmap 既可以用作预乘位，也可以用作非预乘 bitmap 。</p><p>view 系统或 Canvas 只能绘制预乘的 bitmap。如果将带有 Alpha 通道的非预乘 bitmap 绘制到了 Canvas 上，则会抛出 RuntimeException。</p><h3 id="final-int-getWidth"><a href="#final-int-getWidth" class="headerlink" title="final int getWidth()"></a>final int getWidth()</h3><p>返回 bitmap 的宽度。</p><h3 id="final-int-getHeight"><a href="#final-int-getHeight" class="headerlink" title="final int getHeight()"></a>final int getHeight()</h3><p>返回 bitmap 的高度。</p><h3 id="int-getScaledWidth-Canvas-canvas"><a href="#int-getScaledWidth-Canvas-canvas" class="headerlink" title="int getScaledWidth(Canvas canvas)"></a>int getScaledWidth(Canvas canvas)</h3><p>使用给定 Canva 的目标密度调用 getScaledWidth(int) 的便捷方法。</p><h3 id="int-getScaledHeight-Canvas-canvas"><a href="#int-getScaledHeight-Canvas-canvas" class="headerlink" title="int getScaledHeight(Canvas canvas)"></a>int getScaledHeight(Canvas canvas)</h3><p>使用给定 Canva 的目标密度调用 getScaledWidth(int) 的便捷方法。</p><h3 id="int-getScaledWidth-DisplayMetrics-metrics"><a href="#int-getScaledWidth-DisplayMetrics-metrics" class="headerlink" title="int getScaledWidth(DisplayMetrics metrics)"></a>int getScaledWidth(DisplayMetrics metrics)</h3><p>使用给定 DisplayMetrics 的目标密度调用 getScaledWidth(int) 的便捷方法。</p><h3 id="int-getScaledHeight-DisplayMetrics-metrics"><a href="#int-getScaledHeight-DisplayMetrics-metrics" class="headerlink" title="int getScaledHeight(DisplayMetrics metrics)"></a>int getScaledHeight(DisplayMetrics metrics)</h3><p>使用给定 DisplayMetrics 的目标密度调用 getScaledWidth(int) 的便捷方法。</p><h3 id="int-getScaledWidth-int-targetDensity"><a href="#int-getScaledWidth-int-targetDensity" class="headerlink" title="int getScaledWidth(int targetDensity)"></a>int getScaledWidth(int targetDensity)</h3><p>返回此 bitmap 宽度除以密度比例因子的便捷方法。</p><p>返回 bitmap 的宽度乘以目标密度与 bitmap 的源密度的比率。</p><ul><li>int targetDensity：bitmap 的目标 canvas 的密度。</li></ul><h3 id="int-getScaledHeight-int-targetDensity"><a href="#int-getScaledHeight-int-targetDensity" class="headerlink" title="int getScaledHeight(int targetDensity)"></a>int getScaledHeight(int targetDensity)</h3><p>返回此 bitmap 高度除以密度比例因子的便捷方法。</p><p>返回 bitmap 的高度乘以目标密度与 bitmap 的源密度的比率。</p><ul><li>int targetDensity：bitmap 的目标 canvas 的密度。</li></ul><h3 id="final-int-getRowBytes"><a href="#final-int-getRowBytes" class="headerlink" title="final int getRowBytes()"></a>final int getRowBytes()</h3><p>返回 bitmap 像素中 行之间的字节数。请注意，指的是由 bitmap 由 native 存储的像素。如果调用 getPixels() 或 setPixels() ，则像素将被统一视为 32 位值，并根据 Color 类打包。</p><p>从 android.os.Build.VERSION_CODES.KITKAT （Android 4.4，19）开始，此方法不应用于计算 bitmap 的内存使用情况。而应使用 getAllocationByteCount() 。</p><h3 id="final-int-getByteCount"><a href="#final-int-getByteCount" class="headerlink" title="final int getByteCount()"></a>final int getByteCount()</h3><p>返回可用于存储该 bitmap 像素的最小字节数。</p><p>从 android.os.Build.VERSION_CODES.KITKAT （Android 4.4，19）开始，此方法不应用于计算 bitmap 的内存使用情况。而应使用 getAllocationByteCount() 。</p><h3 id="final-int-getAllocationByteCount"><a href="#final-int-getAllocationByteCount" class="headerlink" title="final int getAllocationByteCount()"></a>final int getAllocationByteCount()</h3><p>返回用于存储此 bitmap 像素的已分配内存的大小。</p><p>如果 bitmap 被重用以解码其他较小尺寸的 bitmap，或者通过手动重新配置，则此结果可能大于 getByteCount() 的结果。请参见 reconfigure(int，int，Config)，setWidth(int) ，setHeight(int) ，setConfig(Bitmap.Config) 和 BitmapFactory.Options.inBitmap 。如果未以这种方式修改 bitmap ，则此值将 getByteCount() 返回的值相同。</p><h3 id="final-Config-getConfig"><a href="#final-Config-getConfig" class="headerlink" title="final Config getConfig()"></a>final Config getConfig()</h3><p>如果 bitmap 的内部配置采用一种公共格式，则返回该配置，否则返回 null 。</p><h3 id="final-boolean-hasAlpha"><a href="#final-boolean-hasAlpha" class="headerlink" title="final boolean hasAlpha()"></a>final boolean hasAlpha()</h3><p>如果 bitmap 的配置支持每个像素的 alpha ，则返回 true；如果像素可能包含非透明的 alpha 值，则返回。对于某些配置，始终为 false（例如 RGB_565），因为它们不支持按像素 alpha。但是，对于需要这样做的配置，可以将 bitmap 标记为知道其所有像素都是不透明的。在这种情况下，hasAlpha（）也将返回 false 。如果未对 ARGB_8888 之类的配置进行标记，则默认情况下将返回 true。</p><h3 id="final-boolean-hasMipMap"><a href="#final-boolean-hasMipMap" class="headerlink" title="final boolean hasMipMap()"></a>final boolean hasMipMap()</h3><p>指示负责绘制此 bitmap 的渲染器是否应按比例缩小 bitmap 图时尝试使用 mipmaps 。</p><p>如果知道要以小于其原始大小的 50％绘制此 bitmap ，则可能可以获得更高的质量。</p><p>此属性只是一个渲染器可以忽略的建议。不能保证有任何效果。</p><h3 id="final-void-setHasMipMap-boolean-hasMipMap"><a href="#final-void-setHasMipMap-boolean-hasMipMap" class="headerlink" title="final void setHasMipMap(boolean hasMipMap)"></a>final void setHasMipMap(boolean hasMipMap)</h3><p>指示负责绘制此 bitmap 的渲染器是否应按比例缩小 bitmap 图时尝试使用 mipmaps 。</p><p>如果知道要以小于其原始大小的 50％绘制此 bitmap ，则可能可以获得更高的质量。</p><p>此属性只是一个渲染器可以忽略的建议。不能保证有任何效果。</p><ul><li>boolean hasMipMap；指示渲染器是否应尝试使用 mipmaps。</li></ul><h3 id="final-ColorSpace-getColorSpace"><a href="#final-ColorSpace-getColorSpace" class="headerlink" title="final ColorSpace getColorSpace()"></a>final ColorSpace getColorSpace()</h3><p>返回与此 bitmap 关联的色彩空间。如果颜色空间未知，则此方法返回 null 。</p><h3 id="void-setColorSpace-NonNull-ColorSpace-colorSpace"><a href="#void-setColorSpace-NonNull-ColorSpace-colorSpace" class="headerlink" title="void setColorSpace(@NonNull ColorSpace colorSpace)"></a>void setColorSpace(@NonNull ColorSpace colorSpace)</h3><p>将 bitmap 识别为具有指定的 ColorSpace ，而不影响 bitma 的底层分配。</p><p>这影响 framework 层如何解释每个像素的颜色。具有 Config.ALPHA_8 的 bitmap 永远不会有颜色空间，因为颜色空间不会影响 a​​lpha 通道。其他 Config 一定具有非 null 的 ColorSpace。</p><h3 id="void-eraseColor-ColorInt-int-c"><a href="#void-eraseColor-ColorInt-int-c" class="headerlink" title="void eraseColor(@ColorInt int c)"></a>void eraseColor(@ColorInt int c)</h3><p>用指定的 Color 填充 bitmap 的像素。</p><h3 id="void-eraseColor-ColorLong-long-color"><a href="#void-eraseColor-ColorLong-long-color" class="headerlink" title="void eraseColor(@ColorLong long color)"></a>void eraseColor(@ColorLong long color)</h3><p>用指定的 ColorLong 填充 bitmap 的像素。</p><h3 id="int-getPixel-int-x-int-y"><a href="#int-getPixel-int-x-int-y" class="headerlink" title="int getPixel(int x, int y)"></a>int getPixel(int x, int y)</h3><p>返回指定位置的 Color 。如果 x 或 y 超出范围（负值或者分别大于等于宽度或高度，则抛出异常）。返回的颜色是 ColorSpace.Named.SRGB 颜色空间中的非预乘 ARGB 值。</p><ul><li>int x：要返回像素的 x 坐标（0 … width-1）。</li><li>int y：要返回像素的 y 坐标（0 … height-1）。</li></ul><h3 id="Color-getColor-int-x-int-y"><a href="#Color-getColor-int-x-int-y" class="headerlink" title="Color getColor(int x, int y)"></a>Color getColor(int x, int y)</h3><p>返回指定位置的 Color 。如果 x 或 y 超出范围（负值或者分别大于等于宽度或高度，则抛出异常）。返回的颜色是 ColorSpace.Named.SRGB 颜色空间中的非预乘 ARGB 值。</p><ul><li>int x：要返回像素的 x 坐标（0 … width-1）。</li><li>int y：要返回像素的 y 坐标（0 … height-1）。</li></ul><h3 id="void-getPixels-ColorInt-int-pixels-int-offset-int-stride-int-x-int-y-int-width-int-height"><a href="#void-getPixels-ColorInt-int-pixels-int-offset-int-stride-int-x-int-y-int-width-int-height" class="headerlink" title="void getPixels(@ColorInt int[] pixels, int offset, int stride, int x, int y, int width, int height)"></a>void getPixels(@ColorInt int[] pixels, int offset, int stride, int x, int y, int width, int height)</h3><p>以 pixel[] 数组的形式返回 bitmap 中数据的副本。每个值都是表示 Color 的包装 int 。 stride 参数允许调用方在行之间的返回像素数组中设置步长。对于正常的打包结果，只需通过宽度作为步长即可。 返回的颜色是 ColorSpace.Named.SRGB 颜色空间中的非预乘 ARGB 值。</p><ul><li>int[] pixels：接收 bitmap 颜色的数组。</li><li>int offset：写入像素的第一个索引[]。</li><li>int stride：要在行之间跳过的像素数[]的条目数（必须 &gt;= bitmap 的宽度）。可以为负。</li><li>int x：从 bitmap 读取的第一个像素的 x 坐标。</li><li>int y：从 bitmap 读取的第一个像素的 y 坐标。</li><li>int width：每行要读取的像素数。</li><li>int height：要读取的行数。</li></ul><h3 id="void-setPixel-int-x-int-y-ColorInt-int-color"><a href="#void-setPixel-int-x-int-y-ColorInt-int-color" class="headerlink" title="void setPixel(int x, int y, @ColorInt int color)"></a>void setPixel(int x, int y, @ColorInt int color)</h3><p>在 x，y 坐标处将指定的 Color 写入 bitmap（假设 bitmap 是可变的）。颜色必须是 ColorSpace.Named.SRGB 颜色空间中的非预乘 ARGB 值。</p><ul><li>int x：要替换的像素的 x 坐标（0 … width-1）。</li><li>int y：要替换的像素的 y 坐标（0 … height-1）。</li><li>int color：写入 bitmap 的 ARGB 颜色。</li></ul><h3 id="void-setPixels-ColorInt-int-pixels-int-offset-int-stride-int-x-int-y-int-width-int-height"><a href="#void-setPixels-ColorInt-int-pixels-int-offset-int-stride-int-x-int-y-int-width-int-height" class="headerlink" title="void setPixels(@ColorInt int[] pixels, int offset, int stride, int x, int y, int width, int height)"></a>void setPixels(@ColorInt int[] pixels, int offset, int stride, int x, int y, int width, int height)</h3><p>用数组中的颜色替换 bitmap 中的像素。数组中的每个元素是一个包装 int ，表示 ColorSpace.Named.SRGB 颜色空间中未预乘的 ARGB Color。</p><ul><li>int[] pixels：写入 bitma 的颜色数组。</li><li>int offset：从像素读取的第一种颜色的索引[]。</li><li>int stride：以像素为单位的颜色数，以在行之间跳过。通常，此值将与 bitmap 的宽度相同，但是可以更大（或为负）。</li><li>int x：bitmap 中要写入的第一个像素的 x 坐标。</li><li>int y：bitmap 中要写入的第一个像素的 y 坐标。</li><li>int width：每行要从 pixel[] 复制的颜色数。</li><li>int height：写入 bitmap 的行数。</li></ul><h3 id="Bitmap-extractAlpha"><a href="#Bitmap-extractAlpha" class="headerlink" title="Bitmap extractAlpha()"></a>Bitmap extractAlpha()</h3><p>返回捕获原始图像的 Alpha 值的新 bitmap。 可以使用 Canvas.drawBitmap() 进行绘制，其中颜色将从传递给绘图调用的 paint 中获取。</p><h3 id="Bitmap-extractAlpha-Paint-paint-int-offsetXY"><a href="#Bitmap-extractAlpha-Paint-paint-int-offsetXY" class="headerlink" title="Bitmap extractAlpha(Paint paint, int[] offsetXY)"></a>Bitmap extractAlpha(Paint paint, int[] offsetXY)</h3><p>返回捕获原始图像的 Alpha 值的新 bitmap。 这些值可能会受到可选的 Paint 参数的影响，该参数可以包含自己的 alph 值，还可以包含 MaskFilter ，后者可以更改结果 bitmap 的实际尺寸（例如模糊 maskfilter 可能会放大结果 bitmap）。如果 offsetXY 不为 null ，则返回偏移返回 bitmap 的量，以便在逻辑上与原始对齐。例如，如果绘画包含半径为 2 的模糊，则 offsetXY[] 将包含 -2，-2，这样绘制 alpha 的 bitmap 偏移量为（-2，-2），然后绘制原图将使得模糊效果与原图在视觉上对齐。</p><ul><li>Paint paint：用于修改结果 bitmap 中的 alpha 值的可选画笔。为默认传递 null 。</li><li>int[] offsetXY：可选数组，该数组返回放置返回的 bitmpa 所需的 X（索引 0）和 Y（索引 1）偏移，以使其在视觉上与原始行对齐。</li></ul><h3 id="boolean-sameAs-Bitmap-other"><a href="#boolean-sameAs-Bitmap-other" class="headerlink" title="boolean sameAs(Bitmap other)"></a>boolean sameAs(Bitmap other)</h3><p>给定另一个 bitmap ，如果它具有与此 bitmap 相同的尺寸，配置，和像素数据，则返回 true。如果其中任何一个不同，则返回 false。 如果 other 为 null ，则返回 false 。</p><h3 id="void-prepareToDraw"><a href="#void-prepareToDraw" class="headerlink" title="void prepareToDraw()"></a>void prepareToDraw()</h3><p>构建与用于绘制 bitmap 的 bitmap 关联的缓存。</p><p>从 android.os.Build.VERSION_CODES.N（Android 7.0，24）开始，如果尚未上传 bitmap，则此调用会在 RenderThread 上启动异步上传到 GPU。使用硬件加速时，必须将 bitmap 上传到 GPU 才能进行渲染。默认情况下，这是在第一次绘制 bitmap 时完成的，但是此过程可能需要几毫秒的时间，具体取决于 bitmap 的大小。每次修改并再次绘制 bitmap 时，都必须重新上传。</p><p>提前调用此方法可以节省使用第一帧的时间。例如，建议在解码的 bitmap 即将显示时在图像解码工作线程上调用此方法。建议在调用此方法之前对 bitmap 进行任何预绘制修改，以便可以重新使用缓存的上传副本，而无需重新上传。</p><p>在 android.os.Build.VERSION_CODES.KITKAT （Android 6.0，23）及以下版本中，对于可清除的 bitmap ，此调用将尝试确保像素已解码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基于 9.0（29）简析 Bitmap 类。&lt;/p&gt;
&lt;p&gt;我们只关注 Bitmap 类暴露出来的（即访问权限为 public）东西。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;枚举类 Config&lt;/li&gt;
&lt;li&gt;枚举类 CompressFormat&lt;/li&gt;
&lt;li&gt;若干 creat
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="图片" scheme="https://codepoem.github.io/tags/%E5%9B%BE%E7%89%87/"/>
    
      <category term="Bitmap" scheme="https://codepoem.github.io/tags/Bitmap/"/>
    
  </entry>
  
  <entry>
    <title>Android图片压缩</title>
    <link href="https://codepoem.github.io/post/Android%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"/>
    <id>https://codepoem.github.io/post/Android图片压缩/</id>
    <published>2019-10-14T08:59:44.000Z</published>
    <updated>2019-10-14T08:59:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要压缩"><a href="#为什么要压缩" class="headerlink" title="为什么要压缩"></a>为什么要压缩</h2><h3 id="减少内存占用"><a href="#减少内存占用" class="headerlink" title="减少内存占用"></a>减少内存占用</h3><p>内存占用大小 = Bitmap 大小 = 总像素点数 x 一个像素点占用的字节数</p><h4 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h4><p><strong>Android 中图片在内存中的表达形式是 Bitmap，即位图。</strong></p><h5 id="总像素点数"><a href="#总像素点数" class="headerlink" title="总像素点数"></a>总像素点数</h5><p><strong>总像素点数由什么决定呢？</strong></p><p>总像素点数 = 图片源长度 x 缩放比例 x 图片源宽度 x 缩放比例</p><p>缩放比例可以大致表示为：（为什么说大致呢？因为不是绝对的，实际还有其他因素可以影响实际缩放比例，如 inScreenDensity）<br>缩放比例 = 1/inSampleSize x (inTargetDensity/inDensity)</p><ul><li>int inSampleSize</li></ul><p>如果设置的值大于 1，将会请求解码器对原始图像进行二次采样，返回较小的图像以节省内存。样本大小是任一维度中与已解码 bitmap 中单个像素对应的像素数。例如，设置 inSampleSize == 4 ，将会返回一张是宽高为原始宽度和高度的 1/4 的图像，像素为原来的 1/16。任何小于等于 1 的值都与 1 相同。注意：解码器使用基于 2 的幂的最终值，任何其他值将四舍五入为最接近的 2 的幂。</p><ul><li>int inDensity</li></ul><p>用于 bitmap 像素密度。这将使得在返回的位图中始终有为其设置的密度（请参阅 Bitmap.setDensity(int)）。此外，如果开启了 inScaled（默认情况下开启），并且此密度与 inTargetDensity 不匹配，则 bitmap 在返回之前将被缩放为目标密度。</p><p>如果设置为 0， BitmapFactory.decodeResource(Resources, int) 、 BitmapFactory.decodeResource(Resources, int, android.graphics.BitmapFactory.Options) 、 BitmapFactory.decodeResourceStream 这些 decode 方法将填充与资源关联的密度。其他 decode 方法将保持原样，并且不会应用任何密度。</p><ul><li>int inTargetDensity</li></ul><p>此 bitmap 将被绘制到的目标像素密度。 与 inDensity 和 inScaled 结合使用，以确定在返回 bitmap 之前是否以及如何缩放位图。</p><p>如果设置为 0， BitmapFactory.decodeResource(Resources, int) 、 BitmapFactory.decodeResource(Resources, int, android.graphics.BitmapFactory.Options) 、 BitmapFactory.decodeResourceStream 这些 decode 方法将填充与资源对象的 DisplayMetrics 相关的密度。其他 decode 方法将保持原样，并且不会对密度进行缩放。</p><ul><li>int inScreenDensity</li></ul><p>正在使用的实际屏幕的像素密度。 仅用于以密度兼容代码运行的应用程序，其中 inTargetDensity 实际上是应用程序看到的密度而不是实际的屏幕密度。</p><p>通过设置此选项，允许加载代码避免将当前的屏幕密度的 bitmap 缩放到/降低到兼容密度。相反的，如果 inDensity 与 inScreenDensity 相同，则 bitmap 将保持不变。任何使用生成的 bitmap 的对象，还必须使用 Bitmap.getScaledWidth 和 Bitmap.getScaledHeight 来说明 bitmap 的密度与目标密度之间的任何差异。</p><p>BitmapFactory 自身永远不会为调用者自动设置。必须明确设置它，因为调用者必须以密度感知的方式处理结果位图。</p><ul><li>boolean inScaled</li></ul><p>如果设置了该配置，并且 inDensity 和 inTargetDensity 不为 0，bitmap 在加载时将缩放以匹配 inTargetDensity，而不是每次绘制到 Canvas 时都依赖于图形系统对其进行缩放。</p><p>BitmapRegionDecoder 会忽略这个配置，并且不会根据密度缩放输出。（尽管支持 inSampleSize ）</p><p>此配置默认开启，如果需要 bitmap 的非缩放版本，则应将其关闭。.9 bitmaps（Nine-patch bitmaps）会忽略此配置，并且始终会缩放。</p><p>如果 inPremultiplied 设置为 false ，并且图像具有 Alpha 透明度，将此配置设置为 true 可能会导致颜色错误。</p><h5 id="一个像素点占用的字节数"><a href="#一个像素点占用的字节数" class="headerlink" title="一个像素点占用的字节数"></a>一个像素点占用的字节数</h5><p><strong>一个像素点占用的字节数由什么决定呢？</strong></p><blockquote><p>像素信息:</p><ul><li>像素不是一个具体的物理量，是一种抽象的数据结构。</li></ul><p>如果把一张图片看成是一堆信息元素的集合，那么为了描述一张图片，我们要先建模，用一个数据结构来表示信息元素。从而，建模后图像就成了一堆数据结构（结构体）的集合，现在给这种数据结构起个名字就叫像素。</p><ul><li>像素这种数据结构中可以记录颜色信息（因为图像就是由不同颜色组成的）。</li></ul></blockquote><blockquote><p>色彩空间（ColorSpace），对色彩的组织方式，RGB、YUV、CMYK 等。</p><ul><li>RGB：一个像素划分 Red、Green、Blue 分量来表示，面向硬件，适合显示系统,不适合图像处理。</li><li>YUV：Y 表示明亮度（Luminance，Luma，黑白信号），UV 表示色度、浓度（Chrominance，Chroma，色彩信息）。</li><li>CMYK：C：Cyan ＝ 青色，常被误称为“天蓝色”或“湛蓝”，M：Magenta ＝ 洋红色，又称为“品红色”，Y：Yellow ＝ 黄色，K：blacK ＝ 黑色，是彩色印刷时采用的一种套色模式，利用色料的三原色混色原理，加上黑色油墨，共计四种颜色混合叠加，形成所谓“全彩印刷”。</li></ul><p>色彩模式是数字世界中表示颜色的一种算法。</p></blockquote><p><strong>因此一个像素点占用的字节由存储像素信息的方案决定。</strong></p><p>假设我们采用 ARGB 色彩模式，即在 RGB 色彩空间的基础上加上 Alpha（透明度）通道。每个通道的取值范围在[0,255]，即有 256 个值，刚好可以用一个字节（8bit）表示。ARGB 四个通道，需要四个字节表示一个像素信息。</p><p>事实上，在保证必要的像素信息的同时追求更少的内存占用，可以减少通道的位数，甚至可以考虑去掉 Alpha（透明度）通道。</p><p><strong>Bitmap.Config 是一个枚举类，它表示的就是每个像素点信息的存储方案。</strong><br>| Config | 每个像素占用字节数 | 表示颜色种数 | 说明 |<br>| ——— | ——————————————– | ——————— | ———————————————————————- |<br>| ALPHA_8 | 1 个字节，A 分量占 8 位，不存储颜色信息 | 0 | 单透明通道 |<br>| RGB_565 | 两个字节，R 分量占 5 位，G 分量占 6 位，B 分量占 5 位 | 2^16(65536) | 简易 RGB 色调 |<br>| RGB_888 | 三个字节，R、G、B 分量各占 8 位 | 2^24(16777216) | RGB 色调 |<br>| ARGB_4444 | 两个字节，A、R、G、B 分量各占 4 位 | 2^12(4096) | 已弃用，成像效果比较差，并且 v4.4+后如果使用了它会自动转成用 ARGB_8888。 |<br>| ARGB_8888 | 四个字节，A、R、G、B 分量各占 8 位 | 2^24(16777216) | 24 位真彩色，Android 中默认的配置 |<br>| RGBA_F16 | 八个字节，A、R、G、B 分量各占 16 位 | 2^48(281474976710656) | 特别适合于宽色域和 HDR 内容，在 8.0（api 26）引入。 |<br>| HARDWARE | - | - | 特殊配置。bitmap 始终存储在图形内存中，在 8.0（api 26）引入。 |</p><h3 id="减少物理空间占用"><a href="#减少物理空间占用" class="headerlink" title="减少物理空间占用"></a>减少物理空间占用</h3><p>物理空间占用 = 簇（操作系统所使用的逻辑概念）的整数倍 &gt;= 文件大小</p><p>图片在物理空间的表现形式是 File，具体有 GIF、JPEG、BMP、PNG 和 WebP 等格式。</p><blockquote><ul><li>Gif<br>Gif 是一种基于 LZW 算法的无损压缩格式，其压缩率一般在 50％左右。Gif 可插入多帧，从而实现动画效果。因此 Gif 图片分为静态 GIF 和动画 GIF 两种 GIF 格式。由于 Gif 以 8 位颜色压缩存储单个位图，所以它最多只能用 256 种颜色来表现物体，对于色彩复杂的物体它就力不从心了。因此 Gif 不适合用于色彩非常丰富的图片的压缩存储，比如拍摄的真彩图片等。</li><li>BMP<br>BMP 是标准图形格式，它是包括 Windows 在内多种操作系统图像展现的终极形式。其本质就是 Bitmap 对象直接持久化保存的位图文件格式，由于没有进行压缩存储，因此体积非常大，故而不适合在网络上传输。同时也是因为这种格式是对 Bitmap 对象的直接存储而没有进行压缩，因此我们在讨论压缩格式时往往忽略这一种。</li><li>PNG<br>PNG 格式本身的设计目的是替代 GIF 格式，所以它与 GIF 有更多相似的地方。PNG 格式也属于无损压缩，其位深为 32 位，也就是说它支持所有的颜色类型。同样是无损压缩，PNG 的压缩率高于 Gif 格式，而且 PNG 支持的颜色数量也远高于 Gif，因此：如果是对静态图片进行无损压缩，优先使用 PNG 取代 Gif，因为 PNG 压缩率高、色彩好；但是 PNG 不支持动画效果。所以 Gif 仍然有用武之地。<br>PNG 缺点是：由于是无损压缩，因此 PNG 文件的体积往往比较大。如果在项目中多处使用 PNG 图片文件，那么在 APP 瘦身时需要对 PNG 文件进行优化以减少 APP 体积大小。具体做法后面会详细介绍。</li><li>JPEG<br>JPEG 是一种有损压缩格式，JPEG 图片以 24 位颜色压缩存储单个位图。也就是说，JPEG 不支持透明通道。JPEG 也不支持多帧动画。因为是有损压缩，所以需要注意控制压缩率以免图片质量太差。<br>JPG 和 JPEG 没有区别，全名、正式扩展名是 JPEG。但因 DOS、Windows95 等早期系统采用的 8.3 命名规则只支持最长 3 字符的扩展名，为了兼容采用了.jpg。也因历史习惯和兼容性的考虑，.jpg 目前更流行。JPEG2000 作为 JPEG 的升级版，其压缩率比 JPEG 高约 30％左右，同时支持有损和无损压缩。<br>JPEG2000 格式有一个极其重要的特征在于它能实现渐进传输，即先传输图像的轮廓，然后逐步传输数据，不断提高图像质量，让图像由朦胧到清晰显示。此外，JPEG2000 还支持所谓的“感兴趣区域”特性，也就是可以任意指定影像上感兴趣区域的压缩质量；另外，JPEG2000 还可以选择指定的部分先解压缩来加载到内存中。JPEG2000 和 JPEG 相比优势明显，且向下兼容，因此可取代传统的 JPEG 格式。</li><li>WebP<br>WebP 是 Google 在 2010 年发布的图片格式，希望以更高的压缩率替代 JPEG。它用 VP8 视频帧内编码作为其算法基础，取得了不错的压缩效果。WebP 支持有损和无损压缩、支持完整的透明通道、也支持多帧动画，并且没有版权问题，是一种非常理想的图片格式。WebP 支持动图，基本取代 gif。<br>WebP 不仅集成了 PNG、JPEG 和 Gif 的所有功能，而且相同质量的无损压缩 WebP 图片体积比 PNG 小大约 26%；如果是有损压缩，相同质量的 WebP 图片体积比 JPEG 小 25%-34%。<br>很多人会认为，既然 WebP 功能完善、压缩率更高，那直接用 WebP 取代上述所有的图片压缩格式不就行了吗？其实不然，WebP 也有其缺点：我们知道 JPEG 是有损压缩而 PNG 是无损压缩，所以 JPEG 的压缩率高于 PNG；但是有损压缩的算法决定了其压缩时间一定是高于无损压缩的，也就是说 JPEG 的压缩时间高于 PNG。而 WebP 无论是无损还是有损压缩，压缩率都分别高于 PNG 和 JPEG；与其相对应的是其压缩时间也比它们长的多。经测试，WebP 图片的编码时间比 JPEG 长 8 倍。可以看出，时间和空间是一对矛盾；如果想要节省更多的空间，必然要付出额外的时间；如果想要节省时间，那么必然要付出空间的代价。这取决于我们在实际中对于时空不同的需求程度来做出选择。<br>不管怎么说，WebP 还是一种强大的、理想的图片压缩格式，并且借由 Google 在网络世界的影响力，WebP 在几年的时间内已经得到了广泛的应用。看看你手机里的 App：微博、微信、QQ、淘宝等等，每个 App 里都有 WebP 的身影。<br>另外，WebP 是 Android4.0 才引入的一种图片压缩格式，如果想要在 Android4.0 以前的版本支持 WebP 格式的图片，那么需要借助于第三方库来支持 WebP 格式图片，例如：<a href="https://github.com/alexey-pelykh/webp-android-backport">webp-android-backport</a>函数库，当然考虑到一般的 Android 开发中只需要向下兼容到 Android4.0 即可，所以也可以忽略这个问题。</li></ul><p>目前来说，以上所述的五种格式，Android 操作系统都提供了原生支持；但是在上层能直接调用的编码方式只有 JPEG、PNG、WebP 这三种。具体的，可以查看 Bitmap 类的枚举内部类 CompressFormat 类的枚举值来获取上层能调用的图片编码方式。你会发现枚举值也是 JPEG、PNG 和 WEBP 三种。<br>如果我们想要在应用层使用 Gif 格式图片，需要自行引入第三方函数库来提供对 Gif 格式图片的支持。不过一般我们用 WebP 取代 Gif。</p></blockquote><h2 id="如何压缩"><a href="#如何压缩" class="headerlink" title="如何压缩"></a>如何压缩</h2><h3 id="压缩分类"><a href="#压缩分类" class="headerlink" title="压缩分类"></a>压缩分类</h3><h4 id="有损压缩"><a href="#有损压缩" class="headerlink" title="有损压缩"></a>有损压缩</h4><blockquote><p>有损压缩的基本依据是：人的眼睛对光线的敏感度远高于对颜色的敏感度，光线对景物的作用比颜色的作用更为重要。有损压缩的原理是：保持颜色的逐渐变化，删除图像中颜色的突然变化。生物学中的大量实验证明，人类大脑会自发地利用与附近最接近的颜色来填补所丢失的颜色。有损压缩的具体实现方法就是删除图像中景物边缘的某些颜色部分。当在屏幕上看这幅图时，大脑会利用在景物上看到的颜色填补所丢失的颜色部分。利用有损压缩技术，某些数据被有意地删除了，并且在图片重新加载至内存中时这些数据也不会还原，因此被称为是“有损”的。有损压缩技术可以灵活地设置压缩率。<br>无可否认，利用有损压缩技术可以在位图持久化存储的过程中大大地压缩图片的存储大小，但是会影响图像质量，这一点在压缩率很高时尤其明显。所以需要选择恰当的压缩率。</p></blockquote><h4 id="无损压缩"><a href="#无损压缩" class="headerlink" title="无损压缩"></a>无损压缩</h4><blockquote><p>无损压缩的基本原理是：相同的颜色信息只需保存一次。具体过程是：首先会确定图像中哪些区域是相同的，哪些是不同的。包括了重复数据的区域就可以被压缩，只需要记录该区域的起始点即可。<br>从本质上看，无损压缩的方法通过删除一些重复数据，也能在位图持久化存储的过程中减少要在磁盘上保存的图片大小。但是，如果将该图片重新读取到内存中，重复数据会被还原。因此，无损压缩的方法并不能减少图片的内存占用量，如果要减少图片占用内存的容量，就必须使用有损压缩方法。<br>无损压缩方法的优点是能够比较好地保存图像的质量，但是相对来说这种方法的压缩率比较低。<br>对比分析：有损压缩压缩率高而且可以灵活设置压缩率，并且删除的数据不可还原，因此可以减少图片的内存占用，但是对图片质量会有一定程度的影响；无损压缩可以很好地保存图片质量，也能保证一定的压缩率虽然没有有损压缩那么高，并且无损压缩删除的数据在重新加载至内存时会被还原，因此不可以减少图片的内存占用。</p></blockquote><h3 id="Android-中压缩"><a href="#Android-中压缩" class="headerlink" title="Android 中压缩"></a>Android 中压缩</h3><h4 id="编译时压缩"><a href="#编译时压缩" class="headerlink" title="编译时压缩"></a>编译时压缩</h4><p>AAPT 打包时默认对 PNG 进行三个优化检查（<a href="http://androidxref.com/">Android 源码</a>中搜索 analyze_image），默认使用的是 libpng 库进行无损压缩（修改色彩模式）：</p><ol><li>每个像素都是 R == G == B (grayscale 灰度)</li><li>每个像素都是 A == 255 (opaque 全透明)</li><li>是否不超过 256 种不同的 RGBA 颜色</li></ol><p>判断它是否可以被转成灰度格式的图片，判断它是否是全透明的，或判断它是否可以被转成一张索引图。</p><p>如果想压缩地更多，禁用掉 AAPT 的默认压缩 PNG（一般二次压缩反而会增大体积），采用第三方压缩工具来提升压缩效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs 禁用AAPT默认PNG处理">android &#123;<br>        buildTypes &#123;<br>            release &#123;<br>                // Disables PNG crunching for the release build type.<br>                crunchPngs false<br>            &#125;<br>        &#125;<br><br>    // If you&#x27;re using an older version (Android Gradle plugin &lt; 3.0.0) of the plugin, use the<br>    // following:<br>    //  aaptOptions &#123;<br>    //      cruncherEnabled false<br>    //  &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第三方工具：</p><ul><li><a href="https://imageoptim.com">ImageOptim</a> 无损压缩</li><li><a href="https://pngmini.com">ImageAlpha</a> 有损压缩</li><li><a href="https://tinypng.com">TinyPNG</a> 有损压缩</li><li><a href="https://pngquant.org/">Pngquant</a> 有损压缩</li><li><a href="http://advsys.net/ken/utils.htm">Pngout</a> 无损压缩</li><li><a href="http://optipng.sourceforge.net/">OptiPNG</a> 无损压缩</li></ul><h4 id="运行时压缩"><a href="#运行时压缩" class="headerlink" title="运行时压缩"></a>运行时压缩</h4><h5 id="质量压缩"><a href="#质量压缩" class="headerlink" title="质量压缩"></a>质量压缩</h5><p>质量压缩在不改变像素的大小的前提下，降低图像的质量（改变图片的位深及透明度等），从而降低存储大小，进而达到压缩的目的。</p><p><strong>质量压缩对内存大小占用无影响。</strong></p><blockquote><p>位深度指的是存储每个像素所用的位数，主要用于存储。<br>色深指的是每一个像素点用多少 bit 存储颜色，属于图片自身的一种属性。<br>位深一般小于或等于色深。<br>举个例子：某张图片 100 像素*100 像素 色深 32 位(ARGB_8888)，保存时位深度为 24 位，那么：<br>该图片在内存中所占大小为：100 x 100 x (32 / 8) Byte<br>在文件中所占大小为 100 x 100 x ( 24/ 8 ) x 压缩率 Byte</p></blockquote><p>Android 中的质量压缩 API ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Android中的质量压缩API">public boolean compress(CompressFormat format, int quality, OutputStream stream)<br></code></pre></td></tr></table></figure><p>Java 层函数 → Native 函数 → Skia 函数 → 对应第三库函数（例如 libjpeg、libpng、libjwebp）</p><ul><li>CompressFormat format：压缩格式,它有 JPEG、PNG、WEBP 三种选择，JPEG 是有损压缩，PNG 是无损压缩，WEBP 是 Google 推出的图像格式.</li><li>int quality：0~100 可选，数值越大，质量越高，图像越大。</li><li>OutputStream stream：压缩后图像的输出流。</li></ul><p>针对 JPEG 的压缩库：</p><ul><li><a href="https://github.com/libjpeg-turbo/libjpeg-turbo">libjpeg-turbo</a></li></ul><blockquote><p>libjpeg-turbo 是用于 x86 和 x86-64 处理器的 libjpeg 的高速版本，它使用 SIMD 指令（MMX，SSE2 等）来加速基线 JPEG 压缩和解压缩。 libjpeg-turbo 的速度通常是未修改版本的 libjpeg 的 2-4 倍，其他所有条件都相同（对于非灰度 JPEG 压缩和解压缩，libjpeg-turbo 的速度是 libjpeg v6b 的 1.8 倍至 4.5 倍）。</p></blockquote><ul><li><a href="https://github.com/mozilla/mozjpeg">mozilla/mozjpeg</a></li></ul><blockquote><p>基于 libjpeg-turbo，依靠三种技术（渐进 JPEG 编码，jpgcrush 和网格量化）来减小 JPEG 图像的大小。libjpeg-turbo 支持渐进式 JPEG，但不支持 jpgcrush 和网格量化。mozjpeg 的唯一目的是减少网络上提供的 JPEG 文件的大小，因此它牺牲了一些性能为代价。</p></blockquote><h5 id="尺寸压缩"><a href="#尺寸压缩" class="headerlink" title="尺寸压缩"></a>尺寸压缩</h5><p>尺寸压缩即减少图片长宽，或者说减少像素点，又称采样压缩（上采样为放大，下采样缩小，因此采样压缩为下采样）。</p><h6 id="邻近采样"><a href="#邻近采样" class="headerlink" title="邻近采样"></a>邻近采样</h6><p>邻近采样（Nearest Neighbour Resampling）采用邻近点插值算法，用一个像素点代替邻近的像素点。</p><p><a href="https://developer.android.com/topic/performance/graphics/load-bitmap?hl=zh-cn">官方高效加载 Bitmap 指南</a>采用的方式就是进行邻近采样。</p><p>做法是先将 BitmapFactory.Options 中的 inJustDecodeBounds 设置为 true，这样 BitmapFactory 在 decode 的时候能避免内存分配，但能对 outWidth，outHeight 和 outMimeType 赋值。然后通过获取到的 outWidth，outHeight 以及 加载的目标宽高计算出合适的采样率赋值给 BitmapFactory.Options 中的 inSamleSize。最后 BitmapFactory.Options 中的 inJustDecodeBounds 设置回 false，并进行相应的 decode。</p><p>关键之处就是计算出合适的采样率，对应 BitmapFactory.Options 中的 inSamleSize（inSamleSize 会是四舍五入后最接近 2 的幂的值）。<br>关于如何计算出合适的采样率，普遍的算法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateInSampleSize</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            BitmapFactory.Options options, <span class="hljs-keyword">int</span> reqWidth, <span class="hljs-keyword">int</span> reqHeight)</span> </span>&#123;<br>    <span class="hljs-comment">// Raw height and width of image</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> height = options.outHeight;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> width = options.outWidth;<br>    <span class="hljs-keyword">int</span> inSampleSize = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (height &gt; reqHeight || width &gt; reqWidth) &#123;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> halfHeight = height / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> halfWidth = width / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// Calculate the largest inSampleSize value that is a power of 2 and keeps both</span><br>        <span class="hljs-comment">// height and width larger than the requested height and width.</span><br>        <span class="hljs-keyword">while</span> ((halfHeight / inSampleSize) &gt;= reqHeight<br>                &amp;&amp; (halfWidth / inSampleSize) &gt;= reqWidth) &#123;<br>            inSampleSize *= <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> inSampleSize;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>第三个开源库<a href="https://github.com/Curzibn/Luban">Luban</a>的<a href="https://github.com/Curzibn/Luban/blob/master/DESCRIPTION.md">计算采样率算法思路</a></p></blockquote><h6 id="双线性采样"><a href="#双线性采样" class="headerlink" title="双线性采样"></a>双线性采样</h6><p>双线性采样（Bilinear Resampling）采用双线性插值算法，相比邻近采样简单粗暴的选择一个像素点代替其他像素点，双线性采样参考源像素相应位置周围 2x2 个点的值，根据相对位置取对应的权重，经过计算得到目标图像。</p><p>Android 中双线性采样有两个 API：</p><ul><li>public static Bitmap createScaledBitmap(@NonNull Bitmap src, int dstWidth, int dstHeight, boolean filter)</li><li>public static Bitmap createBitmap(@NonNull Bitmap source, int x, int y, int width, int height, @Nullable Matrix m, boolean filter)</li></ul><p>事实上，createScaledBitmap(@NonNull Bitmap src, int dstWidth, int dstHeight, boolean filter) 方法最终也是调用 createBitmap(@NonNull Bitmap source, int x, int y, int width, int height, @Nullable Matrix m, boolean filter) 方法。</p><ul><li>Bitmap source：源图像</li><li>int x：目标图像第一个像素的 x 坐标</li><li>int y：目标图像第一个像素的 y 坐标</li><li>int width：目标图像的宽度（像素点个数）</li><li>int height：目标图像的高度（像素点个数）</li><li>Matrix m：变换矩阵</li><li>boolean filter：是否开启双线性滤波</li></ul><h6 id="双立方-双三次采样"><a href="#双立方-双三次采样" class="headerlink" title="双立方/双三次采样"></a>双立方/双三次采样</h6><p><a href="https://en.wikipedia.org/wiki/Bicubic_interpolation">双立方/双三次采样（Bicubic Resampling）</a>，邻近点插值算法的目标像素值由源图上单个像素决定，双线性內插值算法由源像素某点周围 2x2 个像素点按一定权重获得，而双立方／双三次插值算法更进一步参考了源像素某点周围 4x4 个像素。</p><p>Android 中对于双立方/双三次采样没有支持，可以通过手动编写算法或者引用第三方算法库，幸运的是这个算法在 ffmpeg 中已经给到了支持，具体的实现在 libswscale/swscale.c 文件中：<a href="http://www.ffmpeg.org/ffmpeg-scaler.html">FFmpeg Scaler Documentation</a>。</p><h6 id="Lanczos-采样"><a href="#Lanczos-采样" class="headerlink" title="Lanczos 采样"></a>Lanczos 采样</h6><p><a href="https://en.wikipedia.org/wiki/Lanczos_resampling">Lanczos 采样</a>和 Lanczos 过滤是 Lanczos 算法的两种常见应用，它可以用作低通滤波器或者用于平滑地在采样之间插入数字信号，Lanczos 采样一般用来增加数字信号的采样率，或者间隔采样来降低采样率。<br>Lanczos 采样使用的 Lanczos 算法也可以用来作为图片的缩放，Lanczos 算法和双三次插值算法都是使用卷积核来通过输入像素计算输出像素。<br>同样的，Lanczos 算法在 ffmpeg 的 libswscale/swscale.c 中也有实现。其实不光 Lanczos 和上面的三种算法，ffmpeg 还提供了其他的图像重采样方法，诸如 area averaging、Gaussian 等等。</p><h5 id="色彩模式压缩"><a href="#色彩模式压缩" class="headerlink" title="色彩模式压缩"></a>色彩模式压缩</h5><p>BitmapFactory.Options 中 inPreferredConfig 可以指定色彩模式，采用色位更少的色彩模式。</p><hr><p>参考链接：</p><ul><li><a href="https://yunxi.vkucloud.com/article/e53f10f5-0f45-41a3-45dd-08d6f1abedd9">Android Bitmap（位图）详解</a></li><li><a href="https://juejin.im/entry/5ad0213f6fb9a028df2306cd">Android 中 Bitmap 内存优化</a></li><li><a href="https://juejin.im/entry/58fc75e0ac502e0063aa433b">也谈图片压缩</a></li><li><a href="https://juejin.im/post/5a1bd6595188254cc067981f">Android 平台图像压缩方案</a></li><li>QQ 音乐技术文章<a href="https://cloud.tencent.com/developer/article/1006307">Android 中图片压缩分析（上）</a></li><li>QQ 音乐技术文章<a href="https://cloud.tencent.com/developer/article/1006352">Android 中图片压缩分析（下）</a></li><li><a href="https://juejin.im/post/58c3b29761ff4b005d906730#heading-14">Android 性能优化（五）之细说 Bitmap</a></li><li><a href="https://developer.android.com/topic/performance/graphics/load-bitmap.html">Loading Large Bitmaps Efficiently</a></li><li><a href="https://developer.android.google.cn/topic/performance/graphics/cache-bitmap.html">Caching Bitmaps</a></li><li><a href="https://developer.android.com/topic/performance/graphics/manage-memory">Managing Bitmap Memory</a></li><li><a href="https://developer.android.com/topic/performance/graphics">Handling bitmaps</a></li></ul><p>后记：可研读核心类 Bitmap、BitmapFactory。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要压缩&quot;&gt;&lt;a href=&quot;#为什么要压缩&quot; class=&quot;headerlink&quot; title=&quot;为什么要压缩&quot;&gt;&lt;/a&gt;为什么要压缩&lt;/h2&gt;&lt;h3 id=&quot;减少内存占用&quot;&gt;&lt;a href=&quot;#减少内存占用&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="图片" scheme="https://codepoem.github.io/tags/%E5%9B%BE%E7%89%87/"/>
    
      <category term="压缩" scheme="https://codepoem.github.io/tags/%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>简析BitmapFactory</title>
    <link href="https://codepoem.github.io/post/%E7%AE%80%E6%9E%90BitmapFactory/"/>
    <id>https://codepoem.github.io/post/简析BitmapFactory/</id>
    <published>2019-10-14T08:59:44.000Z</published>
    <updated>2019-10-14T08:59:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>基于 9.0（29）简析 BitmapFactory 类。</p><p>我们只关注 BitmapFactor 类暴露出来的（即访问权限为 public）东西。</p><ul><li>静态内部类 Options</li><li>若干 decode 方法</li></ul><h2 id="静态内部类-Options"><a href="#静态内部类-Options" class="headerlink" title="静态内部类 Options"></a>静态内部类 Options</h2><p>Options，顾名思义，是 BitmapFactory 用于 decode 方法的选项参数。让我们看看有哪些：</p><h3 id="Bitmap-inBitmap"><a href="#Bitmap-inBitmap" class="headerlink" title="Bitmap inBitmap"></a>Bitmap inBitmap</h3><p>如果使用此参数，decode 方法会在加载内容时尝试重用此 bitmap ，如果编码操作不能使用此 bitmap （有限制条件），则会抛出 java.lang.IllegalArgumentException 异常。当前的重用实现方式要求 bitmap 必须是可变的，并且即使一个资源在 decode 后通常会得到不可变的 bitmap，在重用成功后所得到的重用 bitmap 也将保持可变性。任何可变的 bitmap 都可以被 BitmapFactory 重用，以解码任何其他 bitmap，只要解码后的 bitmap （待分配内存）的字节数（getByteCount 方法，解码后待分配内存状态的大小）小于或等于分配的字节数（getAllocationByteCount 方法，占用内存的实际大小）。这可能是因为待分配内存的 bitmap 固有尺寸较小，或者其缩放后的尺寸（对于密度/样本尺寸）较小。</p><p>在 android.os.Build.VERSION_CODES.KITKAT（Android4.4，19）之前，使用有更多限制：</p><ul><li>解码的图像（无论是作为资源还是作为流）必须为 jpeg 或 png 格式。</li><li>仅支持大小相等的 bitmap，并且 inSampleSize 设置为 1。</li><li>另外，重用 bitmap 的 Bitmap.Config 配置 inPreferredConfig 将被覆盖（如果已设置）。</li></ul><p>BitmapRegionDecoder 会将其请求的内容绘制到提供的 bitmap 中，如果输出内容大小（缩放后）大于提供的 bitmap ，则进行裁剪。提供的 bitmap 的宽度，高度和 Bitmap.Config 不会更改。<br>android.os.Build.VERSION_CODES.JELLY_BEAN（Android 4.1，16）中引入了对 inBitmap 的 BitmapRegionDecoder 支持。 BitmapRegionDecoder 支持的所有格式 通过 inBitmap 支持 bitmap 重用。</p><h3 id="boolean-inMutable"><a href="#boolean-inMutable" class="headerlink" title="boolean inMutable"></a>boolean inMutable</h3><p>在 native 代码中使用。</p><p>如果开启该设置，则 decode 方法将始终返回可变的 bitmap。这可以用于以编程方式将效果应用于通过 BitmapFactory 加载的 Bitmap。不能与 inPreferredConfig = Bitmap.Config.HARDWARE 同时设置，因为硬件 bitmap 始终是不可变的。</p><h3 id="boolean-inJustDecodeBounds"><a href="#boolean-inJustDecodeBounds" class="headerlink" title="boolean inJustDecodeBounds"></a>boolean inJustDecodeBounds</h3><p>如果开启该设置， 解码器将会返回 null （不返回 bitmap ），但是 out… 字段（如 outWidth 、 outHeight 、 outMimeType ）会被赋值，从而允许调用者查询 bitmap ，而不必为其像素分配内存。</p><h3 id="int-inSampleSize"><a href="#int-inSampleSize" class="headerlink" title="int inSampleSize"></a>int inSampleSize</h3><p>如果设置的值大于 1，将会请求解码器对原始图像进行二次采样，返回较小的图像以节省内存。样本大小是任一维度中与已解码 bitmap 中单个像素对应的像素数。例如，设置 inSampleSize == 4 ，将会返回一张是宽高为原始宽度和高度的 1/4 的图像，像素为原来的 1/16。任何小于等于 1 的值都与 1 相同。注意：解码器使用基于 2 的幂的最终值，任何其他值将四舍五入为最接近的 2 的幂。</p><h3 id="Bitmap-Config-inPreferredConfig"><a href="#Bitmap-Config-inPreferredConfig" class="headerlink" title="Bitmap.Config inPreferredConfig"></a>Bitmap.Config inPreferredConfig</h3><p>如果该配置不为 null ，解码器将会尝试解析 bitmap 成此内部配置（bitmap 的像素存储方式）。如果该配置为 null，或者无法满足要求，解码器将会基于系统屏幕深度和原始图像的特征（如是否有每像素透明度）来选择最合适的配置（要求该配置也满足要求）。</p><p>图像默认以 Bitmap.Config.ARGB_8888 的配置加载。</p><h3 id="ColorSpace-inPreferredColorSpace"><a href="#ColorSpace-inPreferredColorSpace" class="headerlink" title="ColorSpace inPreferredColorSpace"></a>ColorSpace inPreferredColorSpace</h3><p>如果改配置不为 null ，则解码器将尝试解码 bitmap 到此颜色空间中。如果该配置为 null ，或者无法满足要求，则解码器将选择嵌在图像的颜色空间或最适合请求的图像配置的颜色空间（例如，ColorSpace.Named.SRGB 对应 Bitmap.Config.ARGB_8888 ; ColorSpace.Named.EXTENDED_SRGB 对应 Bitmap.Config.RGBA_F16）。</p><p>目前只支持 ColorSpace.Model.RGB 颜色空间，如果设置了非 RGB 颜色空间（例如 ColorSpace.Named.CIE_LAB）， decode 方法将会抛出异常（IllegalArgumentException）。</p><p>指定的色彩空间的传递函数必须是 ColorSpace.Rgb.TransferParameters() ICC 参数曲线。如果在指定的色彩空间调用方法 ColorSpace.Rgb.getTransferParameters() 返回 null ， decode 方法将会抛出异常（IllegalArgumentException）。</p><p>解码之后，bitmap 的色彩空间存储在 BitmapFactory.Options.outColorSpace 字段。</p><h3 id="boolean-inPremultiplied"><a href="#boolean-inPremultiplied" class="headerlink" title="boolean inPremultiplied"></a>boolean inPremultiplied</h3><p>如果开启此配置（默认开启），则生成的 bitmap 的颜色通道将被 alpha 通道预乘。</p><p>由视图系统或通过 Canvas 直接绘制的图像，不应将其设置为 false。视图系统和 Canvas 假定所有绘制的图像都已预乘以简化绘制时融合，并且在绘制未预乘时将抛出 RuntimeException 。</p><p>仅当您要处理原始编码的图像数据（例如，使用 RenderScript 或自定义 OpenGL）时才是合适的。</p><p>不会影响没有 Alpha 通道的 bitmap 。</p><p>将 inScaled 设置为 true 时将此标志设置为 false 可能会导致颜色错误。</p><h3 id="boolean-inDither"><a href="#boolean-inDither" class="headerlink" title="boolean inDither"></a>boolean inDither</h3><p>@deprecated 自 android.os.Build.VERSION_CODES.N （Android7.0，24）起，此配置被忽略。</p><p>在 android.os.Build.VERSION_CODES.M (Android6.0，23)及以下版本中，如果设置为 true，则解码器将尝试对解码的图像进行抖动。</p><h3 id="int-inDensity"><a href="#int-inDensity" class="headerlink" title="int inDensity"></a>int inDensity</h3><p>用于 bitmap 像素密度。这将使得在返回的位图中始终有为其设置的密度（请参阅 Bitmap.setDensity(int)）。此外，如果开启了 inScaled（默认情况下开启），并且此密度与 inTargetDensity 不匹配，则 bitmap 在返回之前将被缩放为目标密度。</p><p>如果设置为 0， BitmapFactory.decodeResource(Resources, int) 、 BitmapFactory.decodeResource(Resources, int, android.graphics.BitmapFactory.Options) 、 BitmapFactory.decodeResourceStream 这些 decode 方法将填充与资源关联的密度。其他 decode 方法将保持原样，并且不会应用任何密度。</p><h3 id="int-inTargetDensity"><a href="#int-inTargetDensity" class="headerlink" title="int inTargetDensity"></a>int inTargetDensity</h3><p>此 bitmap 将被绘制到的目标像素密度。 与 inDensity 和 inScaled 结合使用，以确定在返回 bitmap 之前是否以及如何缩放位图。</p><p>如果设置为 0， BitmapFactory.decodeResource(Resources, int) 、 BitmapFactory.decodeResource(Resources, int, android.graphics.BitmapFactory.Options) 、 BitmapFactory.decodeResourceStream 这些 decode 方法将填充与资源对象的 DisplayMetrics 相关的密度。其他 decode 方法将保持原样，并且不会对密度进行缩放。</p><h3 id="int-inScreenDensity"><a href="#int-inScreenDensity" class="headerlink" title="int inScreenDensity"></a>int inScreenDensity</h3><p>正在使用的实际屏幕的像素密度。 仅用于以密度兼容代码运行的应用程序，其中 inTargetDensity 实际上是应用程序看到的密度而不是实际的屏幕密度。</p><p>通过设置此选项，允许加载代码避免将当前的屏幕密度的 bitmap 缩放到/降低到兼容密度。相反的，如果 inDensity 与 inScreenDensity 相同，则 bitmap 将保持不变。任何使用生成的 bitmap 的对象，还必须使用 Bitmap.getScaledWidth 和 Bitmap.getScaledHeight 来说明 bitmap 的密度与目标密度之间的任何差异。</p><p>BitmapFactory 自身永远不会为调用者自动设置。必须明确设置它，因为调用者必须以密度感知的方式处理结果位图。</p><h3 id="boolean-inScaled"><a href="#boolean-inScaled" class="headerlink" title="boolean inScaled"></a>boolean inScaled</h3><p>如果设置了该配置，并且 inDensity 和 inTargetDensity 不为 0，bitmap 在加载时将缩放以匹配 inTargetDensity，而不是每次绘制到 Canvas 时都依赖于图形系统对其进行缩放。</p><p>BitmapRegionDecoder 会忽略这个配置，并且不会根据密度缩放输出。（尽管支持 inSampleSize ）</p><p>此配置默认开启，如果需要 bitmap 的非缩放版本，则应将其关闭。.9 bitmaps（Nine-patch bitmaps）会忽略此配置，并且始终会缩放。</p><p>如果 inPremultiplied 设置为 false ，并且图像具有 Alpha 透明度，将此配置设置为 true 可能会导致颜色错误。</p><h3 id="boolean-inPurgeable"><a href="#boolean-inPurgeable" class="headerlink" title="boolean inPurgeable"></a>boolean inPurgeable</h3><p>@deprecated 自 android.os.Build.VERSION_CODES.LOLLIPOP（Android5.0，21） 起，此配置被忽略。</p><p>在 android.os.Build.VERSION_CODES.KITKAT（Android4.4，19）及以下版本中，如果将此配置设置为 true ，那么生成的 bitmap 将分配其像素，以便在系统需要回收内存时可以将其清除。在那种情况下，当需要再次访问像素时（例如绘制 bitmap，调用 getPixels（）），它们将被自动重新解码。</p><p>为了进行重新解码，bitmap 必须通过共享对输入的引用或对其进行复制来访问编码的数据。此区别由 inInputShareable 控制。如果 inInputShareable 为 true，则 bitmap 可能会保留对输入的浅引用。如果这 inInputShareable 为 false，则 bitmap 将显式地复制输入数据，并将其保留。即使允许共享，实现仍可以决定对输入数据进行深拷贝。</p><p>尽管 inPurgeable 可以帮助避免大的 Dalvik 堆分配（从 API 级别 11 开始），但是它牺牲了性能可预测性，因为视图系统尝试绘制的任何图像都可能会导致解码延迟，从而导致帧丢失。因此，大多数应用应避免使用 inPurgeable 来提供快速流畅的 UI。为了最小化 Dalvik 堆分配，请使用 inBitmap 配置。</p><p>该配置会被 decodeResource(Resources, int, android.graphics.BitmapFactory.Options) 或者 decodeFile(String,<br>android.graphics.BitmapFactory.Options)</p><h3 id="boolean-inInputShareable"><a href="#boolean-inInputShareable" class="headerlink" title="boolean inInputShareable"></a>boolean inInputShareable</h3><p>@deprecated 自 android.os.Build.VERSION_CODES.LOLLIPOP（Android5.0，21） 起，此配置被忽略。</p><p>在 android.os.Build.VERSION_CODES.KITKAT（Android4.4，19）及以下版本中，此配置与 inPurgeable 结合使用。如果 inPurgeable 为 false ，则会忽略此字段。如果 inPurgeable 为 true ，则配置确定 bitmap 是否可以共享对输数据（inputstream，数组等）的引用，或者是否必须进行深拷贝。</p><h3 id="boolean-inPreferQualityOverSpeed"><a href="#boolean-inPreferQualityOverSpeed" class="headerlink" title="boolean inPreferQualityOverSpeed"></a>boolean inPreferQualityOverSpeed</h3><p>@deprecated 自 android.os.Build.VERSION_CODE.N （Android7.0，24）起，此配置被忽略。输出将始终是高质量的。</p><p>在 android.os.Build.VERSION_CODES.M (Android6.0，23)及以下版本中，如果将 inPreferQualityOverSpeed 设置为 true ，则解码器将尝试以牺牲解码速度为代价，将重构图像解码为更高质量的图像。当前该字段仅影响 JPEG 解码，在这种情况下，将使用更准确但稍慢的 IDCT 方法代替。</p><h3 id="int-outWidth"><a href="#int-outWidth" class="headerlink" title="int outWidth"></a>int outWidth</h3><p>bitmap 的解码结果宽度。如果 inJustDecodeBounds 设置为 false，这将是应用所有缩放后输出 bitmap 的宽度。如果为 true，它将是输入图像的宽度，不考虑缩放。</p><p>如果尝试解码时发生错误，outWidth 将设置为-1。</p><h3 id="int-outHeight"><a href="#int-outHeight" class="headerlink" title="int outHeight"></a>int outHeight</h3><p>bitmap 的解码结果高度。如果 inJustDecodeBounds 设置为 false，这将是应用所有缩放后输出 bitmap 的高度。如果为 true，它将是输入图像的高度，不考虑缩放。</p><p>如果尝试解码时发生错误，outHeight 将设置为-1。</p><h3 id="String-outMimeType"><a href="#String-outMimeType" class="headerlink" title="String outMimeType"></a>String outMimeType</h3><p>如果明确，则将该字符串设置为解码图像的媒体类型。 如果未知或有错误，则将其设置为 null 。</p><h3 id="Bitmap-Config-outConfig"><a href="#Bitmap-Config-outConfig" class="headerlink" title="Bitmap.Config outConfig"></a>Bitmap.Config outConfig</h3><p>如果明确，为解码 bitmap 具有的像素存储方式配置。 如果未知或有错误，则将其设置为 null 。</p><h3 id="ColorSpace-outColorSpace"><a href="#ColorSpace-outColorSpace" class="headerlink" title="ColorSpace outColorSpace"></a>ColorSpace outColorSpace</h3><p>如果明确，为解码后的 bitmap 具有的色彩空间。注意，输出颜色空间不保证是 bitmap 编码的颜色空间。如果未知（例如，配置为 Bitmap.Config.ALPHA_8）或存在错误，则将其设置为 null 。</p><h3 id="byte-inTempStorage"><a href="#byte-inTempStorage" class="headerlink" title="byte[] inTempStorage"></a>byte[] inTempStorage</h3><p>用于解码的临时存储。建议 16K 左右。</p><h3 id="boolean-mCancel"><a href="#boolean-mCancel" class="headerlink" title="boolean mCancel"></a>boolean mCancel</h3><p>@deprecated 自 android.os.Build.VERSION_CODES.N （Android7.0，24）起。</p><p>指示已在此对象上调用 cancel 的标志。如果有一个中间人想要首先解码边界然后解码图像，则此配置很有用。在那种情况下，中间人可以在边界解码和图像解码之间检查是否取消了该操作。</p><h3 id="public-void-requestCancelDecode"><a href="#public-void-requestCancelDecode" class="headerlink" title="public void requestCancelDecode()"></a>public void requestCancelDecode()</h3><p>@deprecated 自 android.os.Build.VERSION_CODES.N （Android7.0，24）起，不影响解码，尽管设置了 mCancel 的值为 true。</p><p>在 android.os.Build.VERSION_CODES.M (Android6.0，23)及以下版本。调用此命令将通知解码器应该取消其操作。这不能保证取消解码，但是如果成功取消解码，则解码器操作结果将返回 null ，或者如果 inJustDecodeBounds 为 true ，则将 outWidth / outHeight 设置为-1。</p><h2 id="decode-方法"><a href="#decode-方法" class="headerlink" title="decode 方法"></a>decode 方法</h2><h3 id="decode-方法简析"><a href="#decode-方法简析" class="headerlink" title="decode 方法简析"></a>decode 方法简析</h3><h4 id="Bitmap-decodeFile-String-pathName-Options-opts"><a href="#Bitmap-decodeFile-String-pathName-Options-opts" class="headerlink" title="Bitmap decodeFile(String pathName, Options opts)"></a>Bitmap decodeFile(String pathName, Options opts)</h4><p>将文件路径解码为 bitmap 。如果指定的文件名为 null ，或无法解码为 bitmap，则该函数返回 null 。</p><ul><li>String pathName：待解码文件的完整路径名</li><li>Options opts：控制下采样以及是否应完全解码图像或仅返回尺寸的选项参数，可为 null。</li></ul><p>实际内部调用了另外一个 decode 方法：<br>Bitmap decodeStream(@Nullable InputStream is, @Nullable Rect outPadding, @Nullable Options opts)<br>（参数 String pathName -&gt; InputStream is, Rect null , Options opts）</p><h4 id="Bitmap-decodeFile-String-pathName"><a href="#Bitmap-decodeFile-String-pathName" class="headerlink" title="Bitmap decodeFile(String pathName)"></a>Bitmap decodeFile(String pathName)</h4><p>重载 Bitmap decodeFile(String pathName, Options opts)</p><p>decodeFile(pathName, null);</p><h4 id="Bitmap-decodeResourceStream-Nullable-Resources-res-Nullable-TypedValue-value-Nullable-InputStream-is-Nullable-Rect-pad-Nullable-Options-opts"><a href="#Bitmap-decodeResourceStream-Nullable-Resources-res-Nullable-TypedValue-value-Nullable-InputStream-is-Nullable-Rect-pad-Nullable-Options-opts" class="headerlink" title="Bitmap decodeResourceStream(@Nullable Resources res, @Nullable TypedValue value, @Nullable InputStream is, @Nullable Rect pad, @Nullable Options opts)"></a>Bitmap decodeResourceStream(@Nullable Resources res, @Nullable TypedValue value, @Nullable InputStream is, @Nullable Rect pad, @Nullable Options opts)</h4><p>从 InputStream 解码新的 bitmap 。此 InputStream 是从资源获得的，我们通过传递这些资源可以相应地缩放位图。</p><h4 id="Bitmap-decodeResource-Resources-res-int-id-Options-opts"><a href="#Bitmap-decodeResource-Resources-res-int-id-Options-opts" class="headerlink" title="Bitmap decodeResource(Resources res, int id, Options opts)"></a>Bitmap decodeResource(Resources res, int id, Options opts)</h4><p>打开给定的资源并且调用 decodeResourceStream 方法的代名词。</p><ul><li>Resources res：包含图像数据的资源对象。</li><li>int id：图像数据的资源 ID。</li><li>Options opts：控制下采样以及是否应完全解码图像或仅返回尺寸的选项参数，可为 null。</li></ul><p>实际内部调用了另外一个 decode 方法：<br>decodeResourceStream(@Nullable Resources res, @Nullable TypedValue value, @Nullable InputStream is, @Nullable Rect pad, @Nullable Options opts)<br>（参数 Resources res, TypedValue value = new TypedValue(), InputStream res.openRawResource(id, value), Rect null, Options opts）</p><h4 id="Bitmap-decodeResource-Resources-res-int-id"><a href="#Bitmap-decodeResource-Resources-res-int-id" class="headerlink" title="Bitmap decodeResource(Resources res, int id)"></a>Bitmap decodeResource(Resources res, int id)</h4><p>重载 Bitmap decodeResource(Resources res, int id, Options opts)</p><p>decodeResource(res, id, null);</p><h4 id="Bitmap-decodeByteArray-byte-data-int-offset-int-length-Options-opts"><a href="#Bitmap-decodeByteArray-byte-data-int-offset-int-length-Options-opts" class="headerlink" title="Bitmap decodeByteArray(byte[] data, int offset, int length, Options opts)"></a>Bitmap decodeByteArray(byte[] data, int offset, int length, Options opts)</h4><p>从指定的字节数组解码不可变的 bitmap。</p><ul><li>byte[] data：压缩图像数据的字节数组。</li><li>int offset：解码器应开始解析的 imageData 的偏移量。</li><li>int length：从偏移量开始解析的字节数。</li><li>Options opts：控制下采样以及是否应完全解码图像或仅返回尺寸的选项参数，可为 null。</li></ul><p>调用 native 解码方法：<br>private static native Bitmap nativeDecodeByteArray(byte[] data, int offset, int length, Options opts, long inBitmapHandle, long colorSpaceHandle)</p><h4 id="Bitmap-decodeByteArray-byte-data-int-offset-int-length"><a href="#Bitmap-decodeByteArray-byte-data-int-offset-int-length" class="headerlink" title="Bitmap decodeByteArray(byte[] data, int offset, int length)"></a>Bitmap decodeByteArray(byte[] data, int offset, int length)</h4><p>重载 Bitmap decodeByteArray(byte[] data, int offset, int length, Options opts)</p><p>decodeByteArray(data, offset, length, null);</p><h4 id="Bitmap-decodeStream-Nullable-InputStream-is-Nullable-Rect-outPadding-Nullable-Options-opts"><a href="#Bitmap-decodeStream-Nullable-InputStream-is-Nullable-Rect-outPadding-Nullable-Options-opts" class="headerlink" title="Bitmap decodeStream(@Nullable InputStream is, @Nullable Rect outPadding, @Nullable Options opts)"></a>Bitmap decodeStream(@Nullable InputStream is, @Nullable Rect outPadding, @Nullable Options opts)</h4><p>将输入流解码为 bitmap 。如果输入流为 null ，或者不能用于解码 bitmap ，则该函数返回 null 。 流的位置将是读取编码数据之后的位置。</p><ul><li>InputStream is：输入流，其中包含要解码为 bitmap 的原始数据。</li><li>Rect outPadding：如果不为 null ，则返回 bitmap 的填充矩形（如果存在），否则将填充设置为[-1，-1，-1，-1]。如果没有 bitmap 返回（ null ），则填充是不变的。</li><li>Options opts：控制下采样以及是否应完全解码图像或仅返回尺寸的选项参数，可为 null。</li></ul><p>如果输入流是 AssetManager.AssetInputStrea，调用 native 解码方法：<br>private static native Bitmap nativeDecodeAsset(long nativeAsset, Rect padding, Options opts,<br>long inBitmapHandle, long colorSpaceHandle)<br>否则调用私有内部方法：<br>Bitmap decodeStreamInternal(@NonNull InputStream is, @Nullable Rect outPadding, @Nullable Options opts)</p><h4 id="decodeStream-InputStream-is"><a href="#decodeStream-InputStream-is" class="headerlink" title="decodeStream(InputStream is)"></a>decodeStream(InputStream is)</h4><p>重载 Bitmap decodeStream(@Nullable InputStream is, @Nullable Rect outPadding, @Nullable Options opts)</p><p>decodeStream(is, null, null);</p><h4 id="Bitmap-decodeFileDescriptor-FileDescriptor-fd-Rect-outPadding-Options-opts"><a href="#Bitmap-decodeFileDescriptor-FileDescriptor-fd-Rect-outPadding-Options-opts" class="headerlink" title="Bitmap decodeFileDescriptor(FileDescriptor fd, Rect outPadding, Options opts)"></a>Bitmap decodeFileDescriptor(FileDescriptor fd, Rect outPadding, Options opts)</h4><p>从文件描述符解码 bitmap 。如果 bitmap 无法解码返回 null 。当返回时，描述符中的位置不会更改，因此可以按原样再次使用描述符。</p><ul><li>FileDescriptor fd：包含要解码的 bitmap 数据的文件描述符。</li><li>Rect outPadding：如果不为 null ，则返回 bitmap 的填充矩形（如果存在），否则将填充设置为[-1，-1，-1，-1]。如果没有 bitmap 返回（ null ），则填充是不变的。</li><li>Options opts：控制下采样以及是否应完全解码图像或仅返回尺寸的选项参数，可为 null。</li></ul><h4 id="Bitmap-decodeFileDescriptor-FileDescriptor-fd"><a href="#Bitmap-decodeFileDescriptor-FileDescriptor-fd" class="headerlink" title="Bitmap decodeFileDescriptor(FileDescriptor fd)"></a>Bitmap decodeFileDescriptor(FileDescriptor fd)</h4><p>重载 Bitmap decodeFileDescriptor(FileDescriptor fd, Rect outPadding, Options opts)</p><p>decodeFileDescriptor(fd, null, null);</p><h3 id="decode-方法总结"><a href="#decode-方法总结" class="headerlink" title="decode 方法总结"></a>decode 方法总结</h3><p>所有的 decode 方法最后都会走下面三个 decode 方法：</p><p>Bitmap decodeStream(@Nullable InputStream is, @Nullable Rect outPadding, @Nullable Options opts)</p><p>Bitmap decodeByteArray(byte[] data, int offset, int length, Options opts)</p><p>Bitmap decodeFileDescriptor(FileDescriptor fd, Rect outPadding, Options opts)</p><p>其中 decodeStream 和 decodeFileDescriptor 方法 有可能走以下这个方法：</p><p>Bitmap decodeStreamInternal(@NonNull InputStream is, @Nullable Rect outPadding, @Nullable Options opts)</p><p>实质是调用了 native 解码方法：<br>Bitmap nativeDecodeStream(InputStream is, byte[] storage, Rect padding, Options opts, long inBitmapHandle, long colorSpaceHandle)</p><p>因此 native 以下四个方法是 decode 的最终归宿：</p><ul><li>private static native Bitmap nativeDecodeStream(InputStream is, byte[] storage, Rect padding, Options opts, long inBitmapHandle, long colorSpaceHandle);</li><li>private static native Bitmap nativeDecodeFileDescriptor(FileDescriptor fd, Rect padding, Options opts, long inBitmapHandle, long colorSpaceHandle);</li><li>private static native Bitmap nativeDecodeAsset(long nativeAsset, Rect padding, Options opts, long inBitmapHandle, long colorSpaceHandle);</li><li>private static native Bitmap nativeDecodeByteArray(byte[] data, int offset, int length, Options opts, long inBitmapHandle, long colorSpaceHandle);</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基于 9.0（29）简析 BitmapFactory 类。&lt;/p&gt;
&lt;p&gt;我们只关注 BitmapFactor 类暴露出来的（即访问权限为 public）东西。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态内部类 Options&lt;/li&gt;
&lt;li&gt;若干 decode 方法&lt;/li&gt;
&lt;/
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="图片" scheme="https://codepoem.github.io/tags/%E5%9B%BE%E7%89%87/"/>
    
      <category term="Bitmap" scheme="https://codepoem.github.io/tags/Bitmap/"/>
    
  </entry>
  
  <entry>
    <title>模板整理之上传仓库</title>
    <link href="https://codepoem.github.io/post/%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86%E4%B9%8B%E4%B8%8A%E4%BC%A0%E4%BB%93%E5%BA%93/"/>
    <id>https://codepoem.github.io/post/模板整理之上传仓库/</id>
    <published>2019-10-09T09:19:33.000Z</published>
    <updated>2019-10-09T09:19:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们在日常打 aar 包和 jar 包，并上传到远端中央仓库时，需要引入大段 gradle 代码，较为繁琐。<br>我这里整理了常用的上传到中央仓库的 gradle 代码，提供了较为方便的使用方式。<a href="">上传代码模板 GitHub</a><br>目前只有上传到 bintray 也就是 jcenter 的整理，后期有需要其他远端中央仓库的会继续跟进。</p><hr><ul><li>模板整理<a href="https://github.com/CodePoem/VTemplate">GitHub</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在日常打 aar 包和 jar 包，并上传到远端中央仓库时，需要引入大段 gradle 代码，较为繁琐。&lt;br&gt;我这里整理了常用的上传到中央仓库的 gradle 代码，提供了较为方便的使用方式。&lt;a href=&quot;&quot;&gt;上传代码模板 GitHub&lt;/a&gt;&lt;br&gt;目前只有上传
      
    
    </summary>
    
      <category term="模板" scheme="https://codepoem.github.io/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="模板" scheme="https://codepoem.github.io/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="上传仓库" scheme="https://codepoem.github.io/tags/%E4%B8%8A%E4%BC%A0%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>模板整理之Travis CI</title>
    <link href="https://codepoem.github.io/post/%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86%E4%B9%8BTravis%20CI/"/>
    <id>https://codepoem.github.io/post/模板整理之Travis CI/</id>
    <published>2019-10-09T08:54:30.000Z</published>
    <updated>2019-10-09T08:54:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.travis-ci.com/">官方文档</a></p><p>免费 Travis-CI（针对开源项目）：<a href="https://travis-ci.org">https://travis-ci.org</a></p><p>收费 Travis-CI（针对私有和商业项目）：<a href="https://travis-ci.com">https://travis-ci.com</a></p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li>登录 Travis CI 并对指定的项目启用。</li><li>配置 .travis.yml ，参考官方文档。</li><li>push（或其他方式）触发 Travis-CI。</li></ol><h2 id="实现工作流"><a href="#实现工作流" class="headerlink" title="实现工作流"></a>实现工作流</h2><ol><li>构建。开发一些新功能，提交代码后自动构建出一个 APK（可以是测试版，也可以是发布版）。</li><li>部署。将 APK 上传到 Github Release / <a href="https://fir.im/">Fir.im</a> / <a href="https://www.pgyer.com/">蒲公英</a>等。</li><li>通知。发出通知（邮件、消息等形式）。</li></ol><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><h4 id="release-签名证书安全"><a href="#release-签名证书安全" class="headerlink" title="release 签名证书安全"></a>release 签名证书安全</h4><p>Android 项目发布需要证书文件、密码、别名、别名密码。无论是开源项目还是私有项目，任何时候都不应该将原始证书或密码放入代码库（原则上来讲证书和密码也不应该交于开发人员，而应该只能通过发布服务器进行编译）</p><p>Travis CI 为此提供了 2 种解决方案：</p><ol><li>对敏感信息、密码、证书等进行对称加密，在 CI 构建环境时解密。</li><li>将密码等通过 Travis CI 控制台设置为构建时的环境变量。</li></ol><p>个人倾向使用第二种方案，但 Travis CI 控制台无法上传文件，因此涉及到文件加密的部分，选择第一种方案。</p><h5 id="加密证书文件："><a href="#加密证书文件：" class="headerlink" title="加密证书文件："></a>加密证书文件：</h5><ol><li>本地安装 Travis CLI 命令行工具。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gem install travis<br></code></pre></td></tr></table></figure><p>这一步如果遇到错误, 尝试加 sudo，请升级一下 ruby 版本。</p><ol start="2"><li>命令行登录 Travis（第一次登录才要），并输入 GitHub 的用户名和密码。</li></ol><p>针对免费版 <a href="https://travis-ci.org：">https://travis-ci.org：</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">travis login --org<br></code></pre></td></tr></table></figure><p>针对收费版 Travis-C <a href="https://travis-ci.com：">https://travis-ci.com：</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">travis login --pro<br></code></pre></td></tr></table></figure><p>这一步如果遇到 travis 命令找不到, 尝试找到 travis 安装的 bin 目录，并配置上环境变量。</p><ol start="3"><li>进入项目根目录，加密证书。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">travis encrypt-file XXX.jks --add<br></code></pre></td></tr></table></figure><p>命令执行结果：</p><ol><li>在 Travis CI 控制台自动生成一对秘钥。</li><li>基于秘钥通过 openssl 对文件进行加密，并在根目录生成 XXX.jks.enc 文件。</li><li>在 .travis.yml 中自动生成 Travis CI 环境下解密文件的配置。</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">before_install:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">openssl</span> <span class="hljs-string">aes-256-cbc</span> <span class="hljs-string">-K</span> <span class="hljs-string">$encrypted_cd91ae131fae_key</span> <span class="hljs-string">-iv</span> <span class="hljs-string">$encrypted_cd91ae131fae_iv</span><br>    <span class="hljs-string">-in</span> <span class="hljs-string">mrd@vdreamers.enc</span> <span class="hljs-string">-out</span> <span class="hljs-string">mrd@vdreamers</span> <span class="hljs-string">-d</span><br></code></pre></td></tr></table></figure><h5 id="加密证书密码"><a href="#加密证书密码" class="headerlink" title="加密证书密码"></a>加密证书密码</h5><p>在 Travis CI 控制台配置证书密码、证书别名、证书别名密码三个环境变量（KEYSTORE_PWD、KEYSTORE_ALIAS、KEYSTORE_ALIAS_PWD）。</p><h5 id="实现本地和-Travis-CI-构建-release-包互不干扰"><a href="#实现本地和-Travis-CI-构建-release-包互不干扰" class="headerlink" title="实现本地和 Travis-CI 构建 release 包互不干扰"></a>实现本地和 Travis-CI 构建 release 包互不干扰</h5><p>基本思路，判断环境变量 CI 是否 为 true，通过 System.getenv(“CI”) 去获取环境变量 CI 的值，fals e 即为本地构建，true 即为 Travis-CI 构建。<br>本地构建去 local.properties 中读取证书配置；Travis-CI 构建通过 System.getenv 去读取环境变量的证书配置。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs gradle">apply plugin: <span class="hljs-string">&#x27;com.android.application&#x27;</span><br><br><span class="hljs-keyword">def</span> keystorePWD = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">def</span> keystoreAlias = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">def</span> keystoreAliasPWD = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-comment">// local.properties file in the root director</span><br><span class="hljs-keyword">def</span> keyFile = <span class="hljs-keyword">project</span>.rootProject.<span class="hljs-keyword">file</span>(<span class="hljs-string">&#x27;local.properties&#x27;</span>)<br><br>Properties properties = <span class="hljs-keyword">new</span> Properties()<br><span class="hljs-comment">// local.properties exists</span><br><span class="hljs-keyword">if</span> (keyFile.exists()) &#123;<br>    properties.load(keyFile.newDataInputStream())<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    keyFile = <span class="hljs-keyword">file</span>(<span class="hljs-string">&quot;../no_exists_keystore.tmp&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// local.properties contains keystore.path</span><br><span class="hljs-keyword">if</span> (properties.containsKey(<span class="hljs-string">&quot;keystore.path&quot;</span>)) &#123;<br>    keyFile = <span class="hljs-keyword">file</span>(properties.getProperty(<span class="hljs-string">&quot;keystore.path&quot;</span>))<br>    keystorePWD = properties.getProperty(<span class="hljs-string">&quot;keystore.password&quot;</span>)<br>    keystoreAlias = properties.getProperty(<span class="hljs-string">&quot;keystore.alias&quot;</span>)<br>    keystoreAliasPWD = properties.getProperty(<span class="hljs-string">&quot;keystore.alias_password&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    keyFile = <span class="hljs-keyword">file</span>(<span class="hljs-string">&quot;../no_exists_keystore.tmp&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">def</span> isRunningOnTravis = System.getenv(<span class="hljs-string">&quot;CI&quot;</span>) == <span class="hljs-string">&quot;true&quot;</span><br><span class="hljs-keyword">if</span> (isRunningOnTravis) &#123;<br>    keyFile = <span class="hljs-keyword">file</span>(<span class="hljs-string">&quot;../mrd@vdreamers&quot;</span>)<br>    keystorePWD = System.getenv(<span class="hljs-string">&quot;KEYSTORE_PWD&quot;</span>)<br>    keystoreAlias = System.getenv(<span class="hljs-string">&quot;KEYSTORE_ALIAS&quot;</span>)<br>    keystoreAliasPWD = System.getenv(<span class="hljs-string">&quot;KEYSTORE_ALIAS_PWD&quot;</span>)<br>&#125;<br><br>android &#123;<br>    signingConfigs &#123;<br>        release &#123;<br>            keyAlias keystoreAlias<br>            keyPassword keystoreAliasPWD<br>            storeFile keyFile<br>            storePassword keystorePWD<br>        &#125;<br>    &#125;<br>    buildTypes &#123;<br>        debug &#123;<br>            minifyEnabled <span class="hljs-keyword">false</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>            signingConfig signingConfigs.debug<br>        &#125;<br>        release &#123;<br>            minifyEnabled <span class="hljs-keyword">false</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>            <span class="hljs-keyword">if</span> (keyFile.exists() || isRunningOnTravis) &#123;<br>                <span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;WITH -&gt; buildTypes -&gt; release: using jks key&quot;</span>)<br>                signingConfig signingConfigs.release<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;WITH -&gt; buildTypes -&gt; release: using default key&quot;</span>)<br>                signingConfig signingConfigs.debug<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本地构建需要在本地 local.properties 中配置好证书路径 keystore.path、证书密码 keystore.password、证书别名 keystore.alias、证书别名密码 keystore.alias_password；<br>分别对应着 Travis CI 控制台加密的证书秘钥对和环境变量证书密码 KEYSTORE_PWD、证书别名 KEYSTORE_ALIAS、证书别名密码 KEYSTORE_ALIAS_PWD。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="GitHub-Release"><a href="#GitHub-Release" class="headerlink" title="GitHub Release"></a>GitHub Release</h4><ol><li>命令行自动生成 deploy 配置。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">travis setup releases<br></code></pre></td></tr></table></figure><p>需要输入 GitHub 账户名和密码以及 apk 路径，如 app/build/outputs/apk/app-release.apk<br>执行完后会自动在 .travis.yml 添加如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">provider:</span> <span class="hljs-string">releases</span><br>  <span class="hljs-attr">api_key:</span><br>    <span class="hljs-attr">secure:</span> <span class="hljs-string">qOr4mGdf8lESDCiMo7ZJbGqLEHI3cXuV4UlQ2ZzvjSpDQyXrQ2l8wHMdgTkFxmlJWReOUuumHK346StBlGA2mQ5ufc6LhtHaCJWNpnk2Nixd2qFma9ySgPakz+7NoMml4wvkgMnn4HBCTV13ucJPxEzVt8KkX1JAiN9s5rh8SkB36i9KC4i/SuAPNPx2vHbglnoPFtToBlQa+cMLRSlXVkLHYYVdWRZOBRneu/H79oPkw5ajfsSG5u7RCCcEaaAfY1oU7ho1mrB1Kogq64BemGZSkIHgF5TCmmWgNypDlAm92tCN0G3uP0xffUZZsUqYoHiflXTjyXoYG4gXXC+SCCmkkFah0DZPcTZ6AHerBJ/8YgJX6/8tV3sH89PuM6HEuPmHbE3xEsGzUZWNrkJWHdJBLi5bXZnuSRvq+JDM/0CYSYuTx+lHCcCUiODIKTXFwHOaB+J+bKUTvvz91Rd7ELodUiBTAI/hXDYmWBAgY9Snw8+qBXiA7Ocp+ykcRuiUXXxvYlLgIzqtTEnoODBOsZ5ukjJoUs2GObcOgyBt4eedv7EfUcUKxHdf7ECZbhCEvhtVvHGzzIN5BN3R8+YJKnb0CmsO6FyCgCSnTyvKlFVfSX5s0v9E7XVFrCOo1gVDoL28v7AmrDZsl1mEaRSvVcOHtAXEhZEyF0CdafJ6s5A=</span><br>  <span class="hljs-attr">file:</span> <span class="hljs-string">app/build/outputs/apk/app-release.apk</span><br>  <span class="hljs-comment"># 这句手动添加</span><br>  <span class="hljs-attr">skip_cleanup:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">on:</span><br>    <span class="hljs-attr">repo:</span> <span class="hljs-string">CodePoem/VTemplate</span><br>    <span class="hljs-comment"># 这句手动添加</span><br>    <span class="hljs-attr">tags:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ul><li>provider：发布目标为 GitHub Release ，除了 GitHub 外，Travis CI 还支持发布到 AWS 、Google App Engine 等数十种 provider 。</li><li>secure：是加密后的 GitHub Access Token 。</li><li>file：发布的文件。</li><li>skip_cleanup：默认情况下 Travis CI 在完成编译后会清除所有生成的文件，因此要将 skip_cleanup 设置为 true 来忽略此操作。</li><li>on：发布的时机，这里配置为 tags : true，即只在有 tag 的情况才发布。</li></ul><ol start="2"><li>打 Tag 后 Push 代码触发 CI 。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git tag -a v0.0.1-alpha-1 -m &quot;这里是Tag注释，说清楚这个版本的主要改动，也可以省略-m参数直接写长文本&quot;<br>git push origin --tags<br></code></pre></td></tr></table></figure><h4 id="Fir-im"><a href="#Fir-im" class="headerlink" title="Fir.im"></a><a href="https://fir.im/">Fir.im</a></h4><ol><li>登录 Fir.im 获取 API Token 。</li><li>将获取的 API Toke n 配置到 Travis CI 的环境变量 FIR_API_TOKEN。</li><li>添加配置。</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">before_install:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">gem</span> <span class="hljs-string">install</span> <span class="hljs-string">fir-cli</span><br><span class="hljs-attr">after_deploy:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">fir</span> <span class="hljs-string">p</span> <span class="hljs-string">app/build/outputs/apk/release/app-release.apk</span> <span class="hljs-string">-T</span> <span class="hljs-string">$FIR_API_TOKEN</span> <span class="hljs-string">-c</span> <span class="hljs-string">&quot;`git cat-file tag $TRAVIS_TAG`&quot;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>打 Tag 后 Push 代码触发 CI 。</li></ol><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><h4 id="SendCloud-邮件通知"><a href="#SendCloud-邮件通知" class="headerlink" title="SendCloud 邮件通知"></a>SendCloud 邮件通知</h4><ol><li>注册 SendCloud 。</li><li>创建触发式模板 update_template 。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">%TRAVIS_REPO_SLUG%新版本%TRAVIS_TAG%已经发布了，功能更新：<br><br><br>%TAG_DESCRIPTION%<br><br>去下载：<br>https://fir.im/ep8s<br></code></pre></td></tr></table></figure><ol start="3"><li>添加配置，调用发送邮件 API 。</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">after_deploy:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">curl</span> <span class="hljs-string">-d</span> <span class="hljs-string">&quot;apiUser=******&amp;apiKey=******&amp;from=test@test.com&amp;fromName=testTitle&amp;subject=测试&amp;replyTo=test@test.com&amp;templateInvokeName=update_template&quot;</span><br>    <span class="hljs-string">--data-urlencode</span> <span class="hljs-string">&quot;xsmtpapi=&#123;&#x27;to&#x27;:[&#x27;806957428@qq.com&#x27;],&#x27;sub&#x27;:&#123;&#x27;%TRAVIS_REPO_SLUG%&#x27;:[&#x27;$TRAVIS_REPO_SLUG&#x27;],&#x27;%TRAVIS_TAG%&#x27;:[&#x27;$TRAVIS_TAG&#x27;],&#x27;%TAG_DESCRIPTION%&#x27;:[&#x27;$(git cat-file tag $TRAVIS_TAG)&#x27;]&#125;&#125;&quot;</span> <span class="hljs-string">http://api.sendcloud.net/apiv2/mail/sendtemplate</span><br></code></pre></td></tr></table></figure><ol start="4"><li>打 Tag 后 Push 代码触发 CI 。</li></ol><hr><ul><li>模板整理<a href="https://github.com/CodePoem/VTemplate">GitHub</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://docs.travis-ci.com/&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;免费 Travis-CI（针对开源项目）：&lt;a href=&quot;https://travis-ci.org&quot;&gt;https://travis-ci.org&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="模板" scheme="https://codepoem.github.io/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="模板" scheme="https://codepoem.github.io/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="Travis CI" scheme="https://codepoem.github.io/tags/Travis-CI/"/>
    
  </entry>
  
  <entry>
    <title>Crash治理之TimeoutException</title>
    <link href="https://codepoem.github.io/post/Crash%E6%B2%BB%E7%90%86%E4%B9%8BTimeoutException/"/>
    <id>https://codepoem.github.io/post/Crash治理之TimeoutException/</id>
    <published>2019-09-25T07:36:46.000Z</published>
    <updated>2019-09-25T07:36:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>与 GC 过程相关的守护线程中的 2 个守护线程 FinalizerDaemon 和 FinalizerWatchdogDaemon 有关。</p><ul><li>FinalizerDaemon ：析构守护线程。对于重写了成员函数 finalize 的对象，它们被 GC 决定回收时，并没有马上被回收，而是被放入到一个队列中，等待 FinalizerDaemon 守护线程去调用它们的成员函数 finalize ，然后再被回收。</li><li>FinalizerWatchdogDaemon ：析构监护守护线程。用来监控 FinalizerDaemon 线程的执行。一旦检测那些重定了成员函数 finalize 的对象在执行成员函数 finalize 时超出一定的时间，那么就会退出 VM 。</li></ul><p>原因小总结：</p><p>GC 过程中 FinalizerDaemon 守护线程执行 doFinalize 方法超时。FinalizerWatchdogDaemon 检测到后产生 TimeoutException 并退出虚拟机。<br>（每个手机触发 Timeout 的时长不同，比如 vivo 的某些 rom 是 2 分钟，模拟器统一都是 10 秒钟）</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="理想方案"><a href="#理想方案" class="headerlink" title="理想方案"></a>理想方案</h3><ol><li>减少对 finalize() 方法的依赖，尽量不依靠 finalize() 方法释放资源，手动处理资源释放逻辑；如果不得已使用 finalize() 方法，尽量减少耗时以及线程同步时间。</li><li>减少 finalizable 对象个数，即减少有 finalize() 方法的对象创建，降低 finalizable 对象 GC 次数；Android 5.0 以后 View 默认会实现 finalize 方法，那么减少 View 的创建就是一种解决方法。</li></ol><p>理想方案现实情况下却不太容易完全做到。往往需要采用止损方案。</p><h3 id="止损方案"><a href="#止损方案" class="headerlink" title="止损方案"></a>止损方案</h3><p>止损方案本质都是不检测该异常或忽略该异常、不上报该异常，治标不治本。</p><h4 id="尝试反射去关闭-FinalizerWatchdogDaemon"><a href="#尝试反射去关闭-FinalizerWatchdogDaemon" class="headerlink" title="尝试反射去关闭 FinalizerWatchdogDaemon"></a>尝试反射去关闭 FinalizerWatchdogDaemon</h4><p><strong>限制：</strong></p><p>Android 9.0 版本开始限制 Private API 调用，不能再使用反射调用 Daemons 以及 FinalizerWatchdogDaemon 类方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WatchDogKiller</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG = <span class="hljs-string">&quot;WatchDogKiller&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> sWatchdogStopped = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkWatchDogAlive</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Class clazz;<br>        <span class="hljs-keyword">try</span> &#123;<br>            clazz = Class.forName(<span class="hljs-string">&quot;java.lang.Daemons$FinalizerWatchdogDaemon&quot;</span>);<br>            <span class="hljs-keyword">final</span> Field field = clazz.getDeclaredField(<span class="hljs-string">&quot;INSTANCE&quot;</span>);<br>            field.setAccessible(<span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">final</span> Object watchdog = field.get(<span class="hljs-keyword">null</span>);<br>            Method isRunningMethod = clazz.getSuperclass().getDeclaredMethod(<span class="hljs-string">&quot;isRunning&quot;</span>);<br>            isRunningMethod.setAccessible(<span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">boolean</span> isRunning = (<span class="hljs-keyword">boolean</span>) isRunningMethod.invoke(watchdog);<br>            <span class="hljs-keyword">return</span> isRunning;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stopWatchDog</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 建议在在debug包或者灰度包中不要stop，保留发现问题的能力。</span><br>        <span class="hljs-keyword">if</span> (!BuildConfig.DEBUG) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Android P 以后不能反射FinalizerWatchdogDaemon</span><br>        <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="hljs-number">28</span>) &#123;<br>            Log.w(TAG, <span class="hljs-string">&quot;stopWatchDog, do not support after Android P, just return&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sWatchdogStopped) &#123;<br>            Log.w(TAG, <span class="hljs-string">&quot;stopWatchDog, already stopped, just return&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        sWatchdogStopped = <span class="hljs-keyword">true</span>;<br>        Log.w(TAG, <span class="hljs-string">&quot;stopWatchDog, try to stop watchdog&quot;</span>);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> Class clazz = Class.forName(<span class="hljs-string">&quot;java.lang.Daemons$FinalizerWatchdogDaemon&quot;</span>);<br>            <span class="hljs-keyword">final</span> Field field = clazz.getDeclaredField(<span class="hljs-string">&quot;INSTANCE&quot;</span>);<br>            field.setAccessible(<span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">final</span> Object watchdog = field.get(<span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">final</span> Field thread = clazz.getSuperclass().getDeclaredField(<span class="hljs-string">&quot;thread&quot;</span>);<br>                thread.setAccessible(<span class="hljs-keyword">true</span>);<br>                thread.set(watchdog, <span class="hljs-keyword">null</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable t) &#123;<br>                Log.e(TAG, <span class="hljs-string">&quot;stopWatchDog, set null occur error:&quot;</span> + t);<br><br>                t.printStackTrace();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 直接调用stop方法，在Android 6.0之前会有线程安全问题</span><br>                    <span class="hljs-keyword">final</span> Method method = clazz.getSuperclass().getDeclaredMethod(<span class="hljs-string">&quot;stop&quot;</span>);<br>                    method.setAccessible(<span class="hljs-keyword">true</span>);<br>                    method.invoke(watchdog);<br>                &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable e) &#123;<br>                    Log.e(TAG, <span class="hljs-string">&quot;stopWatchDog, stop occur error:&quot;</span> + t);<br>                    t.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable t) &#123;<br>            Log.e(TAG, <span class="hljs-string">&quot;stopWatchDog, get object occur error:&quot;</span> + t);<br>            t.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attachBaseContext</span><span class="hljs-params">(Context base)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.attachBaseContext(base);<br>        WatchDogKiller.stopWatchDog();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="利用-Thread-UncaughtExceptionHandler-阻断-TimeoutException-处理"><a href="#利用-Thread-UncaughtExceptionHandler-阻断-TimeoutException-处理" class="headerlink" title="利用 Thread.UncaughtExceptionHandler 阻断 TimeoutException 处理"></a>利用 Thread.UncaughtExceptionHandler 阻断 TimeoutException 处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate();<br>        <span class="hljs-keyword">final</span> Thread.UncaughtExceptionHandler defaultUncaughtExceptionHandler =<br>                Thread.getDefaultUncaughtExceptionHandler();<br>        Thread.setDefaultUncaughtExceptionHandler(<span class="hljs-keyword">new</span> Thread.UncaughtExceptionHandler() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (t.getName().equals(<span class="hljs-string">&quot;FinalizerWatchdogDaemon&quot;</span>) &amp;&amp; e <span class="hljs-keyword">instanceof</span> TimeoutException) &#123;<br>                    <span class="hljs-comment">// ignore it</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    defaultUncaughtExceptionHandler.uncaughtException(t, e);<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><p><strong>推荐阅读:</strong></p><ol><li><a href="https://yq.aliyun.com/articles/225751">提升 Android 下内存的使用意识和排查能力</a></li><li><a href="https://yq.aliyun.com/articles/225755">再谈 Finalizer 对象–大型 App 中内存与性能的隐性杀手</a></li><li><a href="https://www.jianshu.com/p/18950c9b0ec9">从 Daemons 到 finalize timed out after 10 seconds</a></li><li><a href="https://blog.csdn.net/pbm863521/article/details/74451935">ART 运行时垃圾收集（GC）过程分析</a></li><li><a href="https://segmentfault.com/a/1190000019373275">滴滴出行安卓端 finalize time out 的解决方案</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;产生原因&quot;&gt;&lt;a href=&quot;#产生原因&quot; class=&quot;headerlink&quot; title=&quot;产生原因&quot;&gt;&lt;/a&gt;产生原因&lt;/h2&gt;&lt;p&gt;与 GC 过程相关的守护线程中的 2 个守护线程 FinalizerDaemon 和 FinalizerWatchdogDa
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Crash" scheme="https://codepoem.github.io/tags/Crash/"/>
    
      <category term="TimeoutException" scheme="https://codepoem.github.io/tags/TimeoutException/"/>
    
  </entry>
  
  <entry>
    <title>Android动画</title>
    <link href="https://codepoem.github.io/post/Android%E5%8A%A8%E7%94%BB/"/>
    <id>https://codepoem.github.io/post/Android动画/</id>
    <published>2019-09-16T15:48:10.000Z</published>
    <updated>2019-09-16T15:48:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android 中动画划分为两大类 视图动画（View Animation）和 属性动画（Property Animation）。其中 属性动画（Property Animation）需要在 Android3.0 之后（API &gt;= 11）使用。<br>视图动画（View Animation）又包括了 帧动画（Frame Animation） 和 补间动画（Tweened Animation）。</p><h2 id="视图动画（View-Animation）"><a href="#视图动画（View-Animation）" class="headerlink" title="视图动画（View Animation）"></a>视图动画（View Animation）</h2><h3 id="帧动画（Frame-Animation）"><a href="#帧动画（Frame-Animation）" class="headerlink" title="帧动画（Frame Animation）"></a>帧动画（Frame Animation）</h3><p>帧动画（Frame Animation） 有时也叫 Drawable 动画，这种动画的实质其实是 Drawable。像播放幻灯片一样，利用视觉残留产生动画效果。</p><p>核心类：AnimationDrawable</p><p>使用方式：</p><h4 id="XML-定义帧动画"><a href="#XML-定义帧动画" class="headerlink" title="XML 定义帧动画"></a>XML 定义帧动画</h4><p>推荐使用 XML 定义动画：</p><p>在 res/drawable 下新建 animation_frame_test.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">animation-list</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:oneshot</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">&quot;@color/colorPrimary&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:duration</span>=<span class="hljs-string">&quot;300&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">&quot;@color/colorPrimaryDark&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:duration</span>=<span class="hljs-string">&quot;300&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">animation-list</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="Java-代码创建帧动画"><a href="#Java-代码创建帧动画" class="headerlink" title="Java 代码创建帧动画"></a>Java 代码创建帧动画</h4><p>创建 AnimationDrawable 对象，addFrame(Drawable frame,int duration)向动画中添加帧，调用 start()和 stop()。</p><h3 id="补间动画（Tweened-Animation）"><a href="#补间动画（Tweened-Animation）" class="headerlink" title="补间动画（Tweened Animation）"></a>补间动画（Tweened Animation）</h3><p>补间动画（Tweened Animation）只能应用于 View 对象，而且只支持一部分属性，它只是改变了 View 对象绘制的位置，而没有改变 View 对象本身（所以点击响应区域还在原来的位置）。多用于 Window 切换动画或 Activity 跳转动画。</p><p>核心类：android.view.animation.Animator</p><p>补间动画可以分为四种形式，分别是 alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）。</p><h4 id="java-类"><a href="#java-类" class="headerlink" title="java 类"></a>java 类</h4><ul><li>AlphaAnimation 渐变透明度动画效果</li><li>RotateAnimation 画面转移旋转动画效果</li><li>ScaleAnimation 渐变尺寸伸缩动画效果</li><li>TranslateAnimation 画面转换位置移动动画效果</li><li>AnimationSet 一个持有其它动画元素 alpha、scale、translate、rotate 或者其它 set 元素的容器</li></ul><p>插值器：</p><ul><li>LinearInterpolator：动画以均匀的速度改变</li><li>AccelerateInterpolator：在动画开始的地方改变速度较慢，然后开始加速</li><li>AccelerateDecelerateInterpolator：在动画开始、结束的地方改变速度较慢，中间时加速</li><li>CycleInterpolator：动画循环播放特定次数，变化速度按正弦曲线改变： Math.sin(2 mCycles Math.PI * input)</li><li>DecelerateInterpolator：在动画开始的地方改变速度较快，然后开始减速</li><li>AnticipateInterpolator：反向，先向相反方向改变一段再加速播放</li><li>AnticipateOvershootInterpolator：开始的时候向后然后向前甩一定值后返回最后的值</li><li>BounceInterpolator： 跳跃，快到目的值时值会跳跃，如目的值 100，后面的值可能依次为 85，77，70，80，90，100</li><li>OvershottInterpolator：回弹，最后超出目的值然后缓慢改变到目的值</li></ul><h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><p>在 res/anim 下新建 animation_tweened_test_rotate.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">rotate</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:duration</span>=<span class="hljs-string">&quot;1000&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:fromDegrees</span>=<span class="hljs-string">&quot;0&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:interpolator</span>=<span class="hljs-string">&quot;@android:anim/accelerate_decelerate_interpolator&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:pivotX</span>=<span class="hljs-string">&quot;50%&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:pivotY</span>=<span class="hljs-string">&quot;50%&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:repeatCount</span>=<span class="hljs-string">&quot;infinite&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:toDegrees</span>=<span class="hljs-string">&quot;360&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>AnimationUtils.loadAnimation(Context context, @AnimRes int id)创建 Animation，然后给指定的 View 调用 view.startAnimation(Animation animation) view.clearAnimation()</p><h2 id="属性动画（Property-Animation）"><a href="#属性动画（Property-Animation）" class="headerlink" title="属性动画（Property Animation）"></a>属性动画（Property Animation）</h2><p>属性动画实现原理就是修改控件的属性值实现的动画。</p><p>核心类：android.animation.Animator</p><ul><li>Animator 创建属性动画的基类</li><li>ValueAnimator Animator 子类。其内部采用一种时间循环的机制来计算值与值之间的动画过度，我们只需将初始值以及结束值提供给该类，并告诉其动画所需时间长度，该类就会自动帮我们从初始值平滑过度到结束。该类还能管理动画的播放次数、模式和监听器等。</li><li>ObjectAnimator ValueAnimator 的子类，允许我们对指定对象的属性执行动画，用起来更简单，实际中用得较多。</li><li>AnimatorSet Animator 子类，可以组合多个 Animator，并制定 Animator 的播放次序。</li><li>Interpolator 插值器，同补间动画。</li><li>Evaluator 计算器，告诉动画系统如何从初始值过度到结束值。提供了一下的几种 Evaluator：</li></ul><p>IntEvaluator：用于计算 int 属性<br>FloatEvaluator：用于计算 float 属性<br>ArgbEvaluator：用于计算 16 进制表示颜色值的计算器<br>TypeEvaluator：上述计算类的公共接口，可以自己实现接口完成自定义</p><p>监听器：</p><p>AnimatorUpdateListener： 当值状态发生改变时候会回调 onAnimationUpdate 方法。</p><p>AnimatorListener、AnimatorListenerAdapter：</p><ul><li>onAnimationStart()：动画开始</li><li>onAnimationRepeat()：动画重复执行</li><li>onAnimationEnd()：动画结束</li><li>onAnimationCancel()：动画取消</li></ul><p>平常开发，属性动画多使用 ValueAnimator 和 ObjectAnimator。<br>ValueAnimator 有个缺点，就是只能对数值对动画计算。<br>为了能让动画直接与对应控件相关联，以使我们从监听动画过程中解放出来，可以使用 ValueAnimator 的子类 ObjectAnimator。</p><p>使用 ObjectAnimator 实现动画也有一些要求和限制：</p><ol><li>动画显示的属性必须带有一个 setter 方法（以骆驼拼写法命名）。 因为 ObjectAnimator 会在动画期间自动更新属性值，它必须能够用此 setter 方法访问到该属性。 例如：假设属性名称为 color，则需要有一个 setColor()方法。</li><li>如果在调用 ObjectAnimator 的某个工厂方法时，我们只为 values… 参数指定了一个值，那此值将被认定为动画属性的结束值。 这样的话，动画显示的属性必须带有一个 getter 方法，用于获取动画的起始值。例如：假设属性名为 color，则需要有一个 getColor()方法。</li><li>动画属性的 getter 方法（如果必要的话）和 setter 方法所操作数据的类型必须与 ObjectAnimator 中设定的起始和结束值相同。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android 中动画划分为两大类 视图动画（View Animation）和 属性动画（Property Animation）。其中 属性动画（Property Animation）需要在 Android3.0 之后（API &amp;gt;= 11）使用。&lt;br&gt;视图动画（Vi
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="动画" scheme="https://codepoem.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>Android自定义View</title>
    <link href="https://codepoem.github.io/post/Android%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    <id>https://codepoem.github.io/post/Android自定义View/</id>
    <published>2019-09-16T04:34:07.000Z</published>
    <updated>2019-09-16T04:34:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是自定义-View"><a href="#什么是自定义-View" class="headerlink" title="什么是自定义 View"></a>什么是自定义 View</h2><p>自定义 View 就是通过继承 View 或者 View 的子类，并在继承的类里面实现自定义的处理逻辑（重写相应的方法），以达到自己想要的效果。</p><h2 id="为什么要自定义-View"><a href="#为什么要自定义-View" class="headerlink" title="为什么要自定义 View"></a>为什么要自定义 View</h2><ul><li>让界面有特定的显示效果、交互</li><li>优化布局（减少布局层次）</li><li>封装</li></ul><h2 id="如何自定义-View"><a href="#如何自定义-View" class="headerlink" title="如何自定义 View"></a>如何自定义 View</h2><h3 id="自定义-View-主要流程"><a href="#自定义-View-主要流程" class="headerlink" title="自定义 View 主要流程"></a>自定义 View 主要流程</h3><ol><li>测量阶段 measure</li><li>布局阶段 layout</li><li>绘制阶段 draw</li></ol><p>背景：DecorView 是视图的顶级 View，我们添加的布局文件是它的一个子布局，而 ViewRootImpl 则负责渲染视图，它调用了一个 performTraveals 方法使得 ViewTree 开始三大工作流程（performMeasure、performLayout、performDraw），然后使得 View 展现在我们面前。</p><h4 id="测量过程"><a href="#测量过程" class="headerlink" title="测量过程"></a>测量过程</h4><p>ViewRootImpl.performMeasure() -&gt; View.measure() -&gt; View.onMesure()</p><p>measure()：调度方法，主要做一些前置和优化工作，并最终会调用 onMeasure() 方法执行实际的测量工作。<br>onMesure()：实际执行测量任务的方法，主要用与测量 View 尺寸和位置。在自定义 View 的 onMeasure() 方法中，View 根据自己的特性和父 View 对自己的尺寸要求算出自己的期望尺寸，并通过 setMeasuredDimension() 方法告知父 View 自己的期望尺寸。</p><p>MeasureSpec：封装 View 的规格尺寸，由 32 位整型表示测量模式（高 2 位）+测量大小（低 30 位）。</p><h4 id="布局过程"><a href="#布局过程" class="headerlink" title="布局过程"></a>布局过程</h4><p>ViewRootImpl.performLayout() -&gt; View.layout() -&gt; View.onLayout()</p><p>layout：保存 View 的实际尺寸。调用 setFrame() 方法保存 View 的实际尺寸，调用 onSizeChanged() 通知开发者 View 的尺寸更改了，并最终会调用 onLayout() 方法让子 View 布局（因为自定义 View 中没有子 View，所以自定义 View 的 onLayout() 方法是一个空实现）。<br>onLayout： 空实现，什么也不做，因为它没有子 View。</p><h4 id="绘制过程"><a href="#绘制过程" class="headerlink" title="绘制过程"></a>绘制过程</h4><p>ViewRootImpl.performDraw() -&gt; View.draw() -&gt; View.onDraw()</p><p>draw()：绘制阶段的总调度方法，在其中会调用绘制背景的方法 drawBackground()、绘制主体的方法 onDraw()、绘制子 View 的方法 dispatchDraw() 和 绘制前景的方法 onDrawForeground()。<br>drawBackground()：绘制背景的方法，不能重写，只能通过 xml 布局文件或者 setBackground() 来设置或修改背景。<br>onDraw()：绘制 View 主体内容的方法，通常情况下，在自定义 View 的时候，只用实现该方法即可。<br>dispatchDraw()：绘制子 View 的方法。同 onLayout() 方法一样，在自定义 View 中它是空实现，什么也不做。<br>onDrawForeground()：绘制 View 前景的方法，也就是说，想要在主体内容之上绘制东西的时候就可以在该方法中实现。</p><h3 id="自定-ViewGroup-主要流程"><a href="#自定-ViewGroup-主要流程" class="headerlink" title="自定 ViewGroup 主要流程"></a>自定 ViewGroup 主要流程</h3><p>大部分流程和自定义 View 一致，就不再赘述。这里只列出和自定义 View 不一样的地方。</p><ol><li><p>onMeasure()：在自定义 ViewGroup 的 onMeasure() 方法中，ViewGroup 会递归调用子 View 的 measure() 方法，并通过 measure() 将 ViewGroup 对子 View 的尺寸要求（ViewGroup 会根据开发者对子 View 的尺寸要求、自己的父 View（ViewGroup 的父 View） 对自己的尺寸要求和自己的可用空间计算出自己对子 View 的尺寸要求）传入，对子 View 进行测量，并把测量结果临时保存，以便在布局阶段使用。测量出子 View 的实际尺寸之后，ViewGroup 会根据子 View 的实际尺寸计算出自己的期望尺寸，并通过 setMeasuredDimension() 方法告知父 View（ViewGroup 的父 View） 自己的期望尺寸。</p></li><li><p>layout()：保存 ViewGroup 的实际尺寸。调用 setFrame() 方法保存 ViewGroup 的实际尺寸，调用 onSizeChanged() 通知开发者 ViewGroup 的尺寸更改了，并最终会调用 onLayout() 方法让子 View 布局。</p></li><li><p>onLayout()：ViewGroup 会递归调用每个子 View 的 layout() 方法，把测量阶段计算出的子 View 的实际尺寸和位置传给子 View，让子 View 保存自己的实际尺寸和位置。</p></li><li><p>draw() -&gt; dispatchDraw()：绘制子 View 的方法。在自定义 ViewGroup 中，它会调用 ViewGroup.drawChild() 方法，在 ViewGroup.drawChild() 方法中又会调用每一个子 View 的 View.draw() 让子 View 进行自我绘制。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是自定义-View&quot;&gt;&lt;a href=&quot;#什么是自定义-View&quot; class=&quot;headerlink&quot; title=&quot;什么是自定义 View&quot;&gt;&lt;/a&gt;什么是自定义 View&lt;/h2&gt;&lt;p&gt;自定义 View 就是通过继承 View 或者 View 的子类，并
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="自定义View" scheme="https://codepoem.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
  </entry>
  
</feed>
