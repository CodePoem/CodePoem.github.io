<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>小记-第一次报告 Android 官方文档错误</title>
    <link href="/post/%E5%B0%8F%E8%AE%B0-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8A%A5%E5%91%8A%20Android%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%94%99%E8%AF%AF/"/>
    <url>/post/%E5%B0%8F%E8%AE%B0-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8A%A5%E5%91%8A%20Android%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在阅读 Android 官方文档<a href="https://developer.android.com/jetpack/guide">《应用架构指南》</a>一篇，在实操过程中发现示例代码的一处错误。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><a href="https://developer.android.com/jetpack/guide#connect-viewmodel-repository">UserProfileViewModel</a> 的示例代码中</p><p>代码行：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> user = LiveData&lt;User&gt; = _user<br></code></pre></td></tr></table></figure><p>应该为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> user :LiveData&lt;User&gt; = _user<br></code></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本次发现也已向 Google 提交了 <a href="https://issuetracker.google.com/issues/190329948">issue</a>，并得到了反馈。</p><p>虽然只是一处简单的文档笔误，但是也见证了我仔细阅读文档并实操的过程。</p><hr><p>另外，这是我第一次对 Android 官方文档反馈问题，算是拿到“一血”，仅此记录一下~</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>小计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android适配-文件存储</title>
    <link href="/post/Android%E9%80%82%E9%85%8D-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/"/>
    <url>/post/Android%E9%80%82%E9%85%8D-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="FileProvider"><a href="#FileProvider" class="headerlink" title="FileProvider"></a>FileProvider</h2><p>历史问题：File Uri 访问控制需要开放底层文件系统权限，开放的权限直到下次关闭之对任何 App 应用都可用。这种级别的访问从根本上说是不安全的。</p><p>解决方案：FileProvider</p><p>Content Uri 访问控制，“路由映射”设计，无需修改开放底层文件系统权限，只需授予运行时级别的临时权限。</p><ol><li><p>AndroidManifest 中声明 FileProvider。考虑到与依赖代码的兼容，不建议直接使用 FileProvider，建议自定义类继承 FileProvider，并制定唯一的 android:authorities 属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleFileProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FileProvider</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>AndroidManifest.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">provider</span></span><br><span class="hljs-tag">     <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.XXX.XXX.sample.AppleFileProvider&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;$&#123;applicationId&#125;.file.provider&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">android:grantUriPermissions</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><br> <span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>android:name 属性为 FileProvider 组件名。</li><li>android:authorities 属性为控制域，一般是由包名+自定义的标识构成。</li><li>android:exported 属性设置为 false; FileProvider 不需要公开。</li><li>android:grantUriPermissions 属性设置为 true，以允许授予对文件的临时访问权限。</li></ul></li><li><p>定义“路由映射”关系，即指定 android.support.FILE_PROVIDER_PATHS &lt;meta-data&gt; 元素.</p><p>参考官方文档<a href="https://developer.android.google.cn/reference/androidx/core/content/FileProvider#SpecifyFiles">Specifying Available Files</a></p><p>AndroidManifest.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">provider</span></span><br><span class="hljs-tag">     <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.XXX.XXX.sample.AppleFileProvider&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;$&#123;applicationId&#125;.file.provider&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">android:grantUriPermissions</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><br>     <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><br><span class="hljs-tag">         <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">android:resource</span>=<span class="hljs-string">&quot;@xml/apple_file_provider&quot;</span>/&gt;</span><br><br> <span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span><br></code></pre></td></tr></table></figure><p>apple_file_provider.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">paths</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">files-path</span></span><br><span class="hljs-tag">         <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;.&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;files_temp&quot;</span> /&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">cache-path</span></span><br><span class="hljs-tag">         <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;.&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cache_temp&quot;</span> /&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">external-path</span></span><br><span class="hljs-tag">         <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;.&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;external_temp&quot;</span> /&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">external-cache-path</span></span><br><span class="hljs-tag">         <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;.&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;external_cache_temp&quot;</span> /&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">external-files-path</span></span><br><span class="hljs-tag">         <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;.&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;external_files_temp&quot;</span> /&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">external-media-path</span></span><br><span class="hljs-tag">         <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;.&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;external-media_temp&quot;</span> /&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">root-path</span></span><br><span class="hljs-tag">         <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;.&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;root_content_temp&quot;</span> /&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">paths</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>files-path 表示应用程序内部存储区域子目录中的文件。对应 API Context.getFilesDir()。</li><li>cache-path 表示应用程序内部存储区域的缓存子目录中的文件。对应 API Context.getCacheDir()。</li><li>external-path 表示外部存储区根目录下的文件。对应 API Environment.getExternalStorageDirectory()。</li><li>external-files-path 表示应用程序外部存储区域根目录中的文件。对应 API ContextCompat.getExternalFilesDirs(context, null)。</li><li>external-cache-path 表示应用程序外部缓存区域根目录中的文件。对应 API ContextCompat.getExternalCacheDirs(context)。</li><li>external-media-path 表示应用程序外部媒体区域根目录中的文件。对应 API Context.getExternalMediaDirs()。（API 21+）</li></ul><p>注意：root-path 表示设备根目录，可以获取到外置 SD 卡文件。root-path 官方文档里没有提到，但在 FileProvider 源码里有涉及。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ContentProvider</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG_ROOT_PATH = <span class="hljs-string">&quot;root-path&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG_FILES_PATH = <span class="hljs-string">&quot;files-path&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG_CACHE_PATH = <span class="hljs-string">&quot;cache-path&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG_EXTERNAL = <span class="hljs-string">&quot;external-path&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG_EXTERNAL_FILES = <span class="hljs-string">&quot;external-files-path&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG_EXTERNAL_CACHE = <span class="hljs-string">&quot;external-cache-path&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG_EXTERNAL_MEDIA = <span class="hljs-string">&quot;external-media-path&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体“路由映射”逻辑可自行查看 FileProvider 源码中 parsePathStrategy 方法的实现。</p></li><li><p>运行时获取 content uri。</p><p>FileProvider.getUriForFile() 即可将 file Uri 转换为传输时所需的 content Uri。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Uri <span class="hljs-title">getContentUri</span><span class="hljs-params">(Context context, String authority, File file)</span> </span>&#123;<br>    Uri contentUri;<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;<br>        contentUri = FileProvider.getUriForFile(context, authority, file);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        contentUri = Uri.fromFile(file);<br>    &#125;<br>    <span class="hljs-keyword">return</span> contentUri;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="分区存储"><a href="#分区存储" class="headerlink" title="分区存储"></a>分区存储</h2><p>存储目录可以参考之前写的文章 <a href="https://codepoem.fun/2019/05/05/Android%E5%AD%98%E5%82%A8%E7%9B%AE%E5%BD%95/">Android 存储目录.md</a>。</p><p>历史问题：App 开发者未遵循规范，滥用公有存储目录，导致用户相册等公有目录下文件混乱不堪。</p><p>解决方案：分区存储。</p><p>在分区存储的强制规范下，媒体文件要存放到公有目录，就必须直接或间接地使用 MediaStore 的 API 来统一存储到媒体库。</p><p>两个规则强制执行，来规范 App 开发者存储文件行为。</p><ol><li>强制要求指定相对路径，可以理解为子目录，且必须是公有目录默认媒体目录分类（DCIM、Picture、Music、Video、Download、Document）中的一个。</li><li>Android 11 强制执行分区存储，即使申请了外部空间读写权限，直接通过 File Uri 来读写也会抛出异常。</li></ol><p>适配方案：</p><ul><li><p>操作私有目录（包括内部存储私有目录和外部存储私有目录）。<br>使用 Context 相关 API，无需权限。</p></li><li><p>操作外部存储公有目录。</p><ol><li>SAF （全称 Storage Access Framework，存储访问框架），无需权限即可访问自己或其他 App 的公有媒体文件。SAF 的缺点是界面单调、操作不便、不可定制交互。</li><li>根据 API 适配。<ol><li>Android 4.4 - 10 仍旧使用 File API Environment.getExternalStorageDirectory()。<br>Android 6、0 需要动态申请外部存储权限。<br>Android 10 须通过在 manifest 的 Application 节点添加 requestLegacyExternalStorage = true 来声明对 File Api 方式的兼容。</li><li>Android 11 使用 MediaStore 读写，访问自己 App 的文件无需权限。读取其他 App 媒体文件需要 READ_EXTERNAL_STORAGE 权限，写入其他 App 媒体文件需要 MANAGE_EXTERNAL_STORAGE 权限。</li></ol></li></ol></li></ul><hr><p>相关文章：<br><a href="https://codepoem.fun/2019/05/05/Android%E5%AD%98%E5%82%A8%E7%9B%AE%E5%BD%95/">Android 存储目录.md</a><br><a href="https://codepoem.fun/2019/11/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1Android7.0%E9%80%82%E9%85%8DFileProvider%E8%B8%A9%E5%9D%91/">记录一次 Android7.0 适配 FileProvider 踩坑.md</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Android适配</tag>
      
      <tag>文件存储</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>厚薄</title>
    <link href="/post/%E5%8E%9A%E8%96%84/"/>
    <url>/post/%E5%8E%9A%E8%96%84/</url>
    
    <content type="html"><![CDATA[<p>所谓厚薄，<br>书从厚读到薄，从薄读到厚，<br>厚积薄发。</p><p>重拾基础，备忘备战~</p><ul><li><p>数据结构与算法</p><p><a href="https://github.com/CodePoem/VAlgorithm">VAlgorithm</a> -&gt; <a href="https://codepoem.fun/VAlgorithm">go to browse</a></p></li><li><p>设计模式</p><p><a href="https://github.com/CodePoem/VDesignPatterns">VDesignPatterns</a> -&gt; <a href="https://codepoem.fun/VDesignPatterns">go to browse</a></p></li><li><p>Android 知识体系</p><p><a href="https://github.com/CodePoem/VAndroidReview">VAndroidReview</a> -&gt; <a href="https://codepoem.fun/VAndroidReview">go to browse</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>厚薄</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Base</tag>
      
      <tag>厚薄</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优雅Intent ActivityResult</title>
    <link href="/post/%E4%BC%98%E9%9B%85Intent%20ActivityResult/"/>
    <url>/post/%E4%BC%98%E9%9B%85Intent%20ActivityResult/</url>
    
    <content type="html"><![CDATA[<h2 id="ActivityResult-新时代"><a href="#ActivityResult-新时代" class="headerlink" title="ActivityResult 新时代"></a>ActivityResult 新时代</h2><p>跳转 Activity 获取返回值，我们怎么做?</p><p>AndroidX Activity 1.2.0-alpha02 和 Fragment 1.3.0-alpha02 是新旧时代的划分线。</p><p>调用方假设为 IntentsActivity，被调用方假设为 IntentResultActivity。</p><ul><li><p>旧石器时代：</p><p>调用方：</p><ol><li>调用 startActivityForResult 传入请求码，传输数据（可选）。</li><li>覆写 onActivityResult 方法，根据请求码和结果码获取返回结果信息。</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntentsConstants</span> </span>&#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> REQUEST_CODE_OLD = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> RESULT_CODE_OLD = <span class="hljs-number">100</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> EXTRA_RESULT_OLD_REQUEST = <span class="hljs-string">&quot;extra_result_old_request&quot;</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> EXTRA_RESULT_OLD_RESULT = <span class="hljs-string">&quot;extra_result_old_result&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">val</span> intent = Intent(<span class="hljs-keyword">this</span><span class="hljs-symbol">@IntentsActivity</span>, IntentResultActivity::<span class="hljs-keyword">class</span>.java)<br>  <span class="hljs-keyword">val</span> bundle = Bundle()<br>  bundle.putString(EXTRA_RESULT_OLD_REQUEST, <span class="hljs-string">&quot;OLD&quot;</span>)<br>  intent.putExtras(bundle)<br>  startActivityForResult(<br>      intent,<br>      IntentsConstants.REQUEST_CODE_OLD<br>  )<br>&#125;<br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityResult</span><span class="hljs-params">(requestCode: <span class="hljs-type">Int</span>,   resultCode: <span class="hljs-type">Int</span>, <span class="hljs-keyword">data</span>: <span class="hljs-type">Intent</span>?)</span></span> &#123;<br>  <span class="hljs-keyword">super</span>.onActivityResult(requestCode, resultCode, <span class="hljs-keyword">data</span>)<br>  <span class="hljs-keyword">if</span> (requestCode == IntentsConstants.REQUEST_CODE_OLD &amp;&amp; resultCode == IntentsConstants.RESULT_CODE_OLD) &#123;<br>      <span class="hljs-keyword">val</span> result = <span class="hljs-keyword">data</span>?.extras?.getString(IntentsConstants.EXTRA_RESULT_OLD_RESULT)<br>      Toast.makeText(<span class="hljs-keyword">this</span><span class="hljs-symbol">@IntentsActivity</span>, <span class="hljs-string">&quot;result: <span class="hljs-variable">$result</span>&quot;</span>, Toast.LENGTH_SHORT).show()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>被调用方：</p><ol><li>finish 前 调用 setResult，传入结果码，返回数据（可选）。</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBackPressed</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> resultIntent = Intent()<br>    <span class="hljs-keyword">val</span> resultBundle = Bundle()<br>    resultBundle.putString(IntentsConstants.EXTRA_RESULT_OLD_RESULT, <span class="hljs-string">&quot;resultold&quot;</span>)<br>    resultIntent.putExtras(resultBundle)<br><br>    setResult(IntentsConstants.RESULT_CODE_OLD, resultIntent)<br>    <span class="hljs-keyword">super</span>.onBackPressed()<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>新石器时代</p><ol><li>引入依赖 AndroidX Activity 1.2.0-alpha02 和 Fragment 1.3.0-alpha02 或以上版本。</li><li>定义协议</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">implementation <span class="hljs-string">&#x27;androidxactivity:activity-ktx:1.2.0-beta02&#x27;</span><br>implementation <span class="hljs-string">&#x27;androidxfragment:fragment-ktx:1.3.0-beta02&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntentResultContract</span> : <span class="hljs-type">ActivityResultContract</span>&lt;<span class="hljs-type">String, String</span>&gt;</span>() &#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createIntent</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>, input: <span class="hljs-type">String</span>?)</span></span>: Intent &#123;<br>      <span class="hljs-keyword">return</span> Intent(context, IntentResultActivity::<span class="hljs-keyword">class</span>.java).apply &#123;<br>          putExtras(Bundle().apply &#123;<br>              putString(EXTRA_RESULT_NEW_REQUEST, <span class="hljs-string">&quot;NEW&quot;</span>)<br>          &#125;)<br>      &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">parseResult</span><span class="hljs-params">(resultCode: <span class="hljs-type">Int</span>, intent: <span class="hljs-type">Intent</span>?)</span></span>: String? &#123;<br>      <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = intent?.extras?.getString(EXTRA_RESULT_NEW_RESULT)<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (resultCode == RESULT_CODE_NEW &amp;&amp; <span class="hljs-keyword">data</span> != <span class="hljs-literal">null</span>) <span class="hljs-keyword">data</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span><br>  &#125;<br><br>  <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>      <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> RESULT_CODE_NEW = <span class="hljs-number">200</span><br><br>      <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> EXTRA_RESULT_NEW_REQUEST = <span class="hljs-string">&quot;extra_result_new_request&quot;</span><br>      <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> EXTRA_RESULT_NEW_RESULT = <span class="hljs-string">&quot;extra_result_new_result&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用方：</p><ol><li>注册协议</li><li>启动协议</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> intentsActivityLauncher =<br>registerForActivityResult(IntentResultContract()) &#123; result -&gt;<br>    Toast.makeText(<span class="hljs-keyword">this</span><span class="hljs-symbol">@IntentsActivity</span>, <span class="hljs-string">&quot;result: <span class="hljs-variable">$result</span>&quot;</span>, Toast.LENGTH_SHORT).show()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span> &#123;<br>  intentsActivityLauncher.launch(<span class="hljs-string">&quot;NEW&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>被调用方：</p><ol><li>finish 前 调用 setResult，传入结果码，返回数据（可选）。</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBackPressed</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">val</span> resultIntent = Intent()<br>  <span class="hljs-keyword">val</span> resultBundle = Bundle()<br>  resultBundle.putString(IntentsConstants.EXTRA_RESULT_NEW_RESULT, <span class="hljs-string">&quot;resultnew&quot;</span>)<br>  resultIntent.putExtras(resultBundle)<br><br>  setResult(IntentsConstants.RESULT_CODE_NEW, resultIntent)<br>  <span class="hljs-keyword">super</span>.onBackPressed()<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul><li>ActivityResultContract：协议，定义了如何传递数据和如何处理返回的数据。</li><li>ActivityResultLauncher： 启动器，调用 ActivityResultLauncher 的 launch 方法来启动页面跳转，作用相当于原来的 startActivity()。</li></ul><h3 id="库中默认已实现-Contract"><a href="#库中默认已实现-Contract" class="headerlink" title="库中默认已实现 Contract"></a>库中默认已实现 Contract</h3><p>库中默认已实现的 Contract 都定义在 androidx.activity.result.contract.ActivityResultContracts 中。</p><ul><li><p>StartActivityForResult: 通用的 Contract，不做任何转换，Intent 作为输入，ActivityResult 作为输出，这也是最常用的一个协定。</p></li><li><p>RequestMultiplePermissions： 用于请求一组权限。</p></li><li><p>RequestPermission: 用于请求单个权限。</p></li><li><p>TakePicturePreview: 调用 MediaStore.ACTION_IMAGE_CAPTURE 拍照，返回值为 Bitmap 图片。</p></li><li><p>TakePicture: 调用 MediaStore.ACTION_IMAGE_CAPTURE 拍照，并将图片保存到给定的 Uri 地址，返回 true 表示保存成功。</p></li><li><p>TakeVideo: 调用 MediaStore.ACTION_VIDEO_CAPTURE 拍摄视频，保存到给定的 Uri 地址，返回一张缩略图。</p></li><li><p>PickContact: 从通讯录 APP 获取联系人。</p></li><li><p>GetContent: 提示用选择一条内容，返回一个通过 ContentResolver#openInputStream(Uri) 访问原生数据的 Uri 地址（content://形式） 。默认情况下，它增加了 Intent#CATEGORY_OPENABLE, 返回可以表示流的内容。</p></li><li><p>CreateDocument: 提示用户选择一个文档，返回一个(file:/http:/content:)开头的 Uri。</p></li><li><p>OpenMultipleDocuments: 提示用户选择文档（可以选择多个），分别返回它们的 Uri，以 List 的形式。</p></li><li><p>OpenDocumentTree: 提示用户选择一个目录，并返回用户选择的作为一个 Uri 返回，应用程序可以完全管理返回目录中的文档。</p></li></ul><h2 id="ActivityResult-新时代优势"><a href="#ActivityResult-新时代优势" class="headerlink" title="ActivityResult 新时代优势"></a>ActivityResult 新时代优势</h2><ol><li><p>以回调的方式获取返回值，而不是覆写方法。个人认为覆写方法获取返回值有一种“割裂”的感觉。</p></li><li><p>减少了样板代码，自定义 Contract 可以复用传值和解析值的逻辑。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Intent</tag>
      
      <tag>ActivityResult</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>译-viewlifecycleowner与this对比</title>
    <link href="/post/%E8%AF%91-viewlifecycleowner%E4%B8%8Ethis%E5%AF%B9%E6%AF%94/"/>
    <url>/post/%E8%AF%91-viewlifecycleowner%E4%B8%8Ethis%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<p>哈喽，Android 小伙伴们~</p><p>这篇文章将提到 Fragment 中的两种 lifecycleowners。因为作为一个 Android 开发者，我们能够简单地使用 Fragment 作为 lifecycle owner，但某些情境下这可能会使你烦恼。</p><p>让我们先来看一下 Fragment 的生命周期：</p><center><p><img src="/assert/img/lifecycle/fragment_lifecycle.png" alt="FragmentLifecycle"></p></center><p>从图中我们可以看到 onCreate 和 onDestroy 只调用了一次。这些是 Fragment 的主要的生命周期方法。 onCreateView 和 onDestroyView 根据 Fragment 的状态来被调用，因为它们是 Fragment 中 View 的主要生命周期方法。</p><p>因此，如果我们在 onCreate 中绑定 LiveData ，仅仅注册一次似乎是很合适很健康的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">liveData.observe(<span class="hljs-keyword">this</span>, observer)<br></code></pre></td></tr></table></figure><p>然而当我们跳转到另一个 Fragment 并且改变 LiveData 的值后再回到之前的 Fragment 时会发生什么呢?</p><p>返回到之前的 Fragment 时，我们不能获取到 LiveData 最新的数据，需要去请求它。</p><p>因此似乎使用 View 的 LifeCycle 方法是更有用的。在这种条件下，我们可能犯的一个共同的错误是使用 Fragment 作为 LifeCycle owner。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 在 onViewCreated, onCreateView, onActivityCreated 中调用</span><br><span class="hljs-comment">// 错误!!! 它可能造成重复观察或其他问题</span><br>liveData.observe(<span class="hljs-keyword">this</span>, observer)<br></code></pre></td></tr></table></figure><p>我们应该使用 viewLifecycleOwner :</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 在 onViewCreated, onCreateView, onActivityCreated 中调用</span><br>liveData.observe(viewLifecycleOwner, observer)<br></code></pre></td></tr></table></figure><hr><p><a href="https://medium.com/@cs.ibrahimyilmaz/viewlifecycleowner-vs-this-a8259800367b">原文</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>译文</tag>
      
      <tag>lifecycle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优雅FindViewById</title>
    <link href="/post/%E4%BC%98%E9%9B%85FindViewById/"/>
    <url>/post/%E4%BC%98%E9%9B%85FindViewById/</url>
    
    <content type="html"><![CDATA[<h2 id="findBiewById"><a href="#findBiewById" class="headerlink" title="findBiewById"></a>findBiewById</h2><p>findBiewById 是 Android 开发中在布局中查找 View 元素的 Api。</p><h3 id="findBiewById-基本使用"><a href="#findBiewById-基本使用" class="headerlink" title="findBiewById 基本使用"></a>findBiewById 基本使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br>  TextView mTextDemo;<br><br>  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    setContentView(R.layout.activity_demo);<br>    mTextDemo = (TextView) findViewById(R.id.tv_demo);<br>    mTextDemo.setText(<span class="hljs-string">&quot;Demo&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为写起来很繁琐（而且还需要手动强转类型），所以逐渐出现了各种简化或者代替它的方式。</p><h3 id="省略强转"><a href="#省略强转" class="headerlink" title="省略强转"></a>省略强转</h3><p>从 <a href="https://developer.android.google.cn/topic/libraries/support-library/rev-archive.html">Android Support Library 26.0.0 Beta 1</a> 开始 findViewById 将不再需要强转了。</p><p>findViewById() 方法的所有实例现在会返回 &lt;T extends View&gt; T，而不是 View。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br>  TextView mTextDemo;<br><br>  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    setContentView(R.layout.activity_demo);<br>    mTextDemo = findViewById(R.id.tv_demo);<br>    mTextDemo.setText(<span class="hljs-string">&quot;Demo&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="findBiewById-原理"><a href="#findBiewById-原理" class="headerlink" title="findBiewById 原理"></a>findBiewById 原理</h3><p>findBiewById 原理实质上是递归遍历查找匹配 Id 的 View。</p><p>Activity 中 findViewId 方法会调用获取 Window -&gt; DecoreView -&gt; View 的 findBiewById 方法。</p><p>最终会调用到 View 中的 findViewTraversal 方法。方法名看上去是遍历操作，在 View 类中找不到遍历逻辑；<br>实际上 ViewGroup 覆写了 View 的 findViewTraversal 方法，实现了递归遍历查找匹配 View 的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">View</span> </span>&#123;<br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;T extends View&gt; <span class="hljs-function">T <span class="hljs-title">findViewById</span><span class="hljs-params">(<span class="hljs-meta">@IdRes</span> <span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (id == NO_ID) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> findViewTraversal(id);<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> &lt;T extends View&gt; <span class="hljs-function">T <span class="hljs-title">findViewTraversal</span><span class="hljs-params">(<span class="hljs-meta">@IdRes</span> <span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (id == mID) &#123;<br>            <span class="hljs-keyword">return</span> (T) <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewGroup</span> </span>&#123;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * &#123;<span class="hljs-doctag">@hide</span>&#125;</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">protected</span> &lt;T extends View&gt; <span class="hljs-function">T <span class="hljs-title">findViewTraversal</span><span class="hljs-params">(<span class="hljs-meta">@IdRes</span> <span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (id == mID) &#123;<br>            <span class="hljs-keyword">return</span> (T) <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">final</span> View[] where = mChildren;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> len = mChildrenCount;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            View v = where[i];<br><br>            <span class="hljs-keyword">if</span> ((v.mPrivateFlags &amp; PFLAG_IS_ROOT_NAMESPACE) == <span class="hljs-number">0</span>) &#123;<br>                v = v.findViewById(id);<br><br>                <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> (T) v;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ButterKnife"><a href="#ButterKnife" class="headerlink" title="ButterKnife"></a><a href="https://jakewharton.github.io/butterknife/">ButterKnife</a></h2><p>ButterKnife 是 jakewharton 大神开源作品，用于替代 findViewById ，避免繁琐的写法。</p><h3 id="ButterKnife-基本使用"><a href="#ButterKnife-基本使用" class="headerlink" title="ButterKnife 基本使用"></a>ButterKnife 基本使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br>  <span class="hljs-meta">@BindView(R.id.tv_demo)</span><br>  TextView mTextDemo;<br><br>  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    setContentView(R.layout.activity_demo);<br>    ButterKnife.bind(<span class="hljs-keyword">this</span>);<br>    mTextDemo.setText(<span class="hljs-string">&quot;Demo&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ButterKnife-原理"><a href="#ButterKnife-原理" class="headerlink" title="ButterKnife 原理"></a>ButterKnife 原理</h3><p>注解编译时生成绑定类，代替我们完成 FindViewById 的操作。</p><p>PS：ButterKnife Github ReadMe 中说明已不推荐使用，推荐下文提到的 Android 官方提供的 <a href="https://developer.android.com/topic/libraries/view-binding">ViewBinding</a></p><h2 id="Data-Binding-Library"><a href="#Data-Binding-Library" class="headerlink" title="Data Binding Library"></a><a href="https://developer.android.google.cn/topic/libraries/data-binding/index.html">Data Binding Library</a></h2><h3 id="Data-Binding-基本使用"><a href="#Data-Binding-基本使用" class="headerlink" title="Data Binding 基本使用"></a>Data Binding 基本使用</h3><p>布局需要使用 &lt;layout&gt; 标签包裹。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    setContentView(R.layout.demo_activity);<br>    ActivityDemoBinding binding = DataBindingUtil.setContentView(<span class="hljs-keyword">this</span>, R.layout.activity_demo);<br>    binding.tvDemo.setText(<span class="hljs-string">&quot;Demo&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Data-Binding-原理"><a href="#Data-Binding-原理" class="headerlink" title="Data Binding 原理"></a>Data Binding 原理</h3><p>自动查找所有 View 并缓存到 binding 实例中以供访问。性能超过手写的 findViewById，因为它只遍历了一遍 XML 布局，而 findViewById 每次都会去遍历 XML 布局；include 布局中的 view 也能同样能访问，并且保留结构。</p><h2 id="Kotlin-Android-Extensions"><a href="#Kotlin-Android-Extensions" class="headerlink" title="Kotlin Android Extensions"></a>Kotlin Android Extensions</h2><p>直接生成对应的 View 作为属性，不需要 findViewById，不需要定义变量，直接使用。使用时需要注意访问的 View 属于哪个 Layout，因为智能提示的候选项会提供所有布局中的 View 供你选择，然后帮你 import 对应包以便你访问这个 View；假如 import 的多个同一层级的 layout 中具有相同的 id，则这个 id 对应的 View 将无法访问。</p><h3 id="Kotlin-Android-Extensions-synthetic-基本使用"><a href="#Kotlin-Android-Extensions-synthetic-基本使用" class="headerlink" title="Kotlin Android Extensions synthetic 基本使用"></a>Kotlin Android Extensions synthetic 基本使用</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-keyword">import</span> kotlinx.android.synthetic.main.activity_demo.*<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() &#123; &#123;<br><br>  <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> void onCreate(Bundle savedInstanceState) &#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    setContentView(R.layout.demo_activity);<br>    tvDemo.setText(<span class="hljs-string">&quot;Demo&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Kotlin-Android-Extensions-synthetic-原理"><a href="#Kotlin-Android-Extensions-synthetic-原理" class="headerlink" title="Kotlin Android Extensions synthetic 原理"></a>Kotlin Android Extensions synthetic 原理</h3><p>Kotlin 会自动生成类似 findViewById() 的方法：findCachedViewById()，在这个方法里面创建一个 HashMap 缓存每次查找到的 View，避免每次调用 View 的属性或方法时都会重新调用 findCachedViewById() 进行查找。</p><p>PS：在 <a href="https://github.com/JetBrains/kotlin/releases/tag/v1.4.20-M2">Kotlin 1.4.20-M2</a> 中，JetBrain s 废弃了 Kotlin Android Extensions 编译插件。推荐使用 ViewBinding。</p><h2 id="推荐使用-ViewBinding"><a href="#推荐使用-ViewBinding" class="headerlink" title="(推荐使用)ViewBinding"></a>(推荐使用)<a href="https://developer.android.com/topic/libraries/view-binding">ViewBinding</a></h2><h3 id="ViewBinding-基本使用"><a href="#ViewBinding-基本使用" class="headerlink" title="ViewBinding 基本使用"></a>ViewBinding 基本使用</h3><p>Android Studio 3.6 Canary 11 及更高版本中可用。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle">android &#123;<br>  ...<br>  viewBinding &#123;<br>      enabled = <span class="hljs-keyword">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() &#123; &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> binding: ActivityDemoBinding<br><br>  <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> void onCreate(Bundle savedInstanceState) &#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    binding = ActivityDemoBinding.inflate(layoutInflater)<br>    setContentView(binding.root)<br>    binding.tvDemo.setText(<span class="hljs-string">&quot;Demo&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ViewBinding-原理"><a href="#ViewBinding-原理" class="headerlink" title="ViewBinding 原理"></a>ViewBinding 原理</h3><h3 id="ViewBinding-优缺点"><a href="#ViewBinding-优缺点" class="headerlink" title="ViewBinding 优缺点"></a>ViewBinding 优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><p>Null 安全：由于视图绑定会创建对视图的直接引用，因此不存在因视图 ID 无效而引发 Null 指针异常的风险。此外，如果视图仅出现在布局的某些配置中，则绑定类中包含其引用的字段会使用 @Nullable 标记。</p></li><li><p>类型安全：每个绑定类中的字段均具有与它们在 XML 文件中引用的视图相匹配的类型。这意味着不存在发生类转换异常的风险。</p></li><li><p>更快的编译速度：视图绑定不需要处理注释，因此编译时间更短。</p></li><li><p>易于使用：视图绑定不需要特别标记的 XML 布局文件，因此在应用中采用速度更快。在模块中启用视图绑定后，它会自动应用于该模块的所有布局。</p></li></ul><h4 id="缺点与限制"><a href="#缺点与限制" class="headerlink" title="缺点与限制"></a>缺点与限制</h4><ul><li>布局和代码之间的不兼容性可能会导致编译版本在编译时（而非运行时）失败。</li><li>视图绑定不支持布局变量或布局表达式，因此不能用于直接在 XML 布局文件中声明动态界面内容。</li><li>视图绑定不支持双向数据绑定。</li></ul><hr><p>相关文章</p><p><a href="https://juejin.im/post/5e69cb55e51d4526d87c8610#heading-4">使用视图绑定替代 findViewById</a><br><a href="https://juejin.im/post/5dd407066fb9a020366f85fa#heading-5">你好, View Binding! 再次再见, findViewById!</a><br><a href="https://juejin.im/entry/5d8caedd518825093a3579b0">Kotlin 干掉了 findViewById，但用不好也会有性能问题</a><br><a href="https://proandroiddev.com/migrating-the-deprecated-kotlin-android-extensions-compiler-plugin-to-viewbinding-d234c691dec7">Migrating the deprecated Kotlin Android Extensions compiler plugin</a><br><a href="https://blog.csdn.net/qq_17766199/article/details/109557820">【译】迁移被废弃的 Kotlin Android Extensions 插件</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>FindViewById</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fragment可见性</title>
    <link href="/post/Fragmnet%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    <url>/post/Fragmnet%E5%8F%AF%E8%A7%81%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fragment</span></span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 当fragment与viewpager、FragmentPagerAdapter一起使用时，切换页面时会调用此方法</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> isVisibleToUser 是否对用户可见</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserVisibleHint</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isVisibleToUser)</span> </span>&#123;<br>            <span class="hljs-keyword">boolean</span> change = isVisibleToUser != getUserVisibleHint();<br>            <span class="hljs-keyword">super</span>.setUserVisibleHint(isVisibleToUser);<br>            <span class="hljs-comment">// 在viewpager中，创建fragment时就会调用这个方法，但这时还没有resume，为了避免重复调用visible和invisible，</span><br>            <span class="hljs-comment">// 只有当fragment状态是resumed并且初始化完毕后才进行visible和invisible的回调</span><br>            <span class="hljs-keyword">if</span> (isResumed() &amp;&amp; change) &#123;<br>                <span class="hljs-keyword">if</span> (getUserVisibleHint()) &#123;<br>                    onVisible();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    onInvisible();<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 当使用show/hide方法时，会触发此回调</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> hidden fragment是否被隐藏</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onHiddenChanged</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> hidden)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.onHiddenChanged(hidden);<br>            <span class="hljs-keyword">if</span> (hidden) &#123;<br>                onInvisible();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                onVisible();<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.onResume();<br>            <span class="hljs-comment">// onResume并不代表fragment可见</span><br>            <span class="hljs-comment">// 如果是在viewpager里，就需要判断getUserVisibleHint，不在viewpager时，getUserVisibleHint默认为true</span><br>            <span class="hljs-comment">// 如果是其它情况，就通过isHidden判断，因为show/hide时会改变isHidden的状态</span><br>            <span class="hljs-comment">// 所以，只有当fragment原来是可见状态时，进入onResume就回调onVisible</span><br>            <span class="hljs-keyword">if</span> (getUserVisibleHint() &amp;&amp; !isHidden()) &#123;<br>                onVisible();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPause</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.onPause();<br>            <span class="hljs-comment">// onPause时也需要判断，如果当前fragment在viewpager中不可见，就已经回调过了，onPause时也就不需要再次回调onInvisible了</span><br>            <span class="hljs-comment">// 所以，只有当fragment是可见状态时进入onPause才加调onInvisible</span><br>            <span class="hljs-keyword">if</span> (getUserVisibleHint() &amp;&amp; !isHidden()) &#123;<br>                onInvisible();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onInvisible</span><span class="hljs-params">()</span> </span>&#123;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onVisible</span><span class="hljs-params">()</span> </span>&#123;<br>            initData();<br>        &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>补充 ：</p><p>setUserVisibleHint 为什么只在 Viewpager 有效？</p><p>实际上查看 setUserVisibleHint 的实际调用方，只有 FragmentPagerAdapter 和 FragmentStatePagerAdapter，也即 ViewPager 的适配器有调用。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fragment</tag>
      
      <tag>可见性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ViewPager下Fragment预加载与懒加载</title>
    <link href="/post/ViewPager%E4%B8%8BFragment%E9%A2%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <url>/post/ViewPager%E4%B8%8BFragment%E9%A2%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>ViewPager 控件有一个预加载机制，即默认情况下当前页面左右两侧的 1 个页面会被预加载，以方便用户滑动切换到相邻的界面时，更流畅地加载界面（节省了初始化时间）。</p><p>从源码里可以看到，ViewPager 的预加载机制是不可取消的，预加载数量 limit 至少为 1，如果外部设置小于 1，内部会自动置为 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewPager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewGroup</span> </span>&#123;<br><br>    <span class="hljs-comment">// 省略其他代码</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOffscreenPageLimit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> limit)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (limit &lt; <span class="hljs-number">1</span>) &#123;<br>            Log.w(<span class="hljs-string">&quot;ViewPager&quot;</span>, <span class="hljs-string">&quot;Requested offscreen page limit &quot;</span> + limit + <span class="hljs-string">&quot; too small; defaulting to &quot;</span> + <span class="hljs-number">1</span>);<br>            limit = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (limit != <span class="hljs-keyword">this</span>.mOffscreenPageLimit) &#123;<br>            <span class="hljs-keyword">this</span>.mOffscreenPageLimit = limit;<br>            <span class="hljs-keyword">this</span>.populate();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>在 ViewPager 预加载的机制下，ViewPager 本身比较难以实现 Fragment 实例化懒加载。既然 Fragment 的实例化难以懒加载，那么退而求其次，只要求实现 Fragment 请求数据的懒加载。</p><p>我们需要从 Fragment 本身入手。</p><p>主要用到 Fragment 两个方法：</p><ul><li>public void onViewCreated(View view, @Nullable Bundle savedInstanceState)</li><li>public void setUserVisibleHint(boolean isVisibleToUser)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseFragment</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> isViewCreated;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> isVisibleToUser;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> isDataInitiated;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewCreated</span><span class="hljs-params">(View view, <span class="hljs-meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onViewCreated(view, savedInstanceState);<br>        isViewCreated = <span class="hljs-keyword">true</span>;<br>        lazyLoad();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserVisibleHint</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isVisibleToUser)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.setUserVisibleHint(isVisibleToUser);<br>        <span class="hljs-keyword">this</span>.isVisibleToUser = isVisibleToUser;<br>        <span class="hljs-keyword">if</span> (isVisibleToUser) &#123;<br>            lazyLoad();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lazyLoad</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> lazyLoad(<span class="hljs-keyword">false</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lazyLoad</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> forceRefresh)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (isVisibleToUser &amp;&amp; isViewCreated &amp;&amp; (!isDataInitiated || forceRefresh)) &#123;<br>            fetchData();<br>            isDataInitiated = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fetchData</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fragment</tag>
      
      <tag>ViewPager</tag>
      
      <tag>预加载</tag>
      
      <tag>懒加载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录一次Android7.0适配FileProvider踩坑</title>
    <link href="/post/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1Android7.0%E9%80%82%E9%85%8DFileProvider%E8%B8%A9%E5%9D%91/"/>
    <url>/post/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1Android7.0%E9%80%82%E9%85%8DFileProvider%E8%B8%A9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<ul><li>FileProvider 重复</li></ul><p>自定义 FileProvider 继承 FileProvider。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleFileProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FileProvider</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>AndroidManifest.xml 中 application 节点下添加 provider 节点。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">provider</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.XXX.XXX.sample.AppleFileProvider&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;$&#123;applicationId&#125;.file.provider&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:grantUriPermissions</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:resource</span>=<span class="hljs-string">&quot;@xml/apple_file_provider&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>多个 FileProvider authorities 重复</li></ul><p>authorities 一般是由包名+自定义的标识构成。</p><p>Uri uri = FileProvider.getUriForFile(getContext(), context.getPackageName() + “.file.provider”, file);</p><p>例子：</p><p>AppleFileProvider 和 BoyFileProvider 的 authorities 重复了，都为${applicationId}.file.provider。<br>默认会取 apk 中合并后的 AndroidManifest.xml 的第一个 authorities 匹配的 FileProvider。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">provider</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.XXX.XXX.sample.AppleFileProvider&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;$&#123;applicationId&#125;.file.provider&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:grantUriPermissions</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:resource</span>=<span class="hljs-string">&quot;@xml/apple_file_provider&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">provider</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.XXX.XXX.sample.BoyFileProvider&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;$&#123;applicationId&#125;.file.provider&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:grantUriPermissions</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:resource</span>=<span class="hljs-string">&quot;@xml/boy_file_provider&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此时 Uri uri = FileProvider.getUriForFile(getContext(), context.getPackageName() + “.file.provider”, file);会与 AppleFileProvider 匹配，也就会去取 apple_file_provider.xml 中的配置。<br>如果 AppleFileProvider 与 BoyFileProvider 在 AndroidManifest 的顺序互换一下，那么就会与 BoyFileProvider 匹配，也就会去取 boy_file_provider.xml 中的配置。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>FileProvider</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简析LeakCanary</title>
    <link href="/post/%E7%AE%80%E6%9E%90LeakCanary/"/>
    <url>/post/%E7%AE%80%E6%9E%90LeakCanary/</url>
    
    <content type="html"><![CDATA[<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>添加依赖（release 有 no-op 版）然后在 Application 初始化。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">dependencies</span> &#123;<br>  debugImplementation <span class="hljs-string">&#x27;com.squareup.leakcanary:leakcanary-android:1.X&#x27;</span><br>  releaseImplementation <span class="hljs-string">&#x27;com.squareup.leakcanary:leakcanary-android-no-op:1.X&#x27;</span><br>  <span class="hljs-comment">// Optional, if you use support library fragments:</span><br>  debugImplementation <span class="hljs-string">&#x27;com.squareup.leakcanary:leakcanary-support-fragment:1.X&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onCreate();<br>    <span class="hljs-keyword">if</span> (LeakCanary.isInAnalyzerProcess(<span class="hljs-keyword">this</span>)) &#123;<br>        <span class="hljs-comment">// This process is dedicated to LeakCanary for heap analysis.</span><br>        <span class="hljs-comment">// You should not init your app in this process.</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    LeakCanary.install(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-comment">// Normal app init code...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h3><p>Activity：</p><p>application.registerActivityLifecycleCallbacks 覆写 onActivityDestroyed</p><p>watch（）使用 WeakReference + ReferenceQueue 监听对象回收情况</p><p>watchedObjects（LinkedHashMap&lt;key, KeyedWeakReference&gt;） watch() 方法传进来的引用，尚未判定为泄露<br>queue（ReferenceQueue） 怀疑泄漏的对象列表</p><p>以 UUID.randomUUID().toString() 为 key 构造 KeyedWeakReference（关联 ReferenceQueue） 存入 watchedObjects。</p><p><strong><em>弱引用一旦变得弱可达，就会立即入队 ReferenceQueue。这将在 finalization 或者 GC 之前发生。</em></strong></p><p>watch 方法最后会调用 moveToRetained（）</p><h3 id="Dump"><a href="#Dump" class="headerlink" title="Dump"></a>Dump</h3><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>计算了到 GC Roots 的最短强引用路径。</p><h2 id="2-0-版本"><a href="#2-0-版本" class="headerlink" title="2.0 版本"></a>2.0 版本</h2><h3 id="不需要在-Application-初始化"><a href="#不需要在-Application-初始化" class="headerlink" title="不需要在 Application 初始化"></a>不需要在 Application 初始化</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">dependencies</span> &#123;<br>  debugImplementation <span class="hljs-string">&#x27;com.squareup.leakcanary:leakcanary-android:2.X&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ContentProvider-实现"><a href="#ContentProvider-实现" class="headerlink" title="ContentProvider 实现"></a>ContentProvider 实现</h4><p>leakcanary-android-process 模块的 AndroidManifest.xml 文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;com.squareup.leakcanary&quot;</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">application</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">service</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;leakcanary.internal.HeapAnalyzerService&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:process</span>=<span class="hljs-string">&quot;:leakcanary&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">provider</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;leakcanary.internal.AppWatcherInstaller$LeakCanaryProcess&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;$&#123;applicationId&#125;.leakcanary-process.installer&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:process</span>=<span class="hljs-string">&quot;:leakcanary&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><p>看看 AppWatcherInstaller 干了啥：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppWatcherInstaller</span> : <span class="hljs-type">ContentProvider</span></span>() &#123;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * [MainProcess] automatically sets up the LeakCanary code that runs in the main app process.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainProcess</span> : <span class="hljs-type">AppWatcherInstaller</span></span>()<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * When using the `leakcanary-android-process` artifact instead of `leakcanary-android`,</span><br><span class="hljs-comment">   * [LeakCanaryProcess] automatically sets up the LeakCanary code</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeakCanaryProcess</span> : <span class="hljs-type">AppWatcherInstaller</span></span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>      <span class="hljs-keyword">super</span>.onCreate()<br>      AppWatcher.config = AppWatcher.config.copy(enabled = <span class="hljs-literal">false</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;<br><br>   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">val</span> application = context!!.applicationContext <span class="hljs-keyword">as</span> Application<br>    InternalAppWatcher.install(application)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用加载顺序实现自动注入：</p><p>Application-&gt;attachBaseContext =====&gt; ContentProvider-&gt;onCreate =====&gt; Application-&gt;onCreate =====&gt; Activity-&gt;onCreate</p><p>优点：实现”免侵入”集成，不需要手动初始化。<br>缺点：无法更改初始化时机（App 启动优化按需延迟初始化第三方库对这样的集成方式就无能为力了）。考虑到 LeakCanary 是开发 debug 阶段使用的，也无可厚非。一般的 SDK 还是不建议使用这种方式。</p><h3 id="添加默认对-Fragment-的支持"><a href="#添加默认对-Fragment-的支持" class="headerlink" title="添加默认对 Fragment 的支持"></a>添加默认对 Fragment 的支持</h3><p>Fragment：</p><p>Android O 版本 androidx 都具备对 Fragment 生命周期的监听功能。</p><p>application.registerActivityLifecycleCallbacks 覆写 onActivityCreated<br>然后 fragmentManager.registerFragmentLifecycleCallbacks 覆写 onFragmentViewDestroyed() onFragmentDestroyed()</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>LeakCanary</tag>
      
      <tag>内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简析OkHttp</title>
    <link href="/post/%E7%AE%80%E6%9E%90OkHttp/"/>
    <url>/post/%E7%AE%80%E6%9E%90OkHttp/</url>
    
    <content type="html"><![CDATA[<p>是对 Socket 的封装。URLConnection 在 4.4 以后底层也使用了 OkHttp。</p><p>Android 源码中 /external/okhttp/jarjar-rules.txt 中表示 com.squareup 开关的包会在编译时打包成 com.android 开头的包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">rule com.squareup.** com.android.@1<br>rule okio.** com.android.okio.@1<br></code></pre></td></tr></table></figure><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">String url = <span class="hljs-string">&quot;http://www.xxx.com&quot;</span>;<br><span class="hljs-comment">//  生成 OkHttpClient 实例对象</span><br>OkHttpClient okHttpClient = <span class="hljs-keyword">new</span> OkHttpClient();<br><span class="hljs-comment">//  生成 Request 对象</span><br>Request request = <span class="hljs-keyword">new</span> Request.Builder()<br>    .url(url)<br>    .post(RequestBody.create(MediaType.parse(<span class="hljs-string">&quot;application/json; charset=utf-8&quot;</span>),<span class="hljs-string">&quot;test content&quot;</span>))<br>    .build();<br><span class="hljs-comment">//  生成 Call 对象</span><br>Call call = okHttpClient.newCall(request);<br><br>call.enqueue(<span class="hljs-keyword">new</span> Callback() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Call call, <span class="hljs-meta">@NonNull</span> IOException e)</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Call call, <span class="hljs-meta">@NonNull</span> Response response)</span>  </span>&#123;<br><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li><p>创建请求对象。 (url, method, headers, body, tags)–&gt; Request–&gt; Call</p></li><li><p>线程池分发请求。同步使用 call.excute(),异步使用 call.enqueue()请求事件队列, 都交给 Dispatcher 分发， enqueue–&gt;Runnable–&gt;ThreadPoolExecutor</p></li><li><p>递归 Interceptor 拦截器，发送请求。 getResponseWithInterceptorChain()，InterceptorChain</p></li><li><p>请求回调，数据解析。 Respose –&gt; (code,message,requestBody)</p></li></ol><p>不管是异步还是同步，都是一样的三部曲:</p><ol><li>加入到 Dispatche r 里面的同步(或异步)队列。</li><li>执行 getResponseWithInterceptorChain 方法。（只不过同步操作是直接运行了 getResponseWithInterceptorChain 方法，而异步是通过线程池执行 R unnabl e 再去执行 getResponseWithInterceptorChain 方法）</li><li>从 Dispatcher 里面的同步(或异步)队列移除。</li></ol><p>Dispatcher 内部维护 3 个队列及 1 个线程池:</p><ul><li>readyAsyncCalls</li></ul><p>待访问请求队列，里面存储准备执行的请求。</p><ul><li>runningSyncCalls</li></ul><p>同步请求队列，正在执行的请求，包含已经取消但是还没有结束的请求。</p><ul><li>runningAsyncCalls</li></ul><p>异步请求队列，里面存储正在执行，包含已经取消但是还没有结束的请求。</p><ul><li>ExecutorService</li></ul><p>线程池，最小 0，最大 Max 的线程池。</p><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h3><p>重试与重定向拦截器。</p><p>通过 while (true) 的死循环来进行对异常结果或者响应结果判断是否要进行重新请求。</p><h3 id="BirdgeInterceptor"><a href="#BirdgeInterceptor" class="headerlink" title="BirdgeInterceptor"></a>BirdgeInterceptor</h3><p>桥接拦截器。</p><p>为用户构建的一个 Request 请求转化为能够进行网络访问的请求，同时将网络请求回来的响应 Response 转化为用户可用的 Response。初始化信息，添加请求头等，比如涉及的网络文件的类型和网页的编码，返回的数据的解压处理等等。</p><h3 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h3><p>缓存拦截器。</p><p>根据 OkHttpClient 对象的配置以及缓存策略对请求值进行缓存。</p><p>内部有 Cache 类，处理缓存操作，intercache 内部类，disklrucache 算法等<br>重点是不缓存非 get 的请求。<br>CacheStrategy 缓存策略类，通过工厂模式获取。</p><h3 id="ConnectionInterceptor"><a href="#ConnectionInterceptor" class="headerlink" title="ConnectionInterceptor"></a>ConnectionInterceptor</h3><p>网络连接拦截器。</p><p>底层是通过 SOCKET 的方式于服务端进行连接的，并且在连接建立之后会通过 OKIO 获取通向 server 端的输入流 Source 和输出流 Sink。</p><h3 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h3><p>服务请求的拦截器。</p><p>负责与服务器建立 Socket 连接，并且创建了一个 HttpStream 它包括通向服务器的输入流和输出流。</p><h3 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h3><h4 id="Application-Interceptor"><a href="#Application-Interceptor" class="headerlink" title="Application Interceptor"></a>Application Interceptor</h4><p>在 retryAndFollowUpInterceptor 之前，处于拦截器第一个位置。</p><p>它是第一个触发拦截的，这里拦截到的 url 请求的信息都是最原始的信息。所以我们可以在该拦截器中添加一些我们请求中需要的通用信息，打印一些我们需要的日志。可以定义多个这样的拦截器，例如一个处理 header 信息，一个处理 接口请求的 加解密 。</p><h4 id="NetwrokInterceptor"><a href="#NetwrokInterceptor" class="headerlink" title="NetwrokInterceptor"></a>NetwrokInterceptor</h4><p>在 ConnectInterceptor 和 CallServerInterceptor 之间，处于拦截器倒数第二个位置。</p><p>会经过 RetryAndFollowIntercptor 进行重定向并且也会通过 BridgeInterceptor 进行 request 请求头和 响应 resposne 的处理，因此这里可以得到的是更多的信息。在打印结果可以看到它内部重定向操作和失败重试，这里会有比 Application Interceptor 更多的日志。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>OkHttp</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简析Glide</title>
    <link href="/post/%E7%AE%80%E6%9E%90Glide/"/>
    <url>/post/%E7%AE%80%E6%9E%90Glide/</url>
    
    <content type="html"><![CDATA[<p>最简洁的图片加载流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Glide.with(context)<br>    .load(myUrl)<br>    .into(imageView);<br></code></pre></td></tr></table></figure><ol><li>with 传递图片加载上下文，获取图片加载请求管理器（RequestManager）。</li><li>load 传递图片加载数据源，构建图片加载请求建造器（RequestBuilder）。</li><li>into 传递图片加载目标载体，创建图片加载请求（Request），执行图片加载。</li></ol><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>with 支持传递 Context，Activity，Fragment，Glide 4.0.0 版本后 with 还支持传递 View。</p><ol><li>如果是子线程，会使用 ApplicationContext。</li><li>传递 Context 如果是 ContextWrapper 直接会优先向上遍历得到 Activity。</li><li>传递 View ，会优先向上遍历得到 Activity，然后根据得到的 Activity 优先遍历得到 Fragment。</li></ol><h3 id="传入-ApplicationContext"><a href="#传入-ApplicationContext" class="headerlink" title="传入 ApplicationContext"></a>传入 ApplicationContext</h3><p>Application 对象的生命周期即应用程序的生命周期，因此 Glide 并不需要做什么特殊的处理，它自动就是和应用程序的生命周期是同步的。</p><h3 id="传入非-ApplicationContext"><a href="#传入非-ApplicationContext" class="headerlink" title="传入非 ApplicationContext"></a>传入非 ApplicationContext</h3><p>无视图的 Fragment 接管 LifeCycle。</p><h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><h3 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h3><ol><li>根据图片地址，宽高，变换，签名等生成 key。</li><li>根据 key 从活动缓存取图片资源。取到则完成；取不到进行下一步。</li><li>根据 key 从内存缓存（LRU 实现）。取到则将取到的图片资源添加到活动缓存，完成；取不到进行下一步。</li><li>返回 null，表示未取到。</li></ol><ul><li><p>LRU 缓存。LruCache 算法（Least Recently Used），也叫近期最少使用算法。算法原理就是把最近使用的对象用强引用存储在 LinkedHashMap 中，并且把最近最少使用的对象在缓存值达到预设定值之前从内存中移除。</p></li><li><p>活跃缓存。弱引用缓存正在使用的图片，可以保护这些图片不会被 LruCache 算法回收掉。</p></li></ul><p>缓存写入时机：</p><ul><li>图片资源执行完加载解码后，写入活跃缓存。</li><li>图片资源回收且引用数为 0，先从活跃缓存中删除，后写入 LRU 缓存。</li></ul><h3 id="硬盘缓存"><a href="#硬盘缓存" class="headerlink" title="硬盘缓存"></a>硬盘缓存</h3><p>DiskCacheStrategy.NONE： 表示不缓存任何内容。<br>DiskCacheStrategy.SOURCE： 表示只缓存原始图片。<br>DiskCacheStrategy.RESULT： 表示只缓存转换过后的图片（默认选项）。<br>DiskCacheStrategy.ALL ： 表示既缓存原始图片，也缓存转换过后的图片。</p><p>DiskLruCache，journal 文件。</p><p>journal 文件组成：</p><ul><li>libcore.io.DiskLruCache （魔法值，标志着使用 DiskLruCache 技术）</li><li>DiskLruCache 版本号</li><li>应用版本号</li><li>DIRTY 数据行（正在写数据）</li><li>CLEAN 数据行（写入数据成功）</li><li>REMOVE 数据行（写入数据失败）</li><li>READ 数据行（读取数据）</li></ul><h2 id="Bitmap-采样和复用机制"><a href="#Bitmap-采样和复用机制" class="headerlink" title="Bitmap 采样和复用机制"></a>Bitmap 采样和复用机制</h2><h3 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h3><ol><li>计算缩放因子</li><li>获取采样类型 内存优先（比要求的尺寸小）/ 质量优先（比要求的尺寸大）</li><li>计算整型的缩放因子</li><li>将整型的缩放因子转成 2 的幂</li></ol><h3 id="复用机制"><a href="#复用机制" class="headerlink" title="复用机制"></a>复用机制</h3><p>BitmapPool，默认具体实现 LruBitmapPool。</p><p>不光对开销较大的 Bitmap 进行了复用，就连为了复用 Bitmap 时重复申请的 Key 对象都进行了复用，尽可能的减少了对象的创建开销，保证了应用的流畅性。</p><h4 id="复用的前提"><a href="#复用的前提" class="headerlink" title="复用的前提"></a>复用的前提</h4><p>inMutable = true<br>inBitmap 指定复用的 Bitmap</p><p>在 Android 4.4 之前，仅支持相同大小的 bitmap，inSampleSize 必须为 1，而且必须采用 jpeg 或 png 格式。</p><p>在 Android 4.4 之后只有一个限制，就是被复用的 bitmap 尺寸要大于新的 bitmap，简单来说就是大图可以给小图复用。</p><h4 id="复用实现"><a href="#复用实现" class="headerlink" title="复用实现"></a>复用实现</h4><p>根据特定的缓存策略，根据系统版本如判断采用完全匹配或者大小匹配，从缓存池获取到 Dirty 的 Bitmap，使用 reconfigure 和 eraseColor(Color.TRANSPARENT) 来 clean 这个 Bitmap。</p><ol><li>加入复用池时机：外部加载完或者回收调用放入</li><li>获取缓存时机：加载图片前</li><li>删除，每次操作都会判断是否需要删除多余的缓存</li></ol><h2 id="线程池管理"><a href="#线程池管理" class="headerlink" title="线程池管理"></a>线程池管理</h2><ul><li>diskCacheExecutor 本地缓存任务 newDiskCacheBuilder corePoolSize=maximumPoolSize=1</li><li>sourceExecutor 资源获取任务 corePoolSize=maximumPoolSize=处理器数量和固定值 4 之间区最小</li><li>sourceUnlimitedExecutor 资源获取不限制任务 corePoolSize=0 maximumPoolSize=Integer.MAX_VALUE 10ms 超时 SynchronousQueue</li><li>animationExecutor Gif 加载任务 corePoolSize=在处理器数量和固定值 4 之间区最小 maximumPoolSize=1 或 2</li></ul><p>除了 sourceUnlimitedExecutor 都使用了 PriorityBlockingQueue 来作为等待队列。</p><h2 id="使用自定义模块解耦"><a href="#使用自定义模块解耦" class="headerlink" title="使用自定义模块解耦"></a>使用自定义模块解耦</h2><ul><li><p>setMemoryCache()<br>用于配置 Glide 的内存缓存策略，默认配置是 LruResourceCache。</p></li><li><p>setBitmapPool()<br>用于配置 Glide 的 Bitmap 缓存池，默认配置是 LruBitmapPool。</p></li><li><p>setDiskCache()<br>用于配置 Glide 的硬盘缓存策略，默认配置是 InternalCacheDiskCacheFactory。</p></li><li><p>setDiskCacheService()<br>用于配置 Glide 读取缓存中图片的异步执行器，默认配置是 FifoPriorityThreadPoolExecutor，也就是先入先出原则。</p></li><li><p>setResizeService()<br>用于配置 Glide 读取非缓存中图片的异步执行器，默认配置也是 FifoPriorityThreadPoolExecutor。</p></li><li><p>setDecodeFormat()<br>用于配置 Glide 加载图片的解码模式，默认配置是 RGB_565。</p></li></ul><p>Glide 3:</p><ol><li>自定义模块类，实现 GlideModule 。</li><li>AndroidManifest.xml 中配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span>&gt;</span><br><br>    ...<br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">application</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.example.glidetest.MyGlideModule&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:value</span>=<span class="hljs-string">&quot;GlideModule&quot;</span> /&gt;</span><br><br>        ...<br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><p>解析 AndroidManifest.xml 中 value 为 GlideModule 的 meta-data ,反射实例化自定义模块类。Glide 在实例化的时候会先遍历模块列表应用配置。</p><p>Glide 4:</p><ol><li>自定义模块类，继承 AppGlideModule 。</li><li>自定义模块类上添加 @GlideModule 注解。</li></ol><p>注解处理器 auto-service + JavaPoet</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>图片</tag>
      
      <tag>Glide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简析Bitmap</title>
    <link href="/post/%E7%AE%80%E6%9E%90Bitmap/"/>
    <url>/post/%E7%AE%80%E6%9E%90Bitmap/</url>
    
    <content type="html"><![CDATA[<p>基于 9.0（29）简析 Bitmap 类。</p><p>我们只关注 Bitmap 类暴露出来的（即访问权限为 public）东西。</p><ul><li>枚举类 Config</li><li>枚举类 CompressFormat</li><li>若干 createBitmap 静态方法</li><li>其他方法</li></ul><h2 id="枚举类-Config"><a href="#枚举类-Config" class="headerlink" title="枚举类 Config"></a>枚举类 Config</h2><p>可能的 bitmap 配置。bitmap 配置描述像素的存储方式。这会影响质量（颜色深度）以及显示透明/半透明颜色的能力。</p><table><thead><tr><th>Config</th><th>每个像素占用字节数</th><th>表示颜色种数</th><th>说明</th></tr></thead><tbody><tr><td>ALPHA_8</td><td>1 个字节，A 分量占 8 位，不存储颜色信息</td><td>0</td><td>单透明通道</td></tr><tr><td>RGB_565</td><td>两个字节，R 分量占 5 位，G 分量占 6 位，B 分量占 5 位</td><td>2^16(65536)</td><td>简易 RGB 色调</td></tr><tr><td>RGB_888</td><td>三个字节，R、G、B 分量各占 8 位</td><td>2^24(16777216)</td><td>RGB 色调</td></tr><tr><td>ARGB_4444</td><td>两个字节，A、R、G、B 分量各占 4 位</td><td>2^12(4096)</td><td>已弃用，成像效果比较差，并且 v4.4+后如果使用了它会自动转成用 ARGB_8888。</td></tr><tr><td>ARGB_8888</td><td>四个字节，A、R、G、B 分量各占 8 位</td><td>2^24(16777216)</td><td>24 位真彩色，Android 中默认的配置</td></tr><tr><td>RGBA_F16</td><td>八个字节，A、R、G、B 分量各占 16 位</td><td>2^48(281474976710656)</td><td>特别适合于宽色域和 HDR 内容，在 8.0（api 26）引入。</td></tr><tr><td>HARDWARE</td><td>-</td><td>-</td><td>特殊配置。bitmap 始终存储在图形内存中，在 8.0（api 26）引入。</td></tr></tbody></table><h2 id="枚举类-CompressFormat"><a href="#枚举类-CompressFormat" class="headerlink" title="枚举类 CompressFormat"></a>枚举类 CompressFormat</h2><p>指定可以将 bitmap 压缩为的已知格式。</p><ul><li>JPEG</li><li>PNG</li><li>WEBP</li></ul><h2 id="若干-createBitmap-静态方法"><a href="#若干-createBitmap-静态方法" class="headerlink" title="若干 createBitmap 静态方法"></a>若干 createBitmap 静态方法</h2><h3 id="public-static-Bitmap-wrapHardwareBuffer-NonNull-HardwareBuffer-hardwareBuffer-Nullable-ColorSpace-colorSpace"><a href="#public-static-Bitmap-wrapHardwareBuffer-NonNull-HardwareBuffer-hardwareBuffer-Nullable-ColorSpace-colorSpace" class="headerlink" title="public static Bitmap wrapHardwareBuffer(@NonNull HardwareBuffer hardwareBuffer, @Nullable ColorSpace colorSpace)"></a>public static Bitmap wrapHardwareBuffer(@NonNull HardwareBuffer hardwareBuffer, @Nullable ColorSpace colorSpace)</h3><p>创建由 HardwareBuffer 支持的硬件位图。</p><p>传递的 HardwareBuffer 使用标志必须包含 HardwareBuffer.USAGE_GPU_SAMPLED_IMAGE。</p><p>bitmap 将保留对缓冲区的引用，以便调用者可以安全地关闭 HardwareBuffer 而不会影响 bitmap 。但是，在包装 bitmap 访问硬件缓冲区时，不能对其进行修改。这样做将导致不确定的行为。</p><ul><li>HardwareBuffer hardwareBuffer：包装的 HardwareBuffer。</li><li>ColorSpace colorSpace：bitmap 的颜色空间。必须是 ColorSpace.Rgb 颜色空间。如果为 null ，则假定为 SRGB。</li></ul><h3 id="public-static-Bitmap-createScaledBitmap-NonNull-Bitmap-src-int-dstWidth-int-dstHeight-boolean-filter"><a href="#public-static-Bitmap-createScaledBitmap-NonNull-Bitmap-src-int-dstWidth-int-dstHeight-boolean-filter" class="headerlink" title="public static Bitmap createScaledBitmap(@NonNull Bitmap src, int dstWidth, int dstHeight, boolean filter)"></a>public static Bitmap createScaledBitmap(@NonNull Bitmap src, int dstWidth, int dstHeight, boolean filter)</h3><p>如果可能，创建一个新的 bitmap ，从现有的 bitmap 缩放。如果指定的宽度和高度与源位图的当前宽度和高度相同，则返回源位图，并且不创建新的位图。</p><ul><li>Bitmap src：源 bitmap。</li><li>int dstWidth：新 bitmap 的所需宽度</li><li>int dstHeight：新 bitmap 的所需高度</li><li>boolean filter：缩放 bitmap 时是否使用双线性滤波。如果为 true ，则在缩放时将使用双线性滤波，从而以较差的性能为代价来获得更好的图像质量。如果为 false ，则使用邻近采样缩放，这将使图像质量较差，但速度更快。推荐的默认值是将设置为 true，因为双线性滤镜的成本通常很小，并且改善的图像质量非常重要。</li></ul><h3 id="public-static-Bitmap-createBitmap-NonNull-Bitmap-src"><a href="#public-static-Bitmap-createBitmap-NonNull-Bitmap-src" class="headerlink" title="public static Bitmap createBitmap(@NonNull Bitmap src)"></a>public static Bitmap createBitmap(@NonNull Bitmap src)</h3><p>重载 Bitmap createBitmap(@NonNull Bitmap source, int x, int y, int width, int height)</p><p>createBitmap(src, 0, 0, src.getWidth(), src.getHeight());</p><h3 id="public-static-Bitmap-createBitmap-NonNull-Bitmap-source-int-x-int-y-int-width-int-height"><a href="#public-static-Bitmap-createBitmap-NonNull-Bitmap-source-int-x-int-y-int-width-int-height" class="headerlink" title="public static Bitmap createBitmap(@NonNull Bitmap source, int x, int y, int width, int height)"></a>public static Bitmap createBitmap(@NonNull Bitmap source, int x, int y, int width, int height)</h3><p>重载 Bitmap createBitmap(@NonNull Bitmap source, int x, int y, int width, int height, @Nullable Matrix m, boolean filter)</p><p>createBitmap(source, x, y, width, height, null, false);</p><h3 id="public-static-Bitmap-createBitmap-NonNull-Bitmap-source-int-x-int-y-int-width-int-height-Nullable-Matrix-m-boolean-filter"><a href="#public-static-Bitmap-createBitmap-NonNull-Bitmap-source-int-x-int-y-int-width-int-height-Nullable-Matrix-m-boolean-filter" class="headerlink" title="public static Bitmap createBitmap(@NonNull Bitmap source, int x, int y, int width, int height, @Nullable Matrix m, boolean filter)"></a>public static Bitmap createBitmap(@NonNull Bitmap source, int x, int y, int width, int height, @Nullable Matrix m, boolean filter)</h3><p>从源 bitmap 返回一个 bitmap 。新的 bitmap 可能与源 bitmap 是同一对象，或者可能已复制。使用与源 bitmap 相同的密度和色彩空间进行初始化。</p><p>如果源 bitmap 是不可变的，并且所请求的子集与源 bitmsp 本身相同，则返回源 bitmap ，并且不会创建新 bitmap 。</p><p>除非在以下情况下，否则返回的 bitmap 将始终是可变的：<br>（1）在返回源 bitmap 且源 bitmap 不可变的情况下<br>（2）源 bitmap 是硬件 bitmap 。即 getConfig() = Config.HARDWARE 。</p><ul><li>Bitmap source：源 bitmap 。</li><li>int x：源中第一个像素的 x 坐标</li><li>int y：源中第一个像素的 y 坐标</li><li>int width：每行像素数</li><li>int height：行数</li><li>Matrix m：应用于像素的可选矩阵</li><li>boolean filter：是否使用双线性滤波，则为 true。仅在矩阵包含的不仅仅是平移时适用。</li></ul><h3 id="public-static-Bitmap-createBitmap-int-width-int-height-NonNull-Config-config"><a href="#public-static-Bitmap-createBitmap-int-width-int-height-NonNull-Config-config" class="headerlink" title="public static Bitmap createBitmap(int width, int height, @NonNull Config config)"></a>public static Bitmap createBitmap(int width, int height, @NonNull Config config)</h3><p>重载 Bitmap createBitmap(int width, int height, @NonNull Config config, boolean hasAlpha)</p><p>createBitmap(null, width, height, config, hasAlpha)</p><h3 id="public-static-Bitmap-createBitmap-Nullable-DisplayMetrics-display-int-width-int-height-NonNull-Config-config"><a href="#public-static-Bitmap-createBitmap-Nullable-DisplayMetrics-display-int-width-int-height-NonNull-Config-config" class="headerlink" title="public static Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config)"></a>public static Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config)</h3><p>重载 Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config, boolean hasAlpha)</p><p>createBitmap(display, width, height, config, true);</p><h3 id="public-static-Bitmap-createBitmap-int-width-int-height-NonNull-Config-config-boolean-hasAlpha"><a href="#public-static-Bitmap-createBitmap-int-width-int-height-NonNull-Config-config-boolean-hasAlpha" class="headerlink" title="public static Bitmap createBitmap(int width, int height, @NonNull Config config, boolean hasAlpha)"></a>public static Bitmap createBitmap(int width, int height, @NonNull Config config, boolean hasAlpha)</h3><p>重载 Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config, boolean hasAlpha)</p><p>createBitmap(null, width, height, config, hasAlpha);</p><h3 id="public-static-Bitmap-createBitmap-int-width-int-height-NonNull-Config-config-boolean-hasAlpha-NonNull-ColorSpace-colorSpace"><a href="#public-static-Bitmap-createBitmap-int-width-int-height-NonNull-Config-config-boolean-hasAlpha-NonNull-ColorSpace-colorSpace" class="headerlink" title="public static Bitmap createBitmap(int width, int height, @NonNull Config config, boolean hasAlpha, @NonNull ColorSpace colorSpace)"></a>public static Bitmap createBitmap(int width, int height, @NonNull Config config, boolean hasAlpha, @NonNull ColorSpace colorSpace)</h3><p>重载 Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config, boolean hasAlpha, @NonNull ColorSpace colorSpace)</p><p>createBitmap(null, width, height, config, hasAlpha, colorSpace);</p><h3 id="public-static-Bitmap-createBitmap-Nullable-DisplayMetrics-display-int-width-int-height-NonNull-Config-config-boolean-hasAlpha"><a href="#public-static-Bitmap-createBitmap-Nullable-DisplayMetrics-display-int-width-int-height-NonNull-Config-config-boolean-hasAlpha" class="headerlink" title="public static Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config, boolean hasAlpha)"></a>public static Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config, boolean hasAlpha)</h3><p>重载 Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config, boolean hasAlpha, @NonNull ColorSpace colorSpace)</p><p>createBitmap(display, width, height, config, hasAlpha, ColorSpace.get(ColorSpace.Named.SRGB));</p><h3 id="public-static-Bitmap-createBitmap-Nullable-DisplayMetrics-display-int-width-int-height-NonNull-Config-config-boolean-hasAlpha-NonNull-ColorSpace-colorSpace"><a href="#public-static-Bitmap-createBitmap-Nullable-DisplayMetrics-display-int-width-int-height-NonNull-Config-config-boolean-hasAlpha-NonNull-ColorSpace-colorSpace" class="headerlink" title="public static Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config, boolean hasAlpha, @NonNull ColorSpace colorSpace)"></a>public static Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config, boolean hasAlpha, @NonNull ColorSpace colorSpace)</h3><p>返回具有指定宽度和高度的可变 bitmap。它的初始密度由给定的 DisplayMetrics 确定。新创建的 bitmap 位于 ColorSpace.Named.SRGB 颜色空间中。</p><ul><li>DisplayMetrics display：将被绘制的 bitmap 的显示的显示度量。</li><li>int width：bitmap 的宽度。</li><li>int height：bitmap 的高度。</li><li>Config config：创建的 bitmap 的配置。</li><li>boolean hasAlpha：如果 bitmap 是 ARGB_8888 或 RGBA_16F ，则此标志可用于将 bitmap 标记为不透明。这样做将以黑色而不是透明的方式清除 bitmap。</li><li>ColorSpace colorSpace：bitmap 的颜色空间。如果配置为 Config.RGBA_F16 和 ColorSpace.Named.SRGB sRGB 或 ColorSpace.Named.LINEAR_SRGB ，则假定为相应的扩展范围变体。</li></ul><h3 id="public-static-Bitmap-createBitmap-NonNull-ColorInt-int-colors-int-offset-int-stride-int-width-int-height-NonNull-Config-config"><a href="#public-static-Bitmap-createBitmap-NonNull-ColorInt-int-colors-int-offset-int-stride-int-width-int-height-NonNull-Config-config" class="headerlink" title="public static Bitmap createBitmap(@NonNull @ColorInt int[] colors, int offset, int stride, int width, int height, @NonNull Config config)"></a>public static Bitmap createBitmap(@NonNull @ColorInt int[] colors, int offset, int stride, int width, int height, @NonNull Config config)</h3><p>重载 Bitmap createBitmap(@NonNull DisplayMetrics display, @NonNull @ColorInt int[] colors, int offset, int stride, int width, int height, @NonNull Config config)</p><p>createBitmap(null, colors, offset, stride, width, height, config)</p><h3 id="public-static-Bitmap-createBitmap-NonNull-DisplayMetrics-display-NonNull-ColorInt-int-colors-int-offset-int-stride-int-width-int-height-NonNull-Config-config"><a href="#public-static-Bitmap-createBitmap-NonNull-DisplayMetrics-display-NonNull-ColorInt-int-colors-int-offset-int-stride-int-width-int-height-NonNull-Config-config" class="headerlink" title="public static Bitmap createBitmap(@NonNull DisplayMetrics display, @NonNull @ColorInt int[] colors, int offset, int stride, int width, int height, @NonNull Config config)"></a>public static Bitmap createBitmap(@NonNull DisplayMetrics display, @NonNull @ColorInt int[] colors, int offset, int stride, int width, int height, @NonNull Config config)</h3><p>返回具有指定宽度和高度的不可变 bitmap，每个像素值设置为 colors 数组中的相应值。它的初始密度由给定的 DisplayMetrics 确定。新创建的 bitmap 位于 ColorSpace.Named.SRGB 颜色空间中。</p><ul><li>DisplayMetrics display：将被绘制的 bitmap 的显示的显示度量。</li><li>@ColorInt int[] colors：sRGB Color 数组，用于初始化像素。</li><li>int offset：颜色数组中第一个颜色之前要跳过的值数。</li><li>int stride：行之间数组中的颜色数（必须为 &gt;= width 或 &lt;= -width）。</li><li>int width：bitmap 的宽度。</li><li>int height：bitmap 的高度。</li><li>Config config：创建的 bitmap 的配置。如果配置不支持每像素的 alpha（例如 RGB_565），那么 colors []中的 alpha 字节将被忽略（假定为 FF）</li></ul><h3 id="public-static-Bitmap-createBitmap-NonNull-ColorInt-int-colors-int-width-int-height-Config-config"><a href="#public-static-Bitmap-createBitmap-NonNull-ColorInt-int-colors-int-width-int-height-Config-config" class="headerlink" title="public static Bitmap createBitmap(@NonNull @ColorInt int[] colors, int width, int height, Config config)"></a>public static Bitmap createBitmap(@NonNull @ColorInt int[] colors, int width, int height, Config config)</h3><p>重载 Bitmap createBitmap(@NonNull DisplayMetrics display, @NonNull @ColorInt int[] colors, int offset, int stride, int width, int height, @NonNull Config config)</p><p>createBitmap(null, colors, 0, width, width, height, config);</p><h3 id="public-static-Bitmap-createBitmap-Nullable-DisplayMetrics-display-NonNull-ColorInt-int-colors-int-width-int-height-NonNull-Config-config"><a href="#public-static-Bitmap-createBitmap-Nullable-DisplayMetrics-display-NonNull-ColorInt-int-colors-int-width-int-height-NonNull-Config-config" class="headerlink" title="public static Bitmap createBitmap(@Nullable DisplayMetrics display, @NonNull @ColorInt int colors[], int width, int height, @NonNull Config config)"></a>public static Bitmap createBitmap(@Nullable DisplayMetrics display, @NonNull @ColorInt int colors[], int width, int height, @NonNull Config config)</h3><p>重载 Bitmap createBitmap(@NonNull DisplayMetrics display, @NonNull @ColorInt int[] colors, int offset, int stride, int width, int height, @NonNull Config config)</p><p>createBitmap(display, colors, 0, width, width, height, config);</p><h3 id="public-static-NonNull-Bitmap-createBitmap-NonNull-Picture-source"><a href="#public-static-NonNull-Bitmap-createBitmap-NonNull-Picture-source" class="headerlink" title="public static @NonNull Bitmap createBitmap(@NonNull Picture source)"></a>public static @NonNull Bitmap createBitmap(@NonNull Picture source)</h3><p>重载 Bitmap createBitmap(@NonNull Picture source, int width, int height, @NonNull Config config)</p><p>createBitmap(source, source.getWidth(), source.getHeight(), Config.HARDWARE);</p><h3 id="public-static-NonNull-Bitmap-createBitmap-NonNull-Picture-source-int-width-int-height-NonNull-Config-config"><a href="#public-static-NonNull-Bitmap-createBitmap-NonNull-Picture-source-int-width-int-height-NonNull-Config-config" class="headerlink" title="public static @NonNull Bitmap createBitmap(@NonNull Picture source, int width, int height, @NonNull Config config)"></a>public static @NonNull Bitmap createBitmap(@NonNull Picture source, int width, int height, @NonNull Config config)</h3><p>从记录的绘图命令中给定 Picture 源创建 bitmap。</p><p>在给定的宽度和高度下，bitmap 将不可变。如果宽度和高度与图片的宽度和高度不同，则图片将缩放以适应给定的宽度和高度。</p><ul><li>Picture source：记录的绘图命令 Picture 将会被绘制到返回的 bitmap 中</li><li>int width：要创建的 bitmap 的宽度。图片的宽度将根据需要缩放以匹配。</li><li>int height：要创建的 bitmap 的高度。图片的高度将根据需要缩放以匹配。</li><li>Config config：创建的 bitmap 的配置。</li></ul><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><h3 id="int-getDensity"><a href="#int-getDensity" class="headerlink" title="int getDensity()"></a>int getDensity()</h3><p>返回此 bitmap 的密度。</p><p>默认密度与当前显示的密度相同，除非当前应用程序不支持不同的屏幕密度，这种情况下默认密度为 android.util.DisplayMetric.DENSITY_DEFAULT = DENSITY_MEDIUM = 160。请注意，兼容性模式由最初加载到进程中的应用程序确定-共享同一进程的应用程序应该全部具有相同的兼容性，或者确保它们适当地显式设置其 bitmap 的密度。</p><h3 id="void-setDensity-int-density"><a href="#void-setDensity-int-density" class="headerlink" title="void setDensity(int density)"></a>void setDensity(int density)</h3><p>指定此 bitmap 的密度。当 bitmap 绘制到也具有密度的 Canvas 时，它将适当缩放。</p><ul><li>int densit：该 bitmap 使用的密度缩放因子；如果密度未知，则使用 DENSITY_NONE = 0。</li></ul><h3 id="void-reconfigure-int-width-int-height-Config-config"><a href="#void-reconfigure-int-width-int-height-Config-config" class="headerlink" title="void reconfigure(int width, int height, Config config)"></a>void reconfigure(int width, int height, Config config)</h3><p>将 bitmap 修改为具有指定的宽度，高度和 Config ，而不影响该 bitmap 的底层分配。 对于新配置，bitmap 像素数据未重新初始化。</p><p>此方法可用于避免分配新的 bitmap，而是将现有 bitmap 的分配重用于大小等于或小于的新配置。如果 bitmap 的分配不足以支持新配置，则将抛出 IllegalArgumentException，并且 bitmap 将不会被修改。</p><p>getByteCount（）的结果将反映新的配置，而 getAllocationByteCount（）的结果将反映初始的配置。</p><p>注意：这可能会更改 hasAlpha（）的结果。当转换为 565 时，新的 bitmap 将始终被视为不透明的。从 565 转换时，新的 bitmap 将被认为是不透明的，并且将遵循由 setPremultiplied（）设置的值。</p><p>警告：不应在当前正在 view 系统、Canvas 或 AndroidBitmap NDK API 使用的 bitmap 上调用此方法。它不能保证基础像素缓冲区如何重新映射到新配置，而只是保证分配已被重用。此外，view 系统无法确定使用过程中正在修改的 bitmap 属性，例如何时附着在 drawables 上。</p><p>为了安全地确保 view 系统不再使用 bitmap，必须等待正在 invalidate（）的任何在最后的绘制过程中由于硬件加速对绘制命令的缓存已经在之前绘制过此 bitmap 的 view 完成绘制过程。举一个例子，以下是以 ImageView 完成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">ImageView myImageView = ...;<br><span class="hljs-keyword">final</span> Bitmap myBitmap = ...;<br>myImageView.setImageDrawable(<span class="hljs-keyword">null</span>);<br>myImageView.post(<span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// myBitmap is now no longer in use by the ImageView</span><br>        <span class="hljs-comment">// and can be safely reconfigured.</span><br>        myBitmap.reconfigure(...);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="void-setWidth-int-width"><a href="#void-setWidth-int-width" class="headerlink" title="void setWidth(int width)"></a>void setWidth(int width)</h3><p>使用当前已有高度和配置调用 reconfigure（int，int，Config）的便捷方法。</p><p>警告：此方法不应在 view 系统当前使用的 bitmap 上使用，有关更多详细信息，请参见 reconfigure（int，int，Config）。</p><h3 id="void-setHeight-int-height"><a href="#void-setHeight-int-height" class="headerlink" title="void setHeight(int height)"></a>void setHeight(int height)</h3><p>使用当前已有宽度和配置调用 reconfigure（int，int，Config）的便捷方法。</p><p>警告：此方法不应在 view 系统当前使用的 bitmap 上使用，有关更多详细信息，请参见 reconfigure（int，int，Config）。</p><h3 id="void-setConfig-Config-config"><a href="#void-setConfig-Config-config" class="headerlink" title="void setConfig(Config config)"></a>void setConfig(Config config)</h3><p>使用当前已有宽度和高度调用 reconfigure（int，int，Config）的便捷方法。</p><p>警告：此方法不应在 view 系统当前使用的 bitmap 上使用，有关更多详细信息，请参见 reconfigure（int，int，Config）。</p><h3 id="void-setNinePatchChunk-byte-chunk"><a href="#void-setNinePatchChunk-byte-chunk" class="headerlink" title="void setNinePatchChunk(byte[] chunk)"></a>void setNinePatchChunk(byte[] chunk)</h3><p>设置.9 图数据块。</p><ul><li>byte[] chunk .9 图相关定义数据块</li></ul><h3 id="void-recycle"><a href="#void-recycle" class="headerlink" title="void recycle()"></a>void recycle()</h3><p>释放与此 bitmap 关联的 native 对象，并清除对像素数据的引用。这将不会同步释放像素数据。 如果没有其他引用，它只是允许对其进行垃圾回收。bitmap 被标记为“死亡”，这意味着如果 getPixels（）或 setPixels（）被调用，它将抛出异常，并且不会绘制任何内容。 此操作不能撤消，因此只有在确定 bitmap 没有进一步用途时才应调用它。这是一个高级调用，通常不需要，因为当没有更多对该 bitmap 的引用时，正常的 GC 进程将释放此内存。</p><h3 id="boolean-isRecycled"><a href="#boolean-isRecycled" class="headerlink" title="boolean isRecycled()"></a>boolean isRecycled()</h3><p>如果此 bitmap 已被回收，则返回 true。如果是被回收，则尝试访问其像素是一个错误，并且 bitmap 将不会绘制。</p><h3 id="int-getGenerationId"><a href="#int-getGenerationId" class="headerlink" title="int getGenerationId()"></a>int getGenerationId()</h3><p>返回此 bitmap 的生成 ID。只要修改 bitmap，生成 ID 就会改变。这是一个可用于检查 bitmap 是否已更改的高效方法。</p><h3 id="void-copyPixelsToBuffer-Buffer-dst"><a href="#void-copyPixelsToBuffer-Buffer-dst" class="headerlink" title="void copyPixelsToBuffer(Buffer dst)"></a>void copyPixelsToBuffer(Buffer dst)</h3><p>将 bitmap 的像素复制到指定的缓冲区（由调用者分配）。如果缓冲区的大小不足以容纳所有像素（考虑到每个像素的字节数），或者如果 Buffer 子类不是支持类型之一（ByteBuffer，ShortBuffer，IntBuffer），则抛出异常。</p><p>bitmap 的内容按原样复制到缓冲区中。这意味着如果该 bitmap 存储了预乘的像素（请参见 isPremultiplied()），则缓冲区中的值也将被预乘。像素保留在 bitmap 的颜色空间中）。</p><p>返回此方法后，将更新缓冲区的当前位置：位置将增加写入缓冲区的元素数量。</p><h3 id="void-copyPixelsFromBuffer-Buffer-src"><a href="#void-copyPixelsFromBuffer-Buffer-src" class="headerlink" title="void copyPixelsFromBuffer(Buffer src)"></a>void copyPixelsFromBuffer(Buffer src)</h3><p>从当前位置开始，从缓冲区复制像素，覆盖 bitmap 的像素。缓冲区中的数据不会以任何方式更改（不同于 setPixels（），后者会从未预乘的 32bit 转换为 bitmap 的 native 格式。源缓冲区中的像素假定位于 bitmap 的色彩空间中）。</p><p>返回此方法后，将更新缓冲区的当前位置：该位置将增加从缓冲区读取的元素数。如果需要再次从缓冲区读取 bitmap，则必须首先倒带缓冲区。</p><h3 id="Bitmap-copy-Config-config-boolean-isMutable"><a href="#Bitmap-copy-Config-config-boolean-isMutable" class="headerlink" title="Bitmap copy(Config config, boolean isMutable)"></a>Bitmap copy(Config config, boolean isMutable)</h3><p>尝试根据此 bitmap 的尺寸制作一个新的 bitmap，将新 bitmap 的配置设置为指定的配置，然后将该 bitmap 的像素复制到新的位图中。如果不支持转换，或者分配器失败，则返回 NULL 。返回的 bitmap 具有与原始 bitmap 相同的密度和色彩空间，以下情况除外。复制到 Config.ALPHA_8 时，颜色空间将被删除。复制到 Config.RGBA_F16 或从 Config.RGBA_F16 复制时， EXTENDED 或 non-EXTENDED 变体可能会适当调整。</p><ul><li>Config config：生成的 bitmap 所需的配置。</li><li>boolean isMutable：是否结果 bitmap 是可变的（即像素可以修改）。</li></ul><h3 id="byte-getNinePatchChunk"><a href="#byte-getNinePatchChunk" class="headerlink" title="byte[] getNinePatchChunk()"></a>byte[] getNinePatchChunk()</h3><p>返回一个可选的私有数据数组，UI 系统用于一些 bitmap 。不应由应用程序调用。</p><h3 id="boolean-compress-CompressFormat-format-int-quality-OutputStream-stream"><a href="#boolean-compress-CompressFormat-format-int-quality-OutputStream-stream" class="headerlink" title="boolean compress(CompressFormat format, int quality, OutputStream stream)"></a>boolean compress(CompressFormat format, int quality, OutputStream stream)</h3><p>将 bitmap 的压缩版本写入指定的输出流。如果返回 true，则可以通过将相应的输入流传递给 BitmapFactory.decodeStream（）来重构位图。注意：不是所有格式都直接支持所有 bitmap 配置，因此从 BitmapFactory 返回的 bitmap 可能处于不同的位深中，并且/或者 丢失了每个像素的 alpha（例如 JPEG 仅支持不透明像素）。</p><ul><li>CompressFormat format：压缩图像的格式</li><li>int qualit：给压缩器的提示，0-100。 0 表示压缩已获得最低质量，100 表示 ​​ 压缩以获得最高质量。某些格式（例如无损的 PNG）将忽略该质量设置。</li><li>OutputStream stream：写入压缩数据的输出流。</li></ul><h3 id="final-boolean-isMutable"><a href="#final-boolean-isMutable" class="headerlink" title="final boolean isMutable()"></a>final boolean isMutable()</h3><p>返回 bitmap 是否为可变的。</p><h3 id="final-boolean-isPremultiplied"><a href="#final-boolean-isPremultiplied" class="headerlink" title="final boolean isPremultiplied()"></a>final boolean isPremultiplied()</h3><p>指示是否存储在此 bitmap 中的像素被预乘。 当像素预乘时，RGB 分量已乘以 alpha 分量。例如，如果原始颜色为 50％半透明红色（128，255，0，0），则预乘形式为（128，128，0，0）。</p><p>如果 getConfig() 为 Bitmap.Config.RGB_565 ，则方法始终返回 false。</p><p>如果 getConfig() 为 Bitmap.Config.ALPHA_8 ，则方法返回值不确定。</p><p>仅当 hasAlpha() 返回 true 时，此方法才返回 true 。 没有 alpha 通道的 bitmap 既可以用作预乘位，也可以用作非预乘 bitmap 。</p><p>view 系统或 Canvas 只能绘制预乘的 bitmap。如果将带有 Alpha 通道的非预乘 bitmap 绘制到了 Canvas 上，则会抛出 RuntimeException。</p><h3 id="final-int-getWidth"><a href="#final-int-getWidth" class="headerlink" title="final int getWidth()"></a>final int getWidth()</h3><p>返回 bitmap 的宽度。</p><h3 id="final-int-getHeight"><a href="#final-int-getHeight" class="headerlink" title="final int getHeight()"></a>final int getHeight()</h3><p>返回 bitmap 的高度。</p><h3 id="int-getScaledWidth-Canvas-canvas"><a href="#int-getScaledWidth-Canvas-canvas" class="headerlink" title="int getScaledWidth(Canvas canvas)"></a>int getScaledWidth(Canvas canvas)</h3><p>使用给定 Canva 的目标密度调用 getScaledWidth(int) 的便捷方法。</p><h3 id="int-getScaledHeight-Canvas-canvas"><a href="#int-getScaledHeight-Canvas-canvas" class="headerlink" title="int getScaledHeight(Canvas canvas)"></a>int getScaledHeight(Canvas canvas)</h3><p>使用给定 Canva 的目标密度调用 getScaledWidth(int) 的便捷方法。</p><h3 id="int-getScaledWidth-DisplayMetrics-metrics"><a href="#int-getScaledWidth-DisplayMetrics-metrics" class="headerlink" title="int getScaledWidth(DisplayMetrics metrics)"></a>int getScaledWidth(DisplayMetrics metrics)</h3><p>使用给定 DisplayMetrics 的目标密度调用 getScaledWidth(int) 的便捷方法。</p><h3 id="int-getScaledHeight-DisplayMetrics-metrics"><a href="#int-getScaledHeight-DisplayMetrics-metrics" class="headerlink" title="int getScaledHeight(DisplayMetrics metrics)"></a>int getScaledHeight(DisplayMetrics metrics)</h3><p>使用给定 DisplayMetrics 的目标密度调用 getScaledWidth(int) 的便捷方法。</p><h3 id="int-getScaledWidth-int-targetDensity"><a href="#int-getScaledWidth-int-targetDensity" class="headerlink" title="int getScaledWidth(int targetDensity)"></a>int getScaledWidth(int targetDensity)</h3><p>返回此 bitmap 宽度除以密度比例因子的便捷方法。</p><p>返回 bitmap 的宽度乘以目标密度与 bitmap 的源密度的比率。</p><ul><li>int targetDensity：bitmap 的目标 canvas 的密度。</li></ul><h3 id="int-getScaledHeight-int-targetDensity"><a href="#int-getScaledHeight-int-targetDensity" class="headerlink" title="int getScaledHeight(int targetDensity)"></a>int getScaledHeight(int targetDensity)</h3><p>返回此 bitmap 高度除以密度比例因子的便捷方法。</p><p>返回 bitmap 的高度乘以目标密度与 bitmap 的源密度的比率。</p><ul><li>int targetDensity：bitmap 的目标 canvas 的密度。</li></ul><h3 id="final-int-getRowBytes"><a href="#final-int-getRowBytes" class="headerlink" title="final int getRowBytes()"></a>final int getRowBytes()</h3><p>返回 bitmap 像素中 行之间的字节数。请注意，指的是由 bitmap 由 native 存储的像素。如果调用 getPixels() 或 setPixels() ，则像素将被统一视为 32 位值，并根据 Color 类打包。</p><p>从 android.os.Build.VERSION_CODES.KITKAT （Android 4.4，19）开始，此方法不应用于计算 bitmap 的内存使用情况。而应使用 getAllocationByteCount() 。</p><h3 id="final-int-getByteCount"><a href="#final-int-getByteCount" class="headerlink" title="final int getByteCount()"></a>final int getByteCount()</h3><p>返回可用于存储该 bitmap 像素的最小字节数。</p><p>从 android.os.Build.VERSION_CODES.KITKAT （Android 4.4，19）开始，此方法不应用于计算 bitmap 的内存使用情况。而应使用 getAllocationByteCount() 。</p><h3 id="final-int-getAllocationByteCount"><a href="#final-int-getAllocationByteCount" class="headerlink" title="final int getAllocationByteCount()"></a>final int getAllocationByteCount()</h3><p>返回用于存储此 bitmap 像素的已分配内存的大小。</p><p>如果 bitmap 被重用以解码其他较小尺寸的 bitmap，或者通过手动重新配置，则此结果可能大于 getByteCount() 的结果。请参见 reconfigure(int，int，Config)，setWidth(int) ，setHeight(int) ，setConfig(Bitmap.Config) 和 BitmapFactory.Options.inBitmap 。如果未以这种方式修改 bitmap ，则此值将 getByteCount() 返回的值相同。</p><h3 id="final-Config-getConfig"><a href="#final-Config-getConfig" class="headerlink" title="final Config getConfig()"></a>final Config getConfig()</h3><p>如果 bitmap 的内部配置采用一种公共格式，则返回该配置，否则返回 null 。</p><h3 id="final-boolean-hasAlpha"><a href="#final-boolean-hasAlpha" class="headerlink" title="final boolean hasAlpha()"></a>final boolean hasAlpha()</h3><p>如果 bitmap 的配置支持每个像素的 alpha ，则返回 true；如果像素可能包含非透明的 alpha 值，则返回。对于某些配置，始终为 false（例如 RGB_565），因为它们不支持按像素 alpha。但是，对于需要这样做的配置，可以将 bitmap 标记为知道其所有像素都是不透明的。在这种情况下，hasAlpha（）也将返回 false 。如果未对 ARGB_8888 之类的配置进行标记，则默认情况下将返回 true。</p><h3 id="final-boolean-hasMipMap"><a href="#final-boolean-hasMipMap" class="headerlink" title="final boolean hasMipMap()"></a>final boolean hasMipMap()</h3><p>指示负责绘制此 bitmap 的渲染器是否应按比例缩小 bitmap 图时尝试使用 mipmaps 。</p><p>如果知道要以小于其原始大小的 50％绘制此 bitmap ，则可能可以获得更高的质量。</p><p>此属性只是一个渲染器可以忽略的建议。不能保证有任何效果。</p><h3 id="final-void-setHasMipMap-boolean-hasMipMap"><a href="#final-void-setHasMipMap-boolean-hasMipMap" class="headerlink" title="final void setHasMipMap(boolean hasMipMap)"></a>final void setHasMipMap(boolean hasMipMap)</h3><p>指示负责绘制此 bitmap 的渲染器是否应按比例缩小 bitmap 图时尝试使用 mipmaps 。</p><p>如果知道要以小于其原始大小的 50％绘制此 bitmap ，则可能可以获得更高的质量。</p><p>此属性只是一个渲染器可以忽略的建议。不能保证有任何效果。</p><ul><li>boolean hasMipMap；指示渲染器是否应尝试使用 mipmaps。</li></ul><h3 id="final-ColorSpace-getColorSpace"><a href="#final-ColorSpace-getColorSpace" class="headerlink" title="final ColorSpace getColorSpace()"></a>final ColorSpace getColorSpace()</h3><p>返回与此 bitmap 关联的色彩空间。如果颜色空间未知，则此方法返回 null 。</p><h3 id="void-setColorSpace-NonNull-ColorSpace-colorSpace"><a href="#void-setColorSpace-NonNull-ColorSpace-colorSpace" class="headerlink" title="void setColorSpace(@NonNull ColorSpace colorSpace)"></a>void setColorSpace(@NonNull ColorSpace colorSpace)</h3><p>将 bitmap 识别为具有指定的 ColorSpace ，而不影响 bitma 的底层分配。</p><p>这影响 framework 层如何解释每个像素的颜色。具有 Config.ALPHA_8 的 bitmap 永远不会有颜色空间，因为颜色空间不会影响 a​​lpha 通道。其他 Config 一定具有非 null 的 ColorSpace。</p><h3 id="void-eraseColor-ColorInt-int-c"><a href="#void-eraseColor-ColorInt-int-c" class="headerlink" title="void eraseColor(@ColorInt int c)"></a>void eraseColor(@ColorInt int c)</h3><p>用指定的 Color 填充 bitmap 的像素。</p><h3 id="void-eraseColor-ColorLong-long-color"><a href="#void-eraseColor-ColorLong-long-color" class="headerlink" title="void eraseColor(@ColorLong long color)"></a>void eraseColor(@ColorLong long color)</h3><p>用指定的 ColorLong 填充 bitmap 的像素。</p><h3 id="int-getPixel-int-x-int-y"><a href="#int-getPixel-int-x-int-y" class="headerlink" title="int getPixel(int x, int y)"></a>int getPixel(int x, int y)</h3><p>返回指定位置的 Color 。如果 x 或 y 超出范围（负值或者分别大于等于宽度或高度，则抛出异常）。返回的颜色是 ColorSpace.Named.SRGB 颜色空间中的非预乘 ARGB 值。</p><ul><li>int x：要返回像素的 x 坐标（0 … width-1）。</li><li>int y：要返回像素的 y 坐标（0 … height-1）。</li></ul><h3 id="Color-getColor-int-x-int-y"><a href="#Color-getColor-int-x-int-y" class="headerlink" title="Color getColor(int x, int y)"></a>Color getColor(int x, int y)</h3><p>返回指定位置的 Color 。如果 x 或 y 超出范围（负值或者分别大于等于宽度或高度，则抛出异常）。返回的颜色是 ColorSpace.Named.SRGB 颜色空间中的非预乘 ARGB 值。</p><ul><li>int x：要返回像素的 x 坐标（0 … width-1）。</li><li>int y：要返回像素的 y 坐标（0 … height-1）。</li></ul><h3 id="void-getPixels-ColorInt-int-pixels-int-offset-int-stride-int-x-int-y-int-width-int-height"><a href="#void-getPixels-ColorInt-int-pixels-int-offset-int-stride-int-x-int-y-int-width-int-height" class="headerlink" title="void getPixels(@ColorInt int[] pixels, int offset, int stride, int x, int y, int width, int height)"></a>void getPixels(@ColorInt int[] pixels, int offset, int stride, int x, int y, int width, int height)</h3><p>以 pixel[] 数组的形式返回 bitmap 中数据的副本。每个值都是表示 Color 的包装 int 。 stride 参数允许调用方在行之间的返回像素数组中设置步长。对于正常的打包结果，只需通过宽度作为步长即可。 返回的颜色是 ColorSpace.Named.SRGB 颜色空间中的非预乘 ARGB 值。</p><ul><li>int[] pixels：接收 bitmap 颜色的数组。</li><li>int offset：写入像素的第一个索引[]。</li><li>int stride：要在行之间跳过的像素数[]的条目数（必须 &gt;= bitmap 的宽度）。可以为负。</li><li>int x：从 bitmap 读取的第一个像素的 x 坐标。</li><li>int y：从 bitmap 读取的第一个像素的 y 坐标。</li><li>int width：每行要读取的像素数。</li><li>int height：要读取的行数。</li></ul><h3 id="void-setPixel-int-x-int-y-ColorInt-int-color"><a href="#void-setPixel-int-x-int-y-ColorInt-int-color" class="headerlink" title="void setPixel(int x, int y, @ColorInt int color)"></a>void setPixel(int x, int y, @ColorInt int color)</h3><p>在 x，y 坐标处将指定的 Color 写入 bitmap（假设 bitmap 是可变的）。颜色必须是 ColorSpace.Named.SRGB 颜色空间中的非预乘 ARGB 值。</p><ul><li>int x：要替换的像素的 x 坐标（0 … width-1）。</li><li>int y：要替换的像素的 y 坐标（0 … height-1）。</li><li>int color：写入 bitmap 的 ARGB 颜色。</li></ul><h3 id="void-setPixels-ColorInt-int-pixels-int-offset-int-stride-int-x-int-y-int-width-int-height"><a href="#void-setPixels-ColorInt-int-pixels-int-offset-int-stride-int-x-int-y-int-width-int-height" class="headerlink" title="void setPixels(@ColorInt int[] pixels, int offset, int stride, int x, int y, int width, int height)"></a>void setPixels(@ColorInt int[] pixels, int offset, int stride, int x, int y, int width, int height)</h3><p>用数组中的颜色替换 bitmap 中的像素。数组中的每个元素是一个包装 int ，表示 ColorSpace.Named.SRGB 颜色空间中未预乘的 ARGB Color。</p><ul><li>int[] pixels：写入 bitma 的颜色数组。</li><li>int offset：从像素读取的第一种颜色的索引[]。</li><li>int stride：以像素为单位的颜色数，以在行之间跳过。通常，此值将与 bitmap 的宽度相同，但是可以更大（或为负）。</li><li>int x：bitmap 中要写入的第一个像素的 x 坐标。</li><li>int y：bitmap 中要写入的第一个像素的 y 坐标。</li><li>int width：每行要从 pixel[] 复制的颜色数。</li><li>int height：写入 bitmap 的行数。</li></ul><h3 id="Bitmap-extractAlpha"><a href="#Bitmap-extractAlpha" class="headerlink" title="Bitmap extractAlpha()"></a>Bitmap extractAlpha()</h3><p>返回捕获原始图像的 Alpha 值的新 bitmap。 可以使用 Canvas.drawBitmap() 进行绘制，其中颜色将从传递给绘图调用的 paint 中获取。</p><h3 id="Bitmap-extractAlpha-Paint-paint-int-offsetXY"><a href="#Bitmap-extractAlpha-Paint-paint-int-offsetXY" class="headerlink" title="Bitmap extractAlpha(Paint paint, int[] offsetXY)"></a>Bitmap extractAlpha(Paint paint, int[] offsetXY)</h3><p>返回捕获原始图像的 Alpha 值的新 bitmap。 这些值可能会受到可选的 Paint 参数的影响，该参数可以包含自己的 alph 值，还可以包含 MaskFilter ，后者可以更改结果 bitmap 的实际尺寸（例如模糊 maskfilter 可能会放大结果 bitmap）。如果 offsetXY 不为 null ，则返回偏移返回 bitmap 的量，以便在逻辑上与原始对齐。例如，如果绘画包含半径为 2 的模糊，则 offsetXY[] 将包含 -2，-2，这样绘制 alpha 的 bitmap 偏移量为（-2，-2），然后绘制原图将使得模糊效果与原图在视觉上对齐。</p><ul><li>Paint paint：用于修改结果 bitmap 中的 alpha 值的可选画笔。为默认传递 null 。</li><li>int[] offsetXY：可选数组，该数组返回放置返回的 bitmpa 所需的 X（索引 0）和 Y（索引 1）偏移，以使其在视觉上与原始行对齐。</li></ul><h3 id="boolean-sameAs-Bitmap-other"><a href="#boolean-sameAs-Bitmap-other" class="headerlink" title="boolean sameAs(Bitmap other)"></a>boolean sameAs(Bitmap other)</h3><p>给定另一个 bitmap ，如果它具有与此 bitmap 相同的尺寸，配置，和像素数据，则返回 true。如果其中任何一个不同，则返回 false。 如果 other 为 null ，则返回 false 。</p><h3 id="void-prepareToDraw"><a href="#void-prepareToDraw" class="headerlink" title="void prepareToDraw()"></a>void prepareToDraw()</h3><p>构建与用于绘制 bitmap 的 bitmap 关联的缓存。</p><p>从 android.os.Build.VERSION_CODES.N（Android 7.0，24）开始，如果尚未上传 bitmap，则此调用会在 RenderThread 上启动异步上传到 GPU。使用硬件加速时，必须将 bitmap 上传到 GPU 才能进行渲染。默认情况下，这是在第一次绘制 bitmap 时完成的，但是此过程可能需要几毫秒的时间，具体取决于 bitmap 的大小。每次修改并再次绘制 bitmap 时，都必须重新上传。</p><p>提前调用此方法可以节省使用第一帧的时间。例如，建议在解码的 bitmap 即将显示时在图像解码工作线程上调用此方法。建议在调用此方法之前对 bitmap 进行任何预绘制修改，以便可以重新使用缓存的上传副本，而无需重新上传。</p><p>在 android.os.Build.VERSION_CODES.KITKAT （Android 6.0，23）及以下版本中，对于可清除的 bitmap ，此调用将尝试确保像素已解码。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>图片</tag>
      
      <tag>Bitmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android图片压缩</title>
    <link href="/post/Android%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"/>
    <url>/post/Android%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么要压缩"><a href="#为什么要压缩" class="headerlink" title="为什么要压缩"></a>为什么要压缩</h2><h3 id="减少内存占用"><a href="#减少内存占用" class="headerlink" title="减少内存占用"></a>减少内存占用</h3><p>内存占用大小 = Bitmap 大小 = 总像素点数 x 一个像素点占用的字节数</p><h4 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h4><p><strong>Android 中图片在内存中的表达形式是 Bitmap，即位图。</strong></p><h5 id="总像素点数"><a href="#总像素点数" class="headerlink" title="总像素点数"></a>总像素点数</h5><p><strong>总像素点数由什么决定呢？</strong></p><p>总像素点数 = 图片源长度 x 缩放比例 x 图片源宽度 x 缩放比例</p><p>缩放比例可以大致表示为：（为什么说大致呢？因为不是绝对的，实际还有其他因素可以影响实际缩放比例，如 inScreenDensity）<br>缩放比例 = 1/inSampleSize x (inTargetDensity/inDensity)</p><ul><li>int inSampleSize</li></ul><p>如果设置的值大于 1，将会请求解码器对原始图像进行二次采样，返回较小的图像以节省内存。样本大小是任一维度中与已解码 bitmap 中单个像素对应的像素数。例如，设置 inSampleSize == 4 ，将会返回一张是宽高为原始宽度和高度的 1/4 的图像，像素为原来的 1/16。任何小于等于 1 的值都与 1 相同。注意：解码器使用基于 2 的幂的最终值，任何其他值将四舍五入为最接近的 2 的幂。</p><ul><li>int inDensity</li></ul><p>用于 bitmap 像素密度。这将使得在返回的位图中始终有为其设置的密度（请参阅 Bitmap.setDensity(int)）。此外，如果开启了 inScaled（默认情况下开启），并且此密度与 inTargetDensity 不匹配，则 bitmap 在返回之前将被缩放为目标密度。</p><p>如果设置为 0， BitmapFactory.decodeResource(Resources, int) 、 BitmapFactory.decodeResource(Resources, int, android.graphics.BitmapFactory.Options) 、 BitmapFactory.decodeResourceStream 这些 decode 方法将填充与资源关联的密度。其他 decode 方法将保持原样，并且不会应用任何密度。</p><ul><li>int inTargetDensity</li></ul><p>此 bitmap 将被绘制到的目标像素密度。 与 inDensity 和 inScaled 结合使用，以确定在返回 bitmap 之前是否以及如何缩放位图。</p><p>如果设置为 0， BitmapFactory.decodeResource(Resources, int) 、 BitmapFactory.decodeResource(Resources, int, android.graphics.BitmapFactory.Options) 、 BitmapFactory.decodeResourceStream 这些 decode 方法将填充与资源对象的 DisplayMetrics 相关的密度。其他 decode 方法将保持原样，并且不会对密度进行缩放。</p><ul><li>int inScreenDensity</li></ul><p>正在使用的实际屏幕的像素密度。 仅用于以密度兼容代码运行的应用程序，其中 inTargetDensity 实际上是应用程序看到的密度而不是实际的屏幕密度。</p><p>通过设置此选项，允许加载代码避免将当前的屏幕密度的 bitmap 缩放到/降低到兼容密度。相反的，如果 inDensity 与 inScreenDensity 相同，则 bitmap 将保持不变。任何使用生成的 bitmap 的对象，还必须使用 Bitmap.getScaledWidth 和 Bitmap.getScaledHeight 来说明 bitmap 的密度与目标密度之间的任何差异。</p><p>BitmapFactory 自身永远不会为调用者自动设置。必须明确设置它，因为调用者必须以密度感知的方式处理结果位图。</p><ul><li>boolean inScaled</li></ul><p>如果设置了该配置，并且 inDensity 和 inTargetDensity 不为 0，bitmap 在加载时将缩放以匹配 inTargetDensity，而不是每次绘制到 Canvas 时都依赖于图形系统对其进行缩放。</p><p>BitmapRegionDecoder 会忽略这个配置，并且不会根据密度缩放输出。（尽管支持 inSampleSize ）</p><p>此配置默认开启，如果需要 bitmap 的非缩放版本，则应将其关闭。.9 bitmaps（Nine-patch bitmaps）会忽略此配置，并且始终会缩放。</p><p>如果 inPremultiplied 设置为 false ，并且图像具有 Alpha 透明度，将此配置设置为 true 可能会导致颜色错误。</p><h5 id="一个像素点占用的字节数"><a href="#一个像素点占用的字节数" class="headerlink" title="一个像素点占用的字节数"></a>一个像素点占用的字节数</h5><p><strong>一个像素点占用的字节数由什么决定呢？</strong></p><blockquote><p>像素信息:</p><ul><li>像素不是一个具体的物理量，是一种抽象的数据结构。</li></ul><p>如果把一张图片看成是一堆信息元素的集合，那么为了描述一张图片，我们要先建模，用一个数据结构来表示信息元素。从而，建模后图像就成了一堆数据结构（结构体）的集合，现在给这种数据结构起个名字就叫像素。</p><ul><li>像素这种数据结构中可以记录颜色信息（因为图像就是由不同颜色组成的）。</li></ul></blockquote><blockquote><p>色彩空间（ColorSpace），对色彩的组织方式，RGB、YUV、CMYK 等。</p><ul><li>RGB：一个像素划分 Red、Green、Blue 分量来表示，面向硬件，适合显示系统,不适合图像处理。</li><li>YUV：Y 表示明亮度（Luminance，Luma，黑白信号），UV 表示色度、浓度（Chrominance，Chroma，色彩信息）。</li><li>CMYK：C：Cyan ＝ 青色，常被误称为“天蓝色”或“湛蓝”，M：Magenta ＝ 洋红色，又称为“品红色”，Y：Yellow ＝ 黄色，K：blacK ＝ 黑色，是彩色印刷时采用的一种套色模式，利用色料的三原色混色原理，加上黑色油墨，共计四种颜色混合叠加，形成所谓“全彩印刷”。</li></ul><p>色彩模式是数字世界中表示颜色的一种算法。</p></blockquote><p><strong>因此一个像素点占用的字节由存储像素信息的方案决定。</strong></p><p>假设我们采用 ARGB 色彩模式，即在 RGB 色彩空间的基础上加上 Alpha（透明度）通道。每个通道的取值范围在[0,255]，即有 256 个值，刚好可以用一个字节（8bit）表示。ARGB 四个通道，需要四个字节表示一个像素信息。</p><p>事实上，在保证必要的像素信息的同时追求更少的内存占用，可以减少通道的位数，甚至可以考虑去掉 Alpha（透明度）通道。</p><p><strong>Bitmap.Config 是一个枚举类，它表示的就是每个像素点信息的存储方案。</strong><br>| Config | 每个像素占用字节数 | 表示颜色种数 | 说明 |<br>| ——— | ——————————————– | ——————— | ———————————————————————- |<br>| ALPHA_8 | 1 个字节，A 分量占 8 位，不存储颜色信息 | 0 | 单透明通道 |<br>| RGB_565 | 两个字节，R 分量占 5 位，G 分量占 6 位，B 分量占 5 位 | 2^16(65536) | 简易 RGB 色调 |<br>| RGB_888 | 三个字节，R、G、B 分量各占 8 位 | 2^24(16777216) | RGB 色调 |<br>| ARGB_4444 | 两个字节，A、R、G、B 分量各占 4 位 | 2^12(4096) | 已弃用，成像效果比较差，并且 v4.4+后如果使用了它会自动转成用 ARGB_8888。 |<br>| ARGB_8888 | 四个字节，A、R、G、B 分量各占 8 位 | 2^24(16777216) | 24 位真彩色，Android 中默认的配置 |<br>| RGBA_F16 | 八个字节，A、R、G、B 分量各占 16 位 | 2^48(281474976710656) | 特别适合于宽色域和 HDR 内容，在 8.0（api 26）引入。 |<br>| HARDWARE | - | - | 特殊配置。bitmap 始终存储在图形内存中，在 8.0（api 26）引入。 |</p><h3 id="减少物理空间占用"><a href="#减少物理空间占用" class="headerlink" title="减少物理空间占用"></a>减少物理空间占用</h3><p>物理空间占用 = 簇（操作系统所使用的逻辑概念）的整数倍 &gt;= 文件大小</p><p>图片在物理空间的表现形式是 File，具体有 GIF、JPEG、BMP、PNG 和 WebP 等格式。</p><blockquote><ul><li>Gif<br>Gif 是一种基于 LZW 算法的无损压缩格式，其压缩率一般在 50％左右。Gif 可插入多帧，从而实现动画效果。因此 Gif 图片分为静态 GIF 和动画 GIF 两种 GIF 格式。由于 Gif 以 8 位颜色压缩存储单个位图，所以它最多只能用 256 种颜色来表现物体，对于色彩复杂的物体它就力不从心了。因此 Gif 不适合用于色彩非常丰富的图片的压缩存储，比如拍摄的真彩图片等。</li><li>BMP<br>BMP 是标准图形格式，它是包括 Windows 在内多种操作系统图像展现的终极形式。其本质就是 Bitmap 对象直接持久化保存的位图文件格式，由于没有进行压缩存储，因此体积非常大，故而不适合在网络上传输。同时也是因为这种格式是对 Bitmap 对象的直接存储而没有进行压缩，因此我们在讨论压缩格式时往往忽略这一种。</li><li>PNG<br>PNG 格式本身的设计目的是替代 GIF 格式，所以它与 GIF 有更多相似的地方。PNG 格式也属于无损压缩，其位深为 32 位，也就是说它支持所有的颜色类型。同样是无损压缩，PNG 的压缩率高于 Gif 格式，而且 PNG 支持的颜色数量也远高于 Gif，因此：如果是对静态图片进行无损压缩，优先使用 PNG 取代 Gif，因为 PNG 压缩率高、色彩好；但是 PNG 不支持动画效果。所以 Gif 仍然有用武之地。<br>PNG 缺点是：由于是无损压缩，因此 PNG 文件的体积往往比较大。如果在项目中多处使用 PNG 图片文件，那么在 APP 瘦身时需要对 PNG 文件进行优化以减少 APP 体积大小。具体做法后面会详细介绍。</li><li>JPEG<br>JPEG 是一种有损压缩格式，JPEG 图片以 24 位颜色压缩存储单个位图。也就是说，JPEG 不支持透明通道。JPEG 也不支持多帧动画。因为是有损压缩，所以需要注意控制压缩率以免图片质量太差。<br>JPG 和 JPEG 没有区别，全名、正式扩展名是 JPEG。但因 DOS、Windows95 等早期系统采用的 8.3 命名规则只支持最长 3 字符的扩展名，为了兼容采用了.jpg。也因历史习惯和兼容性的考虑，.jpg 目前更流行。JPEG2000 作为 JPEG 的升级版，其压缩率比 JPEG 高约 30％左右，同时支持有损和无损压缩。<br>JPEG2000 格式有一个极其重要的特征在于它能实现渐进传输，即先传输图像的轮廓，然后逐步传输数据，不断提高图像质量，让图像由朦胧到清晰显示。此外，JPEG2000 还支持所谓的“感兴趣区域”特性，也就是可以任意指定影像上感兴趣区域的压缩质量；另外，JPEG2000 还可以选择指定的部分先解压缩来加载到内存中。JPEG2000 和 JPEG 相比优势明显，且向下兼容，因此可取代传统的 JPEG 格式。</li><li>WebP<br>WebP 是 Google 在 2010 年发布的图片格式，希望以更高的压缩率替代 JPEG。它用 VP8 视频帧内编码作为其算法基础，取得了不错的压缩效果。WebP 支持有损和无损压缩、支持完整的透明通道、也支持多帧动画，并且没有版权问题，是一种非常理想的图片格式。WebP 支持动图，基本取代 gif。<br>WebP 不仅集成了 PNG、JPEG 和 Gif 的所有功能，而且相同质量的无损压缩 WebP 图片体积比 PNG 小大约 26%；如果是有损压缩，相同质量的 WebP 图片体积比 JPEG 小 25%-34%。<br>很多人会认为，既然 WebP 功能完善、压缩率更高，那直接用 WebP 取代上述所有的图片压缩格式不就行了吗？其实不然，WebP 也有其缺点：我们知道 JPEG 是有损压缩而 PNG 是无损压缩，所以 JPEG 的压缩率高于 PNG；但是有损压缩的算法决定了其压缩时间一定是高于无损压缩的，也就是说 JPEG 的压缩时间高于 PNG。而 WebP 无论是无损还是有损压缩，压缩率都分别高于 PNG 和 JPEG；与其相对应的是其压缩时间也比它们长的多。经测试，WebP 图片的编码时间比 JPEG 长 8 倍。可以看出，时间和空间是一对矛盾；如果想要节省更多的空间，必然要付出额外的时间；如果想要节省时间，那么必然要付出空间的代价。这取决于我们在实际中对于时空不同的需求程度来做出选择。<br>不管怎么说，WebP 还是一种强大的、理想的图片压缩格式，并且借由 Google 在网络世界的影响力，WebP 在几年的时间内已经得到了广泛的应用。看看你手机里的 App：微博、微信、QQ、淘宝等等，每个 App 里都有 WebP 的身影。<br>另外，WebP 是 Android4.0 才引入的一种图片压缩格式，如果想要在 Android4.0 以前的版本支持 WebP 格式的图片，那么需要借助于第三方库来支持 WebP 格式图片，例如：<a href="https://github.com/alexey-pelykh/webp-android-backport">webp-android-backport</a>函数库，当然考虑到一般的 Android 开发中只需要向下兼容到 Android4.0 即可，所以也可以忽略这个问题。</li></ul><p>目前来说，以上所述的五种格式，Android 操作系统都提供了原生支持；但是在上层能直接调用的编码方式只有 JPEG、PNG、WebP 这三种。具体的，可以查看 Bitmap 类的枚举内部类 CompressFormat 类的枚举值来获取上层能调用的图片编码方式。你会发现枚举值也是 JPEG、PNG 和 WEBP 三种。<br>如果我们想要在应用层使用 Gif 格式图片，需要自行引入第三方函数库来提供对 Gif 格式图片的支持。不过一般我们用 WebP 取代 Gif。</p></blockquote><h2 id="如何压缩"><a href="#如何压缩" class="headerlink" title="如何压缩"></a>如何压缩</h2><h3 id="压缩分类"><a href="#压缩分类" class="headerlink" title="压缩分类"></a>压缩分类</h3><h4 id="有损压缩"><a href="#有损压缩" class="headerlink" title="有损压缩"></a>有损压缩</h4><blockquote><p>有损压缩的基本依据是：人的眼睛对光线的敏感度远高于对颜色的敏感度，光线对景物的作用比颜色的作用更为重要。有损压缩的原理是：保持颜色的逐渐变化，删除图像中颜色的突然变化。生物学中的大量实验证明，人类大脑会自发地利用与附近最接近的颜色来填补所丢失的颜色。有损压缩的具体实现方法就是删除图像中景物边缘的某些颜色部分。当在屏幕上看这幅图时，大脑会利用在景物上看到的颜色填补所丢失的颜色部分。利用有损压缩技术，某些数据被有意地删除了，并且在图片重新加载至内存中时这些数据也不会还原，因此被称为是“有损”的。有损压缩技术可以灵活地设置压缩率。<br>无可否认，利用有损压缩技术可以在位图持久化存储的过程中大大地压缩图片的存储大小，但是会影响图像质量，这一点在压缩率很高时尤其明显。所以需要选择恰当的压缩率。</p></blockquote><h4 id="无损压缩"><a href="#无损压缩" class="headerlink" title="无损压缩"></a>无损压缩</h4><blockquote><p>无损压缩的基本原理是：相同的颜色信息只需保存一次。具体过程是：首先会确定图像中哪些区域是相同的，哪些是不同的。包括了重复数据的区域就可以被压缩，只需要记录该区域的起始点即可。<br>从本质上看，无损压缩的方法通过删除一些重复数据，也能在位图持久化存储的过程中减少要在磁盘上保存的图片大小。但是，如果将该图片重新读取到内存中，重复数据会被还原。因此，无损压缩的方法并不能减少图片的内存占用量，如果要减少图片占用内存的容量，就必须使用有损压缩方法。<br>无损压缩方法的优点是能够比较好地保存图像的质量，但是相对来说这种方法的压缩率比较低。<br>对比分析：有损压缩压缩率高而且可以灵活设置压缩率，并且删除的数据不可还原，因此可以减少图片的内存占用，但是对图片质量会有一定程度的影响；无损压缩可以很好地保存图片质量，也能保证一定的压缩率虽然没有有损压缩那么高，并且无损压缩删除的数据在重新加载至内存时会被还原，因此不可以减少图片的内存占用。</p></blockquote><h3 id="Android-中压缩"><a href="#Android-中压缩" class="headerlink" title="Android 中压缩"></a>Android 中压缩</h3><h4 id="编译时压缩"><a href="#编译时压缩" class="headerlink" title="编译时压缩"></a>编译时压缩</h4><p>AAPT 打包时默认对 PNG 进行三个优化检查（<a href="http://androidxref.com/">Android 源码</a>中搜索 analyze_image），默认使用的是 libpng 库进行无损压缩（修改色彩模式）：</p><ol><li>每个像素都是 R == G == B (grayscale 灰度)</li><li>每个像素都是 A == 255 (opaque 全透明)</li><li>是否不超过 256 种不同的 RGBA 颜色</li></ol><p>判断它是否可以被转成灰度格式的图片，判断它是否是全透明的，或判断它是否可以被转成一张索引图。</p><p>如果想压缩地更多，禁用掉 AAPT 的默认压缩 PNG（一般二次压缩反而会增大体积），采用第三方压缩工具来提升压缩效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs 禁用AAPT默认PNG处理">android &#123;<br>        buildTypes &#123;<br>            release &#123;<br>                // Disables PNG crunching for the release build type.<br>                crunchPngs false<br>            &#125;<br>        &#125;<br><br>    // If you&#x27;re using an older version (Android Gradle plugin &lt; 3.0.0) of the plugin, use the<br>    // following:<br>    //  aaptOptions &#123;<br>    //      cruncherEnabled false<br>    //  &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第三方工具：</p><ul><li><a href="https://imageoptim.com">ImageOptim</a> 无损压缩</li><li><a href="https://pngmini.com">ImageAlpha</a> 有损压缩</li><li><a href="https://tinypng.com">TinyPNG</a> 有损压缩</li><li><a href="https://pngquant.org/">Pngquant</a> 有损压缩</li><li><a href="http://advsys.net/ken/utils.htm">Pngout</a> 无损压缩</li><li><a href="http://optipng.sourceforge.net/">OptiPNG</a> 无损压缩</li></ul><h4 id="运行时压缩"><a href="#运行时压缩" class="headerlink" title="运行时压缩"></a>运行时压缩</h4><h5 id="质量压缩"><a href="#质量压缩" class="headerlink" title="质量压缩"></a>质量压缩</h5><p>质量压缩在不改变像素的大小的前提下，降低图像的质量（改变图片的位深及透明度等），从而降低存储大小，进而达到压缩的目的。</p><p><strong>质量压缩对内存大小占用无影响。</strong></p><blockquote><p>位深度指的是存储每个像素所用的位数，主要用于存储。<br>色深指的是每一个像素点用多少 bit 存储颜色，属于图片自身的一种属性。<br>位深一般小于或等于色深。<br>举个例子：某张图片 100 像素*100 像素 色深 32 位(ARGB_8888)，保存时位深度为 24 位，那么：<br>该图片在内存中所占大小为：100 x 100 x (32 / 8) Byte<br>在文件中所占大小为 100 x 100 x ( 24/ 8 ) x 压缩率 Byte</p></blockquote><p>Android 中的质量压缩 API ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Android中的质量压缩API">public boolean compress(CompressFormat format, int quality, OutputStream stream)<br></code></pre></td></tr></table></figure><p>Java 层函数 → Native 函数 → Skia 函数 → 对应第三库函数（例如 libjpeg、libpng、libjwebp）</p><ul><li>CompressFormat format：压缩格式,它有 JPEG、PNG、WEBP 三种选择，JPEG 是有损压缩，PNG 是无损压缩，WEBP 是 Google 推出的图像格式.</li><li>int quality：0~100 可选，数值越大，质量越高，图像越大。</li><li>OutputStream stream：压缩后图像的输出流。</li></ul><p>针对 JPEG 的压缩库：</p><ul><li><a href="https://github.com/libjpeg-turbo/libjpeg-turbo">libjpeg-turbo</a></li></ul><blockquote><p>libjpeg-turbo 是用于 x86 和 x86-64 处理器的 libjpeg 的高速版本，它使用 SIMD 指令（MMX，SSE2 等）来加速基线 JPEG 压缩和解压缩。 libjpeg-turbo 的速度通常是未修改版本的 libjpeg 的 2-4 倍，其他所有条件都相同（对于非灰度 JPEG 压缩和解压缩，libjpeg-turbo 的速度是 libjpeg v6b 的 1.8 倍至 4.5 倍）。</p></blockquote><ul><li><a href="https://github.com/mozilla/mozjpeg">mozilla/mozjpeg</a></li></ul><blockquote><p>基于 libjpeg-turbo，依靠三种技术（渐进 JPEG 编码，jpgcrush 和网格量化）来减小 JPEG 图像的大小。libjpeg-turbo 支持渐进式 JPEG，但不支持 jpgcrush 和网格量化。mozjpeg 的唯一目的是减少网络上提供的 JPEG 文件的大小，因此它牺牲了一些性能为代价。</p></blockquote><h5 id="尺寸压缩"><a href="#尺寸压缩" class="headerlink" title="尺寸压缩"></a>尺寸压缩</h5><p>尺寸压缩即减少图片长宽，或者说减少像素点，又称采样压缩（上采样为放大，下采样缩小，因此采样压缩为下采样）。</p><h6 id="邻近采样"><a href="#邻近采样" class="headerlink" title="邻近采样"></a>邻近采样</h6><p>邻近采样（Nearest Neighbour Resampling）采用邻近点插值算法，用一个像素点代替邻近的像素点。</p><p><a href="https://developer.android.com/topic/performance/graphics/load-bitmap?hl=zh-cn">官方高效加载 Bitmap 指南</a>采用的方式就是进行邻近采样。</p><p>做法是先将 BitmapFactory.Options 中的 inJustDecodeBounds 设置为 true，这样 BitmapFactory 在 decode 的时候能避免内存分配，但能对 outWidth，outHeight 和 outMimeType 赋值。然后通过获取到的 outWidth，outHeight 以及 加载的目标宽高计算出合适的采样率赋值给 BitmapFactory.Options 中的 inSamleSize。最后 BitmapFactory.Options 中的 inJustDecodeBounds 设置回 false，并进行相应的 decode。</p><p>关键之处就是计算出合适的采样率，对应 BitmapFactory.Options 中的 inSamleSize（inSamleSize 会是四舍五入后最接近 2 的幂的值）。<br>关于如何计算出合适的采样率，普遍的算法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateInSampleSize</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            BitmapFactory.Options options, <span class="hljs-keyword">int</span> reqWidth, <span class="hljs-keyword">int</span> reqHeight)</span> </span>&#123;<br>    <span class="hljs-comment">// Raw height and width of image</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> height = options.outHeight;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> width = options.outWidth;<br>    <span class="hljs-keyword">int</span> inSampleSize = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (height &gt; reqHeight || width &gt; reqWidth) &#123;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> halfHeight = height / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> halfWidth = width / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// Calculate the largest inSampleSize value that is a power of 2 and keeps both</span><br>        <span class="hljs-comment">// height and width larger than the requested height and width.</span><br>        <span class="hljs-keyword">while</span> ((halfHeight / inSampleSize) &gt;= reqHeight<br>                &amp;&amp; (halfWidth / inSampleSize) &gt;= reqWidth) &#123;<br>            inSampleSize *= <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> inSampleSize;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>第三个开源库<a href="https://github.com/Curzibn/Luban">Luban</a>的<a href="https://github.com/Curzibn/Luban/blob/master/DESCRIPTION.md">计算采样率算法思路</a></p></blockquote><h6 id="双线性采样"><a href="#双线性采样" class="headerlink" title="双线性采样"></a>双线性采样</h6><p>双线性采样（Bilinear Resampling）采用双线性插值算法，相比邻近采样简单粗暴的选择一个像素点代替其他像素点，双线性采样参考源像素相应位置周围 2x2 个点的值，根据相对位置取对应的权重，经过计算得到目标图像。</p><p>Android 中双线性采样有两个 API：</p><ul><li>public static Bitmap createScaledBitmap(@NonNull Bitmap src, int dstWidth, int dstHeight, boolean filter)</li><li>public static Bitmap createBitmap(@NonNull Bitmap source, int x, int y, int width, int height, @Nullable Matrix m, boolean filter)</li></ul><p>事实上，createScaledBitmap(@NonNull Bitmap src, int dstWidth, int dstHeight, boolean filter) 方法最终也是调用 createBitmap(@NonNull Bitmap source, int x, int y, int width, int height, @Nullable Matrix m, boolean filter) 方法。</p><ul><li>Bitmap source：源图像</li><li>int x：目标图像第一个像素的 x 坐标</li><li>int y：目标图像第一个像素的 y 坐标</li><li>int width：目标图像的宽度（像素点个数）</li><li>int height：目标图像的高度（像素点个数）</li><li>Matrix m：变换矩阵</li><li>boolean filter：是否开启双线性滤波</li></ul><h6 id="双立方-双三次采样"><a href="#双立方-双三次采样" class="headerlink" title="双立方/双三次采样"></a>双立方/双三次采样</h6><p><a href="https://en.wikipedia.org/wiki/Bicubic_interpolation">双立方/双三次采样（Bicubic Resampling）</a>，邻近点插值算法的目标像素值由源图上单个像素决定，双线性內插值算法由源像素某点周围 2x2 个像素点按一定权重获得，而双立方／双三次插值算法更进一步参考了源像素某点周围 4x4 个像素。</p><p>Android 中对于双立方/双三次采样没有支持，可以通过手动编写算法或者引用第三方算法库，幸运的是这个算法在 ffmpeg 中已经给到了支持，具体的实现在 libswscale/swscale.c 文件中：<a href="http://www.ffmpeg.org/ffmpeg-scaler.html">FFmpeg Scaler Documentation</a>。</p><h6 id="Lanczos-采样"><a href="#Lanczos-采样" class="headerlink" title="Lanczos 采样"></a>Lanczos 采样</h6><p><a href="https://en.wikipedia.org/wiki/Lanczos_resampling">Lanczos 采样</a>和 Lanczos 过滤是 Lanczos 算法的两种常见应用，它可以用作低通滤波器或者用于平滑地在采样之间插入数字信号，Lanczos 采样一般用来增加数字信号的采样率，或者间隔采样来降低采样率。<br>Lanczos 采样使用的 Lanczos 算法也可以用来作为图片的缩放，Lanczos 算法和双三次插值算法都是使用卷积核来通过输入像素计算输出像素。<br>同样的，Lanczos 算法在 ffmpeg 的 libswscale/swscale.c 中也有实现。其实不光 Lanczos 和上面的三种算法，ffmpeg 还提供了其他的图像重采样方法，诸如 area averaging、Gaussian 等等。</p><h5 id="色彩模式压缩"><a href="#色彩模式压缩" class="headerlink" title="色彩模式压缩"></a>色彩模式压缩</h5><p>BitmapFactory.Options 中 inPreferredConfig 可以指定色彩模式，采用色位更少的色彩模式。</p><hr><p>参考链接：</p><ul><li><a href="https://yunxi.vkucloud.com/article/e53f10f5-0f45-41a3-45dd-08d6f1abedd9">Android Bitmap（位图）详解</a></li><li><a href="https://juejin.im/entry/5ad0213f6fb9a028df2306cd">Android 中 Bitmap 内存优化</a></li><li><a href="https://juejin.im/entry/58fc75e0ac502e0063aa433b">也谈图片压缩</a></li><li><a href="https://juejin.im/post/5a1bd6595188254cc067981f">Android 平台图像压缩方案</a></li><li>QQ 音乐技术文章<a href="https://cloud.tencent.com/developer/article/1006307">Android 中图片压缩分析（上）</a></li><li>QQ 音乐技术文章<a href="https://cloud.tencent.com/developer/article/1006352">Android 中图片压缩分析（下）</a></li><li><a href="https://juejin.im/post/58c3b29761ff4b005d906730#heading-14">Android 性能优化（五）之细说 Bitmap</a></li><li><a href="https://developer.android.com/topic/performance/graphics/load-bitmap.html">Loading Large Bitmaps Efficiently</a></li><li><a href="https://developer.android.google.cn/topic/performance/graphics/cache-bitmap.html">Caching Bitmaps</a></li><li><a href="https://developer.android.com/topic/performance/graphics/manage-memory">Managing Bitmap Memory</a></li><li><a href="https://developer.android.com/topic/performance/graphics">Handling bitmaps</a></li></ul><p>后记：可研读核心类 Bitmap、BitmapFactory。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>图片</tag>
      
      <tag>压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简析BitmapFactory</title>
    <link href="/post/%E7%AE%80%E6%9E%90BitmapFactory/"/>
    <url>/post/%E7%AE%80%E6%9E%90BitmapFactory/</url>
    
    <content type="html"><![CDATA[<p>基于 9.0（29）简析 BitmapFactory 类。</p><p>我们只关注 BitmapFactor 类暴露出来的（即访问权限为 public）东西。</p><ul><li>静态内部类 Options</li><li>若干 decode 方法</li></ul><h2 id="静态内部类-Options"><a href="#静态内部类-Options" class="headerlink" title="静态内部类 Options"></a>静态内部类 Options</h2><p>Options，顾名思义，是 BitmapFactory 用于 decode 方法的选项参数。让我们看看有哪些：</p><h3 id="Bitmap-inBitmap"><a href="#Bitmap-inBitmap" class="headerlink" title="Bitmap inBitmap"></a>Bitmap inBitmap</h3><p>如果使用此参数，decode 方法会在加载内容时尝试重用此 bitmap ，如果编码操作不能使用此 bitmap （有限制条件），则会抛出 java.lang.IllegalArgumentException 异常。当前的重用实现方式要求 bitmap 必须是可变的，并且即使一个资源在 decode 后通常会得到不可变的 bitmap，在重用成功后所得到的重用 bitmap 也将保持可变性。任何可变的 bitmap 都可以被 BitmapFactory 重用，以解码任何其他 bitmap，只要解码后的 bitmap （待分配内存）的字节数（getByteCount 方法，解码后待分配内存状态的大小）小于或等于分配的字节数（getAllocationByteCount 方法，占用内存的实际大小）。这可能是因为待分配内存的 bitmap 固有尺寸较小，或者其缩放后的尺寸（对于密度/样本尺寸）较小。</p><p>在 android.os.Build.VERSION_CODES.KITKAT（Android4.4，19）之前，使用有更多限制：</p><ul><li>解码的图像（无论是作为资源还是作为流）必须为 jpeg 或 png 格式。</li><li>仅支持大小相等的 bitmap，并且 inSampleSize 设置为 1。</li><li>另外，重用 bitmap 的 Bitmap.Config 配置 inPreferredConfig 将被覆盖（如果已设置）。</li></ul><p>BitmapRegionDecoder 会将其请求的内容绘制到提供的 bitmap 中，如果输出内容大小（缩放后）大于提供的 bitmap ，则进行裁剪。提供的 bitmap 的宽度，高度和 Bitmap.Config 不会更改。<br>android.os.Build.VERSION_CODES.JELLY_BEAN（Android 4.1，16）中引入了对 inBitmap 的 BitmapRegionDecoder 支持。 BitmapRegionDecoder 支持的所有格式 通过 inBitmap 支持 bitmap 重用。</p><h3 id="boolean-inMutable"><a href="#boolean-inMutable" class="headerlink" title="boolean inMutable"></a>boolean inMutable</h3><p>在 native 代码中使用。</p><p>如果开启该设置，则 decode 方法将始终返回可变的 bitmap。这可以用于以编程方式将效果应用于通过 BitmapFactory 加载的 Bitmap。不能与 inPreferredConfig = Bitmap.Config.HARDWARE 同时设置，因为硬件 bitmap 始终是不可变的。</p><h3 id="boolean-inJustDecodeBounds"><a href="#boolean-inJustDecodeBounds" class="headerlink" title="boolean inJustDecodeBounds"></a>boolean inJustDecodeBounds</h3><p>如果开启该设置， 解码器将会返回 null （不返回 bitmap ），但是 out… 字段（如 outWidth 、 outHeight 、 outMimeType ）会被赋值，从而允许调用者查询 bitmap ，而不必为其像素分配内存。</p><h3 id="int-inSampleSize"><a href="#int-inSampleSize" class="headerlink" title="int inSampleSize"></a>int inSampleSize</h3><p>如果设置的值大于 1，将会请求解码器对原始图像进行二次采样，返回较小的图像以节省内存。样本大小是任一维度中与已解码 bitmap 中单个像素对应的像素数。例如，设置 inSampleSize == 4 ，将会返回一张是宽高为原始宽度和高度的 1/4 的图像，像素为原来的 1/16。任何小于等于 1 的值都与 1 相同。注意：解码器使用基于 2 的幂的最终值，任何其他值将四舍五入为最接近的 2 的幂。</p><h3 id="Bitmap-Config-inPreferredConfig"><a href="#Bitmap-Config-inPreferredConfig" class="headerlink" title="Bitmap.Config inPreferredConfig"></a>Bitmap.Config inPreferredConfig</h3><p>如果该配置不为 null ，解码器将会尝试解析 bitmap 成此内部配置（bitmap 的像素存储方式）。如果该配置为 null，或者无法满足要求，解码器将会基于系统屏幕深度和原始图像的特征（如是否有每像素透明度）来选择最合适的配置（要求该配置也满足要求）。</p><p>图像默认以 Bitmap.Config.ARGB_8888 的配置加载。</p><h3 id="ColorSpace-inPreferredColorSpace"><a href="#ColorSpace-inPreferredColorSpace" class="headerlink" title="ColorSpace inPreferredColorSpace"></a>ColorSpace inPreferredColorSpace</h3><p>如果改配置不为 null ，则解码器将尝试解码 bitmap 到此颜色空间中。如果该配置为 null ，或者无法满足要求，则解码器将选择嵌在图像的颜色空间或最适合请求的图像配置的颜色空间（例如，ColorSpace.Named.SRGB 对应 Bitmap.Config.ARGB_8888 ; ColorSpace.Named.EXTENDED_SRGB 对应 Bitmap.Config.RGBA_F16）。</p><p>目前只支持 ColorSpace.Model.RGB 颜色空间，如果设置了非 RGB 颜色空间（例如 ColorSpace.Named.CIE_LAB）， decode 方法将会抛出异常（IllegalArgumentException）。</p><p>指定的色彩空间的传递函数必须是 ColorSpace.Rgb.TransferParameters() ICC 参数曲线。如果在指定的色彩空间调用方法 ColorSpace.Rgb.getTransferParameters() 返回 null ， decode 方法将会抛出异常（IllegalArgumentException）。</p><p>解码之后，bitmap 的色彩空间存储在 BitmapFactory.Options.outColorSpace 字段。</p><h3 id="boolean-inPremultiplied"><a href="#boolean-inPremultiplied" class="headerlink" title="boolean inPremultiplied"></a>boolean inPremultiplied</h3><p>如果开启此配置（默认开启），则生成的 bitmap 的颜色通道将被 alpha 通道预乘。</p><p>由视图系统或通过 Canvas 直接绘制的图像，不应将其设置为 false。视图系统和 Canvas 假定所有绘制的图像都已预乘以简化绘制时融合，并且在绘制未预乘时将抛出 RuntimeException 。</p><p>仅当您要处理原始编码的图像数据（例如，使用 RenderScript 或自定义 OpenGL）时才是合适的。</p><p>不会影响没有 Alpha 通道的 bitmap 。</p><p>将 inScaled 设置为 true 时将此标志设置为 false 可能会导致颜色错误。</p><h3 id="boolean-inDither"><a href="#boolean-inDither" class="headerlink" title="boolean inDither"></a>boolean inDither</h3><p>@deprecated 自 android.os.Build.VERSION_CODES.N （Android7.0，24）起，此配置被忽略。</p><p>在 android.os.Build.VERSION_CODES.M (Android6.0，23)及以下版本中，如果设置为 true，则解码器将尝试对解码的图像进行抖动。</p><h3 id="int-inDensity"><a href="#int-inDensity" class="headerlink" title="int inDensity"></a>int inDensity</h3><p>用于 bitmap 像素密度。这将使得在返回的位图中始终有为其设置的密度（请参阅 Bitmap.setDensity(int)）。此外，如果开启了 inScaled（默认情况下开启），并且此密度与 inTargetDensity 不匹配，则 bitmap 在返回之前将被缩放为目标密度。</p><p>如果设置为 0， BitmapFactory.decodeResource(Resources, int) 、 BitmapFactory.decodeResource(Resources, int, android.graphics.BitmapFactory.Options) 、 BitmapFactory.decodeResourceStream 这些 decode 方法将填充与资源关联的密度。其他 decode 方法将保持原样，并且不会应用任何密度。</p><h3 id="int-inTargetDensity"><a href="#int-inTargetDensity" class="headerlink" title="int inTargetDensity"></a>int inTargetDensity</h3><p>此 bitmap 将被绘制到的目标像素密度。 与 inDensity 和 inScaled 结合使用，以确定在返回 bitmap 之前是否以及如何缩放位图。</p><p>如果设置为 0， BitmapFactory.decodeResource(Resources, int) 、 BitmapFactory.decodeResource(Resources, int, android.graphics.BitmapFactory.Options) 、 BitmapFactory.decodeResourceStream 这些 decode 方法将填充与资源对象的 DisplayMetrics 相关的密度。其他 decode 方法将保持原样，并且不会对密度进行缩放。</p><h3 id="int-inScreenDensity"><a href="#int-inScreenDensity" class="headerlink" title="int inScreenDensity"></a>int inScreenDensity</h3><p>正在使用的实际屏幕的像素密度。 仅用于以密度兼容代码运行的应用程序，其中 inTargetDensity 实际上是应用程序看到的密度而不是实际的屏幕密度。</p><p>通过设置此选项，允许加载代码避免将当前的屏幕密度的 bitmap 缩放到/降低到兼容密度。相反的，如果 inDensity 与 inScreenDensity 相同，则 bitmap 将保持不变。任何使用生成的 bitmap 的对象，还必须使用 Bitmap.getScaledWidth 和 Bitmap.getScaledHeight 来说明 bitmap 的密度与目标密度之间的任何差异。</p><p>BitmapFactory 自身永远不会为调用者自动设置。必须明确设置它，因为调用者必须以密度感知的方式处理结果位图。</p><h3 id="boolean-inScaled"><a href="#boolean-inScaled" class="headerlink" title="boolean inScaled"></a>boolean inScaled</h3><p>如果设置了该配置，并且 inDensity 和 inTargetDensity 不为 0，bitmap 在加载时将缩放以匹配 inTargetDensity，而不是每次绘制到 Canvas 时都依赖于图形系统对其进行缩放。</p><p>BitmapRegionDecoder 会忽略这个配置，并且不会根据密度缩放输出。（尽管支持 inSampleSize ）</p><p>此配置默认开启，如果需要 bitmap 的非缩放版本，则应将其关闭。.9 bitmaps（Nine-patch bitmaps）会忽略此配置，并且始终会缩放。</p><p>如果 inPremultiplied 设置为 false ，并且图像具有 Alpha 透明度，将此配置设置为 true 可能会导致颜色错误。</p><h3 id="boolean-inPurgeable"><a href="#boolean-inPurgeable" class="headerlink" title="boolean inPurgeable"></a>boolean inPurgeable</h3><p>@deprecated 自 android.os.Build.VERSION_CODES.LOLLIPOP（Android5.0，21） 起，此配置被忽略。</p><p>在 android.os.Build.VERSION_CODES.KITKAT（Android4.4，19）及以下版本中，如果将此配置设置为 true ，那么生成的 bitmap 将分配其像素，以便在系统需要回收内存时可以将其清除。在那种情况下，当需要再次访问像素时（例如绘制 bitmap，调用 getPixels（）），它们将被自动重新解码。</p><p>为了进行重新解码，bitmap 必须通过共享对输入的引用或对其进行复制来访问编码的数据。此区别由 inInputShareable 控制。如果 inInputShareable 为 true，则 bitmap 可能会保留对输入的浅引用。如果这 inInputShareable 为 false，则 bitmap 将显式地复制输入数据，并将其保留。即使允许共享，实现仍可以决定对输入数据进行深拷贝。</p><p>尽管 inPurgeable 可以帮助避免大的 Dalvik 堆分配（从 API 级别 11 开始），但是它牺牲了性能可预测性，因为视图系统尝试绘制的任何图像都可能会导致解码延迟，从而导致帧丢失。因此，大多数应用应避免使用 inPurgeable 来提供快速流畅的 UI。为了最小化 Dalvik 堆分配，请使用 inBitmap 配置。</p><p>该配置会被 decodeResource(Resources, int, android.graphics.BitmapFactory.Options) 或者 decodeFile(String,<br>android.graphics.BitmapFactory.Options)</p><h3 id="boolean-inInputShareable"><a href="#boolean-inInputShareable" class="headerlink" title="boolean inInputShareable"></a>boolean inInputShareable</h3><p>@deprecated 自 android.os.Build.VERSION_CODES.LOLLIPOP（Android5.0，21） 起，此配置被忽略。</p><p>在 android.os.Build.VERSION_CODES.KITKAT（Android4.4，19）及以下版本中，此配置与 inPurgeable 结合使用。如果 inPurgeable 为 false ，则会忽略此字段。如果 inPurgeable 为 true ，则配置确定 bitmap 是否可以共享对输数据（inputstream，数组等）的引用，或者是否必须进行深拷贝。</p><h3 id="boolean-inPreferQualityOverSpeed"><a href="#boolean-inPreferQualityOverSpeed" class="headerlink" title="boolean inPreferQualityOverSpeed"></a>boolean inPreferQualityOverSpeed</h3><p>@deprecated 自 android.os.Build.VERSION_CODE.N （Android7.0，24）起，此配置被忽略。输出将始终是高质量的。</p><p>在 android.os.Build.VERSION_CODES.M (Android6.0，23)及以下版本中，如果将 inPreferQualityOverSpeed 设置为 true ，则解码器将尝试以牺牲解码速度为代价，将重构图像解码为更高质量的图像。当前该字段仅影响 JPEG 解码，在这种情况下，将使用更准确但稍慢的 IDCT 方法代替。</p><h3 id="int-outWidth"><a href="#int-outWidth" class="headerlink" title="int outWidth"></a>int outWidth</h3><p>bitmap 的解码结果宽度。如果 inJustDecodeBounds 设置为 false，这将是应用所有缩放后输出 bitmap 的宽度。如果为 true，它将是输入图像的宽度，不考虑缩放。</p><p>如果尝试解码时发生错误，outWidth 将设置为-1。</p><h3 id="int-outHeight"><a href="#int-outHeight" class="headerlink" title="int outHeight"></a>int outHeight</h3><p>bitmap 的解码结果高度。如果 inJustDecodeBounds 设置为 false，这将是应用所有缩放后输出 bitmap 的高度。如果为 true，它将是输入图像的高度，不考虑缩放。</p><p>如果尝试解码时发生错误，outHeight 将设置为-1。</p><h3 id="String-outMimeType"><a href="#String-outMimeType" class="headerlink" title="String outMimeType"></a>String outMimeType</h3><p>如果明确，则将该字符串设置为解码图像的媒体类型。 如果未知或有错误，则将其设置为 null 。</p><h3 id="Bitmap-Config-outConfig"><a href="#Bitmap-Config-outConfig" class="headerlink" title="Bitmap.Config outConfig"></a>Bitmap.Config outConfig</h3><p>如果明确，为解码 bitmap 具有的像素存储方式配置。 如果未知或有错误，则将其设置为 null 。</p><h3 id="ColorSpace-outColorSpace"><a href="#ColorSpace-outColorSpace" class="headerlink" title="ColorSpace outColorSpace"></a>ColorSpace outColorSpace</h3><p>如果明确，为解码后的 bitmap 具有的色彩空间。注意，输出颜色空间不保证是 bitmap 编码的颜色空间。如果未知（例如，配置为 Bitmap.Config.ALPHA_8）或存在错误，则将其设置为 null 。</p><h3 id="byte-inTempStorage"><a href="#byte-inTempStorage" class="headerlink" title="byte[] inTempStorage"></a>byte[] inTempStorage</h3><p>用于解码的临时存储。建议 16K 左右。</p><h3 id="boolean-mCancel"><a href="#boolean-mCancel" class="headerlink" title="boolean mCancel"></a>boolean mCancel</h3><p>@deprecated 自 android.os.Build.VERSION_CODES.N （Android7.0，24）起。</p><p>指示已在此对象上调用 cancel 的标志。如果有一个中间人想要首先解码边界然后解码图像，则此配置很有用。在那种情况下，中间人可以在边界解码和图像解码之间检查是否取消了该操作。</p><h3 id="public-void-requestCancelDecode"><a href="#public-void-requestCancelDecode" class="headerlink" title="public void requestCancelDecode()"></a>public void requestCancelDecode()</h3><p>@deprecated 自 android.os.Build.VERSION_CODES.N （Android7.0，24）起，不影响解码，尽管设置了 mCancel 的值为 true。</p><p>在 android.os.Build.VERSION_CODES.M (Android6.0，23)及以下版本。调用此命令将通知解码器应该取消其操作。这不能保证取消解码，但是如果成功取消解码，则解码器操作结果将返回 null ，或者如果 inJustDecodeBounds 为 true ，则将 outWidth / outHeight 设置为-1。</p><h2 id="decode-方法"><a href="#decode-方法" class="headerlink" title="decode 方法"></a>decode 方法</h2><h3 id="decode-方法简析"><a href="#decode-方法简析" class="headerlink" title="decode 方法简析"></a>decode 方法简析</h3><h4 id="Bitmap-decodeFile-String-pathName-Options-opts"><a href="#Bitmap-decodeFile-String-pathName-Options-opts" class="headerlink" title="Bitmap decodeFile(String pathName, Options opts)"></a>Bitmap decodeFile(String pathName, Options opts)</h4><p>将文件路径解码为 bitmap 。如果指定的文件名为 null ，或无法解码为 bitmap，则该函数返回 null 。</p><ul><li>String pathName：待解码文件的完整路径名</li><li>Options opts：控制下采样以及是否应完全解码图像或仅返回尺寸的选项参数，可为 null。</li></ul><p>实际内部调用了另外一个 decode 方法：<br>Bitmap decodeStream(@Nullable InputStream is, @Nullable Rect outPadding, @Nullable Options opts)<br>（参数 String pathName -&gt; InputStream is, Rect null , Options opts）</p><h4 id="Bitmap-decodeFile-String-pathName"><a href="#Bitmap-decodeFile-String-pathName" class="headerlink" title="Bitmap decodeFile(String pathName)"></a>Bitmap decodeFile(String pathName)</h4><p>重载 Bitmap decodeFile(String pathName, Options opts)</p><p>decodeFile(pathName, null);</p><h4 id="Bitmap-decodeResourceStream-Nullable-Resources-res-Nullable-TypedValue-value-Nullable-InputStream-is-Nullable-Rect-pad-Nullable-Options-opts"><a href="#Bitmap-decodeResourceStream-Nullable-Resources-res-Nullable-TypedValue-value-Nullable-InputStream-is-Nullable-Rect-pad-Nullable-Options-opts" class="headerlink" title="Bitmap decodeResourceStream(@Nullable Resources res, @Nullable TypedValue value, @Nullable InputStream is, @Nullable Rect pad, @Nullable Options opts)"></a>Bitmap decodeResourceStream(@Nullable Resources res, @Nullable TypedValue value, @Nullable InputStream is, @Nullable Rect pad, @Nullable Options opts)</h4><p>从 InputStream 解码新的 bitmap 。此 InputStream 是从资源获得的，我们通过传递这些资源可以相应地缩放位图。</p><h4 id="Bitmap-decodeResource-Resources-res-int-id-Options-opts"><a href="#Bitmap-decodeResource-Resources-res-int-id-Options-opts" class="headerlink" title="Bitmap decodeResource(Resources res, int id, Options opts)"></a>Bitmap decodeResource(Resources res, int id, Options opts)</h4><p>打开给定的资源并且调用 decodeResourceStream 方法的代名词。</p><ul><li>Resources res：包含图像数据的资源对象。</li><li>int id：图像数据的资源 ID。</li><li>Options opts：控制下采样以及是否应完全解码图像或仅返回尺寸的选项参数，可为 null。</li></ul><p>实际内部调用了另外一个 decode 方法：<br>decodeResourceStream(@Nullable Resources res, @Nullable TypedValue value, @Nullable InputStream is, @Nullable Rect pad, @Nullable Options opts)<br>（参数 Resources res, TypedValue value = new TypedValue(), InputStream res.openRawResource(id, value), Rect null, Options opts）</p><h4 id="Bitmap-decodeResource-Resources-res-int-id"><a href="#Bitmap-decodeResource-Resources-res-int-id" class="headerlink" title="Bitmap decodeResource(Resources res, int id)"></a>Bitmap decodeResource(Resources res, int id)</h4><p>重载 Bitmap decodeResource(Resources res, int id, Options opts)</p><p>decodeResource(res, id, null);</p><h4 id="Bitmap-decodeByteArray-byte-data-int-offset-int-length-Options-opts"><a href="#Bitmap-decodeByteArray-byte-data-int-offset-int-length-Options-opts" class="headerlink" title="Bitmap decodeByteArray(byte[] data, int offset, int length, Options opts)"></a>Bitmap decodeByteArray(byte[] data, int offset, int length, Options opts)</h4><p>从指定的字节数组解码不可变的 bitmap。</p><ul><li>byte[] data：压缩图像数据的字节数组。</li><li>int offset：解码器应开始解析的 imageData 的偏移量。</li><li>int length：从偏移量开始解析的字节数。</li><li>Options opts：控制下采样以及是否应完全解码图像或仅返回尺寸的选项参数，可为 null。</li></ul><p>调用 native 解码方法：<br>private static native Bitmap nativeDecodeByteArray(byte[] data, int offset, int length, Options opts, long inBitmapHandle, long colorSpaceHandle)</p><h4 id="Bitmap-decodeByteArray-byte-data-int-offset-int-length"><a href="#Bitmap-decodeByteArray-byte-data-int-offset-int-length" class="headerlink" title="Bitmap decodeByteArray(byte[] data, int offset, int length)"></a>Bitmap decodeByteArray(byte[] data, int offset, int length)</h4><p>重载 Bitmap decodeByteArray(byte[] data, int offset, int length, Options opts)</p><p>decodeByteArray(data, offset, length, null);</p><h4 id="Bitmap-decodeStream-Nullable-InputStream-is-Nullable-Rect-outPadding-Nullable-Options-opts"><a href="#Bitmap-decodeStream-Nullable-InputStream-is-Nullable-Rect-outPadding-Nullable-Options-opts" class="headerlink" title="Bitmap decodeStream(@Nullable InputStream is, @Nullable Rect outPadding, @Nullable Options opts)"></a>Bitmap decodeStream(@Nullable InputStream is, @Nullable Rect outPadding, @Nullable Options opts)</h4><p>将输入流解码为 bitmap 。如果输入流为 null ，或者不能用于解码 bitmap ，则该函数返回 null 。 流的位置将是读取编码数据之后的位置。</p><ul><li>InputStream is：输入流，其中包含要解码为 bitmap 的原始数据。</li><li>Rect outPadding：如果不为 null ，则返回 bitmap 的填充矩形（如果存在），否则将填充设置为[-1，-1，-1，-1]。如果没有 bitmap 返回（ null ），则填充是不变的。</li><li>Options opts：控制下采样以及是否应完全解码图像或仅返回尺寸的选项参数，可为 null。</li></ul><p>如果输入流是 AssetManager.AssetInputStrea，调用 native 解码方法：<br>private static native Bitmap nativeDecodeAsset(long nativeAsset, Rect padding, Options opts,<br>long inBitmapHandle, long colorSpaceHandle)<br>否则调用私有内部方法：<br>Bitmap decodeStreamInternal(@NonNull InputStream is, @Nullable Rect outPadding, @Nullable Options opts)</p><h4 id="decodeStream-InputStream-is"><a href="#decodeStream-InputStream-is" class="headerlink" title="decodeStream(InputStream is)"></a>decodeStream(InputStream is)</h4><p>重载 Bitmap decodeStream(@Nullable InputStream is, @Nullable Rect outPadding, @Nullable Options opts)</p><p>decodeStream(is, null, null);</p><h4 id="Bitmap-decodeFileDescriptor-FileDescriptor-fd-Rect-outPadding-Options-opts"><a href="#Bitmap-decodeFileDescriptor-FileDescriptor-fd-Rect-outPadding-Options-opts" class="headerlink" title="Bitmap decodeFileDescriptor(FileDescriptor fd, Rect outPadding, Options opts)"></a>Bitmap decodeFileDescriptor(FileDescriptor fd, Rect outPadding, Options opts)</h4><p>从文件描述符解码 bitmap 。如果 bitmap 无法解码返回 null 。当返回时，描述符中的位置不会更改，因此可以按原样再次使用描述符。</p><ul><li>FileDescriptor fd：包含要解码的 bitmap 数据的文件描述符。</li><li>Rect outPadding：如果不为 null ，则返回 bitmap 的填充矩形（如果存在），否则将填充设置为[-1，-1，-1，-1]。如果没有 bitmap 返回（ null ），则填充是不变的。</li><li>Options opts：控制下采样以及是否应完全解码图像或仅返回尺寸的选项参数，可为 null。</li></ul><h4 id="Bitmap-decodeFileDescriptor-FileDescriptor-fd"><a href="#Bitmap-decodeFileDescriptor-FileDescriptor-fd" class="headerlink" title="Bitmap decodeFileDescriptor(FileDescriptor fd)"></a>Bitmap decodeFileDescriptor(FileDescriptor fd)</h4><p>重载 Bitmap decodeFileDescriptor(FileDescriptor fd, Rect outPadding, Options opts)</p><p>decodeFileDescriptor(fd, null, null);</p><h3 id="decode-方法总结"><a href="#decode-方法总结" class="headerlink" title="decode 方法总结"></a>decode 方法总结</h3><p>所有的 decode 方法最后都会走下面三个 decode 方法：</p><p>Bitmap decodeStream(@Nullable InputStream is, @Nullable Rect outPadding, @Nullable Options opts)</p><p>Bitmap decodeByteArray(byte[] data, int offset, int length, Options opts)</p><p>Bitmap decodeFileDescriptor(FileDescriptor fd, Rect outPadding, Options opts)</p><p>其中 decodeStream 和 decodeFileDescriptor 方法 有可能走以下这个方法：</p><p>Bitmap decodeStreamInternal(@NonNull InputStream is, @Nullable Rect outPadding, @Nullable Options opts)</p><p>实质是调用了 native 解码方法：<br>Bitmap nativeDecodeStream(InputStream is, byte[] storage, Rect padding, Options opts, long inBitmapHandle, long colorSpaceHandle)</p><p>因此 native 以下四个方法是 decode 的最终归宿：</p><ul><li>private static native Bitmap nativeDecodeStream(InputStream is, byte[] storage, Rect padding, Options opts, long inBitmapHandle, long colorSpaceHandle);</li><li>private static native Bitmap nativeDecodeFileDescriptor(FileDescriptor fd, Rect padding, Options opts, long inBitmapHandle, long colorSpaceHandle);</li><li>private static native Bitmap nativeDecodeAsset(long nativeAsset, Rect padding, Options opts, long inBitmapHandle, long colorSpaceHandle);</li><li>private static native Bitmap nativeDecodeByteArray(byte[] data, int offset, int length, Options opts, long inBitmapHandle, long colorSpaceHandle);</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>图片</tag>
      
      <tag>Bitmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板整理之上传仓库</title>
    <link href="/post/%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86%E4%B9%8B%E4%B8%8A%E4%BC%A0%E4%BB%93%E5%BA%93/"/>
    <url>/post/%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86%E4%B9%8B%E4%B8%8A%E4%BC%A0%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>我们在日常打 aar 包和 jar 包，并上传到远端中央仓库时，需要引入大段 gradle 代码，较为繁琐。<br>我这里整理了常用的上传到中央仓库的 gradle 代码，提供了较为方便的使用方式。<a href="">上传代码模板 GitHub</a><br>目前只有上传到 bintray 也就是 jcenter 的整理，后期有需要其他远端中央仓库的会继续跟进。</p><hr><ul><li>模板整理<a href="https://github.com/CodePoem/VTemplate">GitHub</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>模板</tag>
      
      <tag>上传仓库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板整理之Travis CI</title>
    <link href="/post/%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86%E4%B9%8BTravis%20CI/"/>
    <url>/post/%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86%E4%B9%8BTravis%20CI/</url>
    
    <content type="html"><![CDATA[<p><a href="https://docs.travis-ci.com/">官方文档</a></p><p>免费 Travis-CI（针对开源项目）：<a href="https://travis-ci.org">https://travis-ci.org</a></p><p>收费 Travis-CI（针对私有和商业项目）：<a href="https://travis-ci.com">https://travis-ci.com</a></p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li>登录 Travis CI 并对指定的项目启用。</li><li>配置 .travis.yml ，参考官方文档。</li><li>push（或其他方式）触发 Travis-CI。</li></ol><h2 id="实现工作流"><a href="#实现工作流" class="headerlink" title="实现工作流"></a>实现工作流</h2><ol><li>构建。开发一些新功能，提交代码后自动构建出一个 APK（可以是测试版，也可以是发布版）。</li><li>部署。将 APK 上传到 Github Release / <a href="https://fir.im/">Fir.im</a> / <a href="https://www.pgyer.com/">蒲公英</a>等。</li><li>通知。发出通知（邮件、消息等形式）。</li></ol><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><h4 id="release-签名证书安全"><a href="#release-签名证书安全" class="headerlink" title="release 签名证书安全"></a>release 签名证书安全</h4><p>Android 项目发布需要证书文件、密码、别名、别名密码。无论是开源项目还是私有项目，任何时候都不应该将原始证书或密码放入代码库（原则上来讲证书和密码也不应该交于开发人员，而应该只能通过发布服务器进行编译）</p><p>Travis CI 为此提供了 2 种解决方案：</p><ol><li>对敏感信息、密码、证书等进行对称加密，在 CI 构建环境时解密。</li><li>将密码等通过 Travis CI 控制台设置为构建时的环境变量。</li></ol><p>个人倾向使用第二种方案，但 Travis CI 控制台无法上传文件，因此涉及到文件加密的部分，选择第一种方案。</p><h5 id="加密证书文件："><a href="#加密证书文件：" class="headerlink" title="加密证书文件："></a>加密证书文件：</h5><ol><li>本地安装 Travis CLI 命令行工具。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gem install travis<br></code></pre></td></tr></table></figure><p>这一步如果遇到错误, 尝试加 sudo，请升级一下 ruby 版本。</p><ol start="2"><li>命令行登录 Travis（第一次登录才要），并输入 GitHub 的用户名和密码。</li></ol><p>针对免费版 <a href="https://travis-ci.org：">https://travis-ci.org：</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">travis login --org<br></code></pre></td></tr></table></figure><p>针对收费版 Travis-C <a href="https://travis-ci.com：">https://travis-ci.com：</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">travis login --pro<br></code></pre></td></tr></table></figure><p>这一步如果遇到 travis 命令找不到, 尝试找到 travis 安装的 bin 目录，并配置上环境变量。</p><ol start="3"><li>进入项目根目录，加密证书。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">travis encrypt-file XXX.jks --add<br></code></pre></td></tr></table></figure><p>命令执行结果：</p><ol><li>在 Travis CI 控制台自动生成一对秘钥。</li><li>基于秘钥通过 openssl 对文件进行加密，并在根目录生成 XXX.jks.enc 文件。</li><li>在 .travis.yml 中自动生成 Travis CI 环境下解密文件的配置。</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">before_install:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">openssl</span> <span class="hljs-string">aes-256-cbc</span> <span class="hljs-string">-K</span> <span class="hljs-string">$encrypted_cd91ae131fae_key</span> <span class="hljs-string">-iv</span> <span class="hljs-string">$encrypted_cd91ae131fae_iv</span><br>    <span class="hljs-string">-in</span> <span class="hljs-string">mrd@vdreamers.enc</span> <span class="hljs-string">-out</span> <span class="hljs-string">mrd@vdreamers</span> <span class="hljs-string">-d</span><br></code></pre></td></tr></table></figure><h5 id="加密证书密码"><a href="#加密证书密码" class="headerlink" title="加密证书密码"></a>加密证书密码</h5><p>在 Travis CI 控制台配置证书密码、证书别名、证书别名密码三个环境变量（KEYSTORE_PWD、KEYSTORE_ALIAS、KEYSTORE_ALIAS_PWD）。</p><h5 id="实现本地和-Travis-CI-构建-release-包互不干扰"><a href="#实现本地和-Travis-CI-构建-release-包互不干扰" class="headerlink" title="实现本地和 Travis-CI 构建 release 包互不干扰"></a>实现本地和 Travis-CI 构建 release 包互不干扰</h5><p>基本思路，判断环境变量 CI 是否 为 true，通过 System.getenv(“CI”) 去获取环境变量 CI 的值，fals e 即为本地构建，true 即为 Travis-CI 构建。<br>本地构建去 local.properties 中读取证书配置；Travis-CI 构建通过 System.getenv 去读取环境变量的证书配置。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs gradle">apply plugin: <span class="hljs-string">&#x27;com.android.application&#x27;</span><br><br><span class="hljs-keyword">def</span> keystorePWD = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">def</span> keystoreAlias = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">def</span> keystoreAliasPWD = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-comment">// local.properties file in the root director</span><br><span class="hljs-keyword">def</span> keyFile = <span class="hljs-keyword">project</span>.rootProject.<span class="hljs-keyword">file</span>(<span class="hljs-string">&#x27;local.properties&#x27;</span>)<br><br>Properties properties = <span class="hljs-keyword">new</span> Properties()<br><span class="hljs-comment">// local.properties exists</span><br><span class="hljs-keyword">if</span> (keyFile.exists()) &#123;<br>    properties.load(keyFile.newDataInputStream())<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    keyFile = <span class="hljs-keyword">file</span>(<span class="hljs-string">&quot;../no_exists_keystore.tmp&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// local.properties contains keystore.path</span><br><span class="hljs-keyword">if</span> (properties.containsKey(<span class="hljs-string">&quot;keystore.path&quot;</span>)) &#123;<br>    keyFile = <span class="hljs-keyword">file</span>(properties.getProperty(<span class="hljs-string">&quot;keystore.path&quot;</span>))<br>    keystorePWD = properties.getProperty(<span class="hljs-string">&quot;keystore.password&quot;</span>)<br>    keystoreAlias = properties.getProperty(<span class="hljs-string">&quot;keystore.alias&quot;</span>)<br>    keystoreAliasPWD = properties.getProperty(<span class="hljs-string">&quot;keystore.alias_password&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    keyFile = <span class="hljs-keyword">file</span>(<span class="hljs-string">&quot;../no_exists_keystore.tmp&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">def</span> isRunningOnTravis = System.getenv(<span class="hljs-string">&quot;CI&quot;</span>) == <span class="hljs-string">&quot;true&quot;</span><br><span class="hljs-keyword">if</span> (isRunningOnTravis) &#123;<br>    keyFile = <span class="hljs-keyword">file</span>(<span class="hljs-string">&quot;../mrd@vdreamers&quot;</span>)<br>    keystorePWD = System.getenv(<span class="hljs-string">&quot;KEYSTORE_PWD&quot;</span>)<br>    keystoreAlias = System.getenv(<span class="hljs-string">&quot;KEYSTORE_ALIAS&quot;</span>)<br>    keystoreAliasPWD = System.getenv(<span class="hljs-string">&quot;KEYSTORE_ALIAS_PWD&quot;</span>)<br>&#125;<br><br>android &#123;<br>    signingConfigs &#123;<br>        release &#123;<br>            keyAlias keystoreAlias<br>            keyPassword keystoreAliasPWD<br>            storeFile keyFile<br>            storePassword keystorePWD<br>        &#125;<br>    &#125;<br>    buildTypes &#123;<br>        debug &#123;<br>            minifyEnabled <span class="hljs-keyword">false</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>            signingConfig signingConfigs.debug<br>        &#125;<br>        release &#123;<br>            minifyEnabled <span class="hljs-keyword">false</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>            <span class="hljs-keyword">if</span> (keyFile.exists() || isRunningOnTravis) &#123;<br>                <span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;WITH -&gt; buildTypes -&gt; release: using jks key&quot;</span>)<br>                signingConfig signingConfigs.release<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;WITH -&gt; buildTypes -&gt; release: using default key&quot;</span>)<br>                signingConfig signingConfigs.debug<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本地构建需要在本地 local.properties 中配置好证书路径 keystore.path、证书密码 keystore.password、证书别名 keystore.alias、证书别名密码 keystore.alias_password；<br>分别对应着 Travis CI 控制台加密的证书秘钥对和环境变量证书密码 KEYSTORE_PWD、证书别名 KEYSTORE_ALIAS、证书别名密码 KEYSTORE_ALIAS_PWD。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="GitHub-Release"><a href="#GitHub-Release" class="headerlink" title="GitHub Release"></a>GitHub Release</h4><ol><li>命令行自动生成 deploy 配置。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">travis setup releases<br></code></pre></td></tr></table></figure><p>需要输入 GitHub 账户名和密码以及 apk 路径，如 app/build/outputs/apk/app-release.apk<br>执行完后会自动在 .travis.yml 添加如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">provider:</span> <span class="hljs-string">releases</span><br>  <span class="hljs-attr">api_key:</span><br>    <span class="hljs-attr">secure:</span> <span class="hljs-string">qOr4mGdf8lESDCiMo7ZJbGqLEHI3cXuV4UlQ2ZzvjSpDQyXrQ2l8wHMdgTkFxmlJWReOUuumHK346StBlGA2mQ5ufc6LhtHaCJWNpnk2Nixd2qFma9ySgPakz+7NoMml4wvkgMnn4HBCTV13ucJPxEzVt8KkX1JAiN9s5rh8SkB36i9KC4i/SuAPNPx2vHbglnoPFtToBlQa+cMLRSlXVkLHYYVdWRZOBRneu/H79oPkw5ajfsSG5u7RCCcEaaAfY1oU7ho1mrB1Kogq64BemGZSkIHgF5TCmmWgNypDlAm92tCN0G3uP0xffUZZsUqYoHiflXTjyXoYG4gXXC+SCCmkkFah0DZPcTZ6AHerBJ/8YgJX6/8tV3sH89PuM6HEuPmHbE3xEsGzUZWNrkJWHdJBLi5bXZnuSRvq+JDM/0CYSYuTx+lHCcCUiODIKTXFwHOaB+J+bKUTvvz91Rd7ELodUiBTAI/hXDYmWBAgY9Snw8+qBXiA7Ocp+ykcRuiUXXxvYlLgIzqtTEnoODBOsZ5ukjJoUs2GObcOgyBt4eedv7EfUcUKxHdf7ECZbhCEvhtVvHGzzIN5BN3R8+YJKnb0CmsO6FyCgCSnTyvKlFVfSX5s0v9E7XVFrCOo1gVDoL28v7AmrDZsl1mEaRSvVcOHtAXEhZEyF0CdafJ6s5A=</span><br>  <span class="hljs-attr">file:</span> <span class="hljs-string">app/build/outputs/apk/app-release.apk</span><br>  <span class="hljs-comment"># 这句手动添加</span><br>  <span class="hljs-attr">skip_cleanup:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">on:</span><br>    <span class="hljs-attr">repo:</span> <span class="hljs-string">CodePoem/VTemplate</span><br>    <span class="hljs-comment"># 这句手动添加</span><br>    <span class="hljs-attr">tags:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ul><li>provider：发布目标为 GitHub Release ，除了 GitHub 外，Travis CI 还支持发布到 AWS 、Google App Engine 等数十种 provider 。</li><li>secure：是加密后的 GitHub Access Token 。</li><li>file：发布的文件。</li><li>skip_cleanup：默认情况下 Travis CI 在完成编译后会清除所有生成的文件，因此要将 skip_cleanup 设置为 true 来忽略此操作。</li><li>on：发布的时机，这里配置为 tags : true，即只在有 tag 的情况才发布。</li></ul><ol start="2"><li>打 Tag 后 Push 代码触发 CI 。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git tag -a v0.0.1-alpha-1 -m &quot;这里是Tag注释，说清楚这个版本的主要改动，也可以省略-m参数直接写长文本&quot;<br>git push origin --tags<br></code></pre></td></tr></table></figure><h4 id="Fir-im"><a href="#Fir-im" class="headerlink" title="Fir.im"></a><a href="https://fir.im/">Fir.im</a></h4><ol><li>登录 Fir.im 获取 API Token 。</li><li>将获取的 API Toke n 配置到 Travis CI 的环境变量 FIR_API_TOKEN。</li><li>添加配置。</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">before_install:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">gem</span> <span class="hljs-string">install</span> <span class="hljs-string">fir-cli</span><br><span class="hljs-attr">after_deploy:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">fir</span> <span class="hljs-string">p</span> <span class="hljs-string">app/build/outputs/apk/release/app-release.apk</span> <span class="hljs-string">-T</span> <span class="hljs-string">$FIR_API_TOKEN</span> <span class="hljs-string">-c</span> <span class="hljs-string">&quot;`git cat-file tag $TRAVIS_TAG`&quot;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>打 Tag 后 Push 代码触发 CI 。</li></ol><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><h4 id="SendCloud-邮件通知"><a href="#SendCloud-邮件通知" class="headerlink" title="SendCloud 邮件通知"></a>SendCloud 邮件通知</h4><ol><li>注册 SendCloud 。</li><li>创建触发式模板 update_template 。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">%TRAVIS_REPO_SLUG%新版本%TRAVIS_TAG%已经发布了，功能更新：<br><br><br>%TAG_DESCRIPTION%<br><br>去下载：<br>https://fir.im/ep8s<br></code></pre></td></tr></table></figure><ol start="3"><li>添加配置，调用发送邮件 API 。</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">after_deploy:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">curl</span> <span class="hljs-string">-d</span> <span class="hljs-string">&quot;apiUser=******&amp;apiKey=******&amp;from=test@test.com&amp;fromName=testTitle&amp;subject=测试&amp;replyTo=test@test.com&amp;templateInvokeName=update_template&quot;</span><br>    <span class="hljs-string">--data-urlencode</span> <span class="hljs-string">&quot;xsmtpapi=&#123;&#x27;to&#x27;:[&#x27;806957428@qq.com&#x27;],&#x27;sub&#x27;:&#123;&#x27;%TRAVIS_REPO_SLUG%&#x27;:[&#x27;$TRAVIS_REPO_SLUG&#x27;],&#x27;%TRAVIS_TAG%&#x27;:[&#x27;$TRAVIS_TAG&#x27;],&#x27;%TAG_DESCRIPTION%&#x27;:[&#x27;$(git cat-file tag $TRAVIS_TAG)&#x27;]&#125;&#125;&quot;</span> <span class="hljs-string">http://api.sendcloud.net/apiv2/mail/sendtemplate</span><br></code></pre></td></tr></table></figure><ol start="4"><li>打 Tag 后 Push 代码触发 CI 。</li></ol><hr><ul><li>模板整理<a href="https://github.com/CodePoem/VTemplate">GitHub</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>模板</tag>
      
      <tag>Travis CI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Crash治理之TimeoutException</title>
    <link href="/post/Crash%E6%B2%BB%E7%90%86%E4%B9%8BTimeoutException/"/>
    <url>/post/Crash%E6%B2%BB%E7%90%86%E4%B9%8BTimeoutException/</url>
    
    <content type="html"><![CDATA[<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>与 GC 过程相关的守护线程中的 2 个守护线程 FinalizerDaemon 和 FinalizerWatchdogDaemon 有关。</p><ul><li>FinalizerDaemon ：析构守护线程。对于重写了成员函数 finalize 的对象，它们被 GC 决定回收时，并没有马上被回收，而是被放入到一个队列中，等待 FinalizerDaemon 守护线程去调用它们的成员函数 finalize ，然后再被回收。</li><li>FinalizerWatchdogDaemon ：析构监护守护线程。用来监控 FinalizerDaemon 线程的执行。一旦检测那些重定了成员函数 finalize 的对象在执行成员函数 finalize 时超出一定的时间，那么就会退出 VM 。</li></ul><p>原因小总结：</p><p>GC 过程中 FinalizerDaemon 守护线程执行 doFinalize 方法超时。FinalizerWatchdogDaemon 检测到后产生 TimeoutException 并退出虚拟机。<br>（每个手机触发 Timeout 的时长不同，比如 vivo 的某些 rom 是 2 分钟，模拟器统一都是 10 秒钟）</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="理想方案"><a href="#理想方案" class="headerlink" title="理想方案"></a>理想方案</h3><ol><li>减少对 finalize() 方法的依赖，尽量不依靠 finalize() 方法释放资源，手动处理资源释放逻辑；如果不得已使用 finalize() 方法，尽量减少耗时以及线程同步时间。</li><li>减少 finalizable 对象个数，即减少有 finalize() 方法的对象创建，降低 finalizable 对象 GC 次数；Android 5.0 以后 View 默认会实现 finalize 方法，那么减少 View 的创建就是一种解决方法。</li></ol><p>理想方案现实情况下却不太容易完全做到。往往需要采用止损方案。</p><h3 id="止损方案"><a href="#止损方案" class="headerlink" title="止损方案"></a>止损方案</h3><p>止损方案本质都是不检测该异常或忽略该异常、不上报该异常，治标不治本。</p><h4 id="尝试反射去关闭-FinalizerWatchdogDaemon"><a href="#尝试反射去关闭-FinalizerWatchdogDaemon" class="headerlink" title="尝试反射去关闭 FinalizerWatchdogDaemon"></a>尝试反射去关闭 FinalizerWatchdogDaemon</h4><p><strong>限制：</strong></p><p>Android 9.0 版本开始限制 Private API 调用，不能再使用反射调用 Daemons 以及 FinalizerWatchdogDaemon 类方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WatchDogKiller</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG = <span class="hljs-string">&quot;WatchDogKiller&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> sWatchdogStopped = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkWatchDogAlive</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Class clazz;<br>        <span class="hljs-keyword">try</span> &#123;<br>            clazz = Class.forName(<span class="hljs-string">&quot;java.lang.Daemons$FinalizerWatchdogDaemon&quot;</span>);<br>            <span class="hljs-keyword">final</span> Field field = clazz.getDeclaredField(<span class="hljs-string">&quot;INSTANCE&quot;</span>);<br>            field.setAccessible(<span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">final</span> Object watchdog = field.get(<span class="hljs-keyword">null</span>);<br>            Method isRunningMethod = clazz.getSuperclass().getDeclaredMethod(<span class="hljs-string">&quot;isRunning&quot;</span>);<br>            isRunningMethod.setAccessible(<span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">boolean</span> isRunning = (<span class="hljs-keyword">boolean</span>) isRunningMethod.invoke(watchdog);<br>            <span class="hljs-keyword">return</span> isRunning;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stopWatchDog</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 建议在在debug包或者灰度包中不要stop，保留发现问题的能力。</span><br>        <span class="hljs-keyword">if</span> (!BuildConfig.DEBUG) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Android P 以后不能反射FinalizerWatchdogDaemon</span><br>        <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="hljs-number">28</span>) &#123;<br>            Log.w(TAG, <span class="hljs-string">&quot;stopWatchDog, do not support after Android P, just return&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sWatchdogStopped) &#123;<br>            Log.w(TAG, <span class="hljs-string">&quot;stopWatchDog, already stopped, just return&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        sWatchdogStopped = <span class="hljs-keyword">true</span>;<br>        Log.w(TAG, <span class="hljs-string">&quot;stopWatchDog, try to stop watchdog&quot;</span>);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> Class clazz = Class.forName(<span class="hljs-string">&quot;java.lang.Daemons$FinalizerWatchdogDaemon&quot;</span>);<br>            <span class="hljs-keyword">final</span> Field field = clazz.getDeclaredField(<span class="hljs-string">&quot;INSTANCE&quot;</span>);<br>            field.setAccessible(<span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">final</span> Object watchdog = field.get(<span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">final</span> Field thread = clazz.getSuperclass().getDeclaredField(<span class="hljs-string">&quot;thread&quot;</span>);<br>                thread.setAccessible(<span class="hljs-keyword">true</span>);<br>                thread.set(watchdog, <span class="hljs-keyword">null</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable t) &#123;<br>                Log.e(TAG, <span class="hljs-string">&quot;stopWatchDog, set null occur error:&quot;</span> + t);<br><br>                t.printStackTrace();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 直接调用stop方法，在Android 6.0之前会有线程安全问题</span><br>                    <span class="hljs-keyword">final</span> Method method = clazz.getSuperclass().getDeclaredMethod(<span class="hljs-string">&quot;stop&quot;</span>);<br>                    method.setAccessible(<span class="hljs-keyword">true</span>);<br>                    method.invoke(watchdog);<br>                &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable e) &#123;<br>                    Log.e(TAG, <span class="hljs-string">&quot;stopWatchDog, stop occur error:&quot;</span> + t);<br>                    t.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable t) &#123;<br>            Log.e(TAG, <span class="hljs-string">&quot;stopWatchDog, get object occur error:&quot;</span> + t);<br>            t.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attachBaseContext</span><span class="hljs-params">(Context base)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.attachBaseContext(base);<br>        WatchDogKiller.stopWatchDog();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="利用-Thread-UncaughtExceptionHandler-阻断-TimeoutException-处理"><a href="#利用-Thread-UncaughtExceptionHandler-阻断-TimeoutException-处理" class="headerlink" title="利用 Thread.UncaughtExceptionHandler 阻断 TimeoutException 处理"></a>利用 Thread.UncaughtExceptionHandler 阻断 TimeoutException 处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate();<br>        <span class="hljs-keyword">final</span> Thread.UncaughtExceptionHandler defaultUncaughtExceptionHandler =<br>                Thread.getDefaultUncaughtExceptionHandler();<br>        Thread.setDefaultUncaughtExceptionHandler(<span class="hljs-keyword">new</span> Thread.UncaughtExceptionHandler() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (t.getName().equals(<span class="hljs-string">&quot;FinalizerWatchdogDaemon&quot;</span>) &amp;&amp; e <span class="hljs-keyword">instanceof</span> TimeoutException) &#123;<br>                    <span class="hljs-comment">// ignore it</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    defaultUncaughtExceptionHandler.uncaughtException(t, e);<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><p><strong>推荐阅读:</strong></p><ol><li><a href="https://yq.aliyun.com/articles/225751">提升 Android 下内存的使用意识和排查能力</a></li><li><a href="https://yq.aliyun.com/articles/225755">再谈 Finalizer 对象–大型 App 中内存与性能的隐性杀手</a></li><li><a href="https://www.jianshu.com/p/18950c9b0ec9">从 Daemons 到 finalize timed out after 10 seconds</a></li><li><a href="https://blog.csdn.net/pbm863521/article/details/74451935">ART 运行时垃圾收集（GC）过程分析</a></li><li><a href="https://segmentfault.com/a/1190000019373275">滴滴出行安卓端 finalize time out 的解决方案</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Crash</tag>
      
      <tag>TimeoutException</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android动画</title>
    <link href="/post/Android%E5%8A%A8%E7%94%BB/"/>
    <url>/post/Android%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<p>Android 中动画划分为两大类 视图动画（View Animation）和 属性动画（Property Animation）。其中 属性动画（Property Animation）需要在 Android3.0 之后（API &gt;= 11）使用。<br>视图动画（View Animation）又包括了 帧动画（Frame Animation） 和 补间动画（Tweened Animation）。</p><h2 id="视图动画（View-Animation）"><a href="#视图动画（View-Animation）" class="headerlink" title="视图动画（View Animation）"></a>视图动画（View Animation）</h2><h3 id="帧动画（Frame-Animation）"><a href="#帧动画（Frame-Animation）" class="headerlink" title="帧动画（Frame Animation）"></a>帧动画（Frame Animation）</h3><p>帧动画（Frame Animation） 有时也叫 Drawable 动画，这种动画的实质其实是 Drawable。像播放幻灯片一样，利用视觉残留产生动画效果。</p><p>核心类：AnimationDrawable</p><p>使用方式：</p><h4 id="XML-定义帧动画"><a href="#XML-定义帧动画" class="headerlink" title="XML 定义帧动画"></a>XML 定义帧动画</h4><p>推荐使用 XML 定义动画：</p><p>在 res/drawable 下新建 animation_frame_test.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">animation-list</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:oneshot</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">&quot;@color/colorPrimary&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:duration</span>=<span class="hljs-string">&quot;300&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">&quot;@color/colorPrimaryDark&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:duration</span>=<span class="hljs-string">&quot;300&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">animation-list</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="Java-代码创建帧动画"><a href="#Java-代码创建帧动画" class="headerlink" title="Java 代码创建帧动画"></a>Java 代码创建帧动画</h4><p>创建 AnimationDrawable 对象，addFrame(Drawable frame,int duration)向动画中添加帧，调用 start()和 stop()。</p><h3 id="补间动画（Tweened-Animation）"><a href="#补间动画（Tweened-Animation）" class="headerlink" title="补间动画（Tweened Animation）"></a>补间动画（Tweened Animation）</h3><p>补间动画（Tweened Animation）只能应用于 View 对象，而且只支持一部分属性，它只是改变了 View 对象绘制的位置，而没有改变 View 对象本身（所以点击响应区域还在原来的位置）。多用于 Window 切换动画或 Activity 跳转动画。</p><p>核心类：android.view.animation.Animator</p><p>补间动画可以分为四种形式，分别是 alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）。</p><h4 id="java-类"><a href="#java-类" class="headerlink" title="java 类"></a>java 类</h4><ul><li>AlphaAnimation 渐变透明度动画效果</li><li>RotateAnimation 画面转移旋转动画效果</li><li>ScaleAnimation 渐变尺寸伸缩动画效果</li><li>TranslateAnimation 画面转换位置移动动画效果</li><li>AnimationSet 一个持有其它动画元素 alpha、scale、translate、rotate 或者其它 set 元素的容器</li></ul><p>插值器：</p><ul><li>LinearInterpolator：动画以均匀的速度改变</li><li>AccelerateInterpolator：在动画开始的地方改变速度较慢，然后开始加速</li><li>AccelerateDecelerateInterpolator：在动画开始、结束的地方改变速度较慢，中间时加速</li><li>CycleInterpolator：动画循环播放特定次数，变化速度按正弦曲线改变： Math.sin(2 mCycles Math.PI * input)</li><li>DecelerateInterpolator：在动画开始的地方改变速度较快，然后开始减速</li><li>AnticipateInterpolator：反向，先向相反方向改变一段再加速播放</li><li>AnticipateOvershootInterpolator：开始的时候向后然后向前甩一定值后返回最后的值</li><li>BounceInterpolator： 跳跃，快到目的值时值会跳跃，如目的值 100，后面的值可能依次为 85，77，70，80，90，100</li><li>OvershottInterpolator：回弹，最后超出目的值然后缓慢改变到目的值</li></ul><h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><p>在 res/anim 下新建 animation_tweened_test_rotate.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">rotate</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:duration</span>=<span class="hljs-string">&quot;1000&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:fromDegrees</span>=<span class="hljs-string">&quot;0&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:interpolator</span>=<span class="hljs-string">&quot;@android:anim/accelerate_decelerate_interpolator&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:pivotX</span>=<span class="hljs-string">&quot;50%&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:pivotY</span>=<span class="hljs-string">&quot;50%&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:repeatCount</span>=<span class="hljs-string">&quot;infinite&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:toDegrees</span>=<span class="hljs-string">&quot;360&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>AnimationUtils.loadAnimation(Context context, @AnimRes int id)创建 Animation，然后给指定的 View 调用 view.startAnimation(Animation animation) view.clearAnimation()</p><h2 id="属性动画（Property-Animation）"><a href="#属性动画（Property-Animation）" class="headerlink" title="属性动画（Property Animation）"></a>属性动画（Property Animation）</h2><p>属性动画实现原理就是修改控件的属性值实现的动画。</p><p>核心类：android.animation.Animator</p><ul><li>Animator 创建属性动画的基类</li><li>ValueAnimator Animator 子类。其内部采用一种时间循环的机制来计算值与值之间的动画过度，我们只需将初始值以及结束值提供给该类，并告诉其动画所需时间长度，该类就会自动帮我们从初始值平滑过度到结束。该类还能管理动画的播放次数、模式和监听器等。</li><li>ObjectAnimator ValueAnimator 的子类，允许我们对指定对象的属性执行动画，用起来更简单，实际中用得较多。</li><li>AnimatorSet Animator 子类，可以组合多个 Animator，并制定 Animator 的播放次序。</li><li>Interpolator 插值器，同补间动画。</li><li>Evaluator 计算器，告诉动画系统如何从初始值过度到结束值。提供了一下的几种 Evaluator：</li></ul><p>IntEvaluator：用于计算 int 属性<br>FloatEvaluator：用于计算 float 属性<br>ArgbEvaluator：用于计算 16 进制表示颜色值的计算器<br>TypeEvaluator：上述计算类的公共接口，可以自己实现接口完成自定义</p><p>监听器：</p><p>AnimatorUpdateListener： 当值状态发生改变时候会回调 onAnimationUpdate 方法。</p><p>AnimatorListener、AnimatorListenerAdapter：</p><ul><li>onAnimationStart()：动画开始</li><li>onAnimationRepeat()：动画重复执行</li><li>onAnimationEnd()：动画结束</li><li>onAnimationCancel()：动画取消</li></ul><p>平常开发，属性动画多使用 ValueAnimator 和 ObjectAnimator。<br>ValueAnimator 有个缺点，就是只能对数值对动画计算。<br>为了能让动画直接与对应控件相关联，以使我们从监听动画过程中解放出来，可以使用 ValueAnimator 的子类 ObjectAnimator。</p><p>使用 ObjectAnimator 实现动画也有一些要求和限制：</p><ol><li>动画显示的属性必须带有一个 setter 方法（以骆驼拼写法命名）。 因为 ObjectAnimator 会在动画期间自动更新属性值，它必须能够用此 setter 方法访问到该属性。 例如：假设属性名称为 color，则需要有一个 setColor()方法。</li><li>如果在调用 ObjectAnimator 的某个工厂方法时，我们只为 values… 参数指定了一个值，那此值将被认定为动画属性的结束值。 这样的话，动画显示的属性必须带有一个 getter 方法，用于获取动画的起始值。例如：假设属性名为 color，则需要有一个 getColor()方法。</li><li>动画属性的 getter 方法（如果必要的话）和 setter 方法所操作数据的类型必须与 ObjectAnimator 中设定的起始和结束值相同。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>动画</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android自定义View</title>
    <link href="/post/Android%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    <url>/post/Android%E8%87%AA%E5%AE%9A%E4%B9%89View/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是自定义-View"><a href="#什么是自定义-View" class="headerlink" title="什么是自定义 View"></a>什么是自定义 View</h2><p>自定义 View 就是通过继承 View 或者 View 的子类，并在继承的类里面实现自定义的处理逻辑（重写相应的方法），以达到自己想要的效果。</p><h2 id="为什么要自定义-View"><a href="#为什么要自定义-View" class="headerlink" title="为什么要自定义 View"></a>为什么要自定义 View</h2><ul><li>让界面有特定的显示效果、交互</li><li>优化布局（减少布局层次）</li><li>封装</li></ul><h2 id="如何自定义-View"><a href="#如何自定义-View" class="headerlink" title="如何自定义 View"></a>如何自定义 View</h2><h3 id="自定义-View-主要流程"><a href="#自定义-View-主要流程" class="headerlink" title="自定义 View 主要流程"></a>自定义 View 主要流程</h3><ol><li>测量阶段 measure</li><li>布局阶段 layout</li><li>绘制阶段 draw</li></ol><p>背景：DecorView 是视图的顶级 View，我们添加的布局文件是它的一个子布局，而 ViewRootImpl 则负责渲染视图，它调用了一个 performTraveals 方法使得 ViewTree 开始三大工作流程（performMeasure、performLayout、performDraw），然后使得 View 展现在我们面前。</p><h4 id="测量过程"><a href="#测量过程" class="headerlink" title="测量过程"></a>测量过程</h4><p>ViewRootImpl.performMeasure() -&gt; View.measure() -&gt; View.onMesure()</p><p>measure()：调度方法，主要做一些前置和优化工作，并最终会调用 onMeasure() 方法执行实际的测量工作。<br>onMesure()：实际执行测量任务的方法，主要用与测量 View 尺寸和位置。在自定义 View 的 onMeasure() 方法中，View 根据自己的特性和父 View 对自己的尺寸要求算出自己的期望尺寸，并通过 setMeasuredDimension() 方法告知父 View 自己的期望尺寸。</p><p>MeasureSpec：封装 View 的规格尺寸，由 32 位整型表示测量模式（高 2 位）+测量大小（低 30 位）。</p><h4 id="布局过程"><a href="#布局过程" class="headerlink" title="布局过程"></a>布局过程</h4><p>ViewRootImpl.performLayout() -&gt; View.layout() -&gt; View.onLayout()</p><p>layout：保存 View 的实际尺寸。调用 setFrame() 方法保存 View 的实际尺寸，调用 onSizeChanged() 通知开发者 View 的尺寸更改了，并最终会调用 onLayout() 方法让子 View 布局（因为自定义 View 中没有子 View，所以自定义 View 的 onLayout() 方法是一个空实现）。<br>onLayout： 空实现，什么也不做，因为它没有子 View。</p><h4 id="绘制过程"><a href="#绘制过程" class="headerlink" title="绘制过程"></a>绘制过程</h4><p>ViewRootImpl.performDraw() -&gt; View.draw() -&gt; View.onDraw()</p><p>draw()：绘制阶段的总调度方法，在其中会调用绘制背景的方法 drawBackground()、绘制主体的方法 onDraw()、绘制子 View 的方法 dispatchDraw() 和 绘制前景的方法 onDrawForeground()。<br>drawBackground()：绘制背景的方法，不能重写，只能通过 xml 布局文件或者 setBackground() 来设置或修改背景。<br>onDraw()：绘制 View 主体内容的方法，通常情况下，在自定义 View 的时候，只用实现该方法即可。<br>dispatchDraw()：绘制子 View 的方法。同 onLayout() 方法一样，在自定义 View 中它是空实现，什么也不做。<br>onDrawForeground()：绘制 View 前景的方法，也就是说，想要在主体内容之上绘制东西的时候就可以在该方法中实现。</p><h3 id="自定-ViewGroup-主要流程"><a href="#自定-ViewGroup-主要流程" class="headerlink" title="自定 ViewGroup 主要流程"></a>自定 ViewGroup 主要流程</h3><p>大部分流程和自定义 View 一致，就不再赘述。这里只列出和自定义 View 不一样的地方。</p><ol><li><p>onMeasure()：在自定义 ViewGroup 的 onMeasure() 方法中，ViewGroup 会递归调用子 View 的 measure() 方法，并通过 measure() 将 ViewGroup 对子 View 的尺寸要求（ViewGroup 会根据开发者对子 View 的尺寸要求、自己的父 View（ViewGroup 的父 View） 对自己的尺寸要求和自己的可用空间计算出自己对子 View 的尺寸要求）传入，对子 View 进行测量，并把测量结果临时保存，以便在布局阶段使用。测量出子 View 的实际尺寸之后，ViewGroup 会根据子 View 的实际尺寸计算出自己的期望尺寸，并通过 setMeasuredDimension() 方法告知父 View（ViewGroup 的父 View） 自己的期望尺寸。</p></li><li><p>layout()：保存 ViewGroup 的实际尺寸。调用 setFrame() 方法保存 ViewGroup 的实际尺寸，调用 onSizeChanged() 通知开发者 ViewGroup 的尺寸更改了，并最终会调用 onLayout() 方法让子 View 布局。</p></li><li><p>onLayout()：ViewGroup 会递归调用每个子 View 的 layout() 方法，把测量阶段计算出的子 View 的实际尺寸和位置传给子 View，让子 View 保存自己的实际尺寸和位置。</p></li><li><p>draw() -&gt; dispatchDraw()：绘制子 View 的方法。在自定义 ViewGroup 中，它会调用 ViewGroup.drawChild() 方法，在 ViewGroup.drawChild() 方法中又会调用每一个子 View 的 View.draw() 让子 View 进行自我绘制。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>自定义View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java泛型</title>
    <link href="/post/Java%E6%B3%9B%E5%9E%8B/"/>
    <url>/post/Java%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>泛型：参数化类型（将类型由原来的具体的类型参数化）。</p><p>特点：</p><ul><li>适用于多种数据类型执行相同的代码。</li><li>使用泛型时，在实际使用之前类型就已经确定了，不需要强制类型转换。</li><li>泛型只在编译阶段有效。</li></ul><p>泛型命名标识字母（常见字母）：</p><ul><li>T Type</li><li>K V Key Value</li><li>E Element</li></ul><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 泛型类">class 类名称&lt;泛型命名标识&gt; &#123;<br>  private 泛型命名标识 /*（成员变量类型）*/ var;<br>  .....<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 泛型接口">public interface 接口名称&lt;泛型命名标识&gt; &#123;<br>    public 泛型命名标识 method();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 泛型方法">public class Method &#123;<br>  public static &lt;泛型命名标识&gt; void method(泛型命名标识 var)&#123;<br>      .....<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>类型擦除：Java 的泛型机制是在编译级别实现的。编译器生成的字节码在运行期间并不包含泛型的类型信息。<br>泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉。</p><h2 id="上界-amp-下界-协变-amp-逆变"><a href="#上界-amp-下界-协变-amp-逆变" class="headerlink" title="上界&amp;下界/协变&amp;逆变"></a>上界&amp;下界/协变&amp;逆变</h2><p>无界：通配符?，表示泛型类型是一个未知类型。<br>上界：上界通配符 extends，限制了泛型未知类型的上界。<br>下界：下界通配符 super，限制了泛型未知类型的下界。</p><p>型变：协变、逆变和不变的统称，用来描述类型转换后的继承关系。比如：Sub 是 Super 的子类型，List&lt;Sub&gt;是否是 List&lt;Super&gt;的子类型。</p><p>协变（covariance）：满足 Sub 是 Super 的子类型，List&lt;Sub&gt;也是 List&lt;? extends Super&gt;的子类型。<br>逆变（covariance）：满足 Sub 是 Super 的子类型，List&lt;Super&gt;也是 List&lt;? super Sub&gt;的子类型。<br>不变（invariance）：表示 Sub 是 Super 的子类型，List&lt;Sub&gt;和 List&lt;Super&gt;不存在型变关系。</p><p>ps：子类(subclass)和子类型(subtype)不是同一个概念。子类说明了新类是继承自父类，而子类型强调的是新类具有父类一样的行为（未必是继承，还有可能是实现接口）。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android设备唯一性</title>
    <link href="/post/Android%E8%AE%BE%E5%A4%87%E5%94%AF%E4%B8%80%E6%80%A7/"/>
    <url>/post/Android%E8%AE%BE%E5%A4%87%E5%94%AF%E4%B8%80%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>如何标识唯一的 Android 设备呢？</p><h2 id="硬件标识符"><a href="#硬件标识符" class="headerlink" title="硬件标识符"></a>硬件标识符</h2><h3 id="IMEI"><a href="#IMEI" class="headerlink" title="IMEI"></a>IMEI</h3><p>国际移动设备身份码(International Mobile Equipment Identity)，是由 15 位数字组成的”电子串号”，它与每台手机一一对应，而且该码是全世界唯一的。</p><p>IMEI 所需权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs IMEI所需权限">&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt;<br></code></pre></td></tr></table></figure><h3 id="MEID"><a href="#MEID" class="headerlink" title="MEID"></a>MEID</h3><p>全球唯一的 56bit CDMA 制式移动终端标识号（ Mobile Equipment IDentifier ）。标识号会被烧入终端里，并且不能被修改。可用来对 CDMA 制式移动式设备进行身份识别和跟踪。</p><h3 id="ESN"><a href="#ESN" class="headerlink" title="ESN"></a>ESN</h3><p>电子序列号（electronic serial number），在 CDMA 系统中，是鉴别一个物理硬件设备唯一的标识。</p><h3 id="DEVICE-ID"><a href="#DEVICE-ID" class="headerlink" title="DEVICE_ID"></a>DEVICE_ID</h3><p>不同的手机设备返回上述的 IMEI，MEID 或者 ESN 码。</p><h3 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h3><p>设备网卡的唯一设别码，该码全球唯一，一般称为物理地址，硬件地址用来定义设备的位置。</p><p>MAC 地址所需权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MAC地址所需权限">&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt;<br></code></pre></td></tr></table></figure><p><strong>PS：</strong> Android6.0 及以上 8.0 以下获取不到准确的 MAC 地址。8.0 及以上获取不到 MAC 地址。</p><h3 id="ANDROID-ID"><a href="#ANDROID-ID" class="headerlink" title="ANDROID_ID"></a>ANDROID_ID</h3><p>在设备首次运行的时候，系统会随机生成一 64 位的数字，并把这个数值以 16 进制保存下来，这个 16 进制的数字就是 ANDROID_ID，但是如果手机恢复出厂设置这个值会发生改变。</p><p><strong>PS：</strong> 国内厂商可能不提供 ANDROID_ID。</p><h3 id="SN"><a href="#SN" class="headerlink" title="SN"></a>SN</h3><p>设备序列号（Serial Number）。</p><p><strong>PS：</strong> 国内厂商不提供 SN 可能为垃圾数据。</p><h3 id="自定义全局唯一-ID-GUID"><a href="#自定义全局唯一-ID-GUID" class="headerlink" title="自定义全局唯一 ID (GUID)"></a>自定义全局唯一 ID (GUID)</h3><p>自定义全局唯一 ID，通常采用随机算法生成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs GUID">UUID.randomUUID().toString();<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>硬件标识符没有哪一个能说是准确且可靠的，因此通常都是使用上述几个的组合来标识唯一的 Android 设备（组合的时候可以加一些自定义的算法，如截取定长、MD5、Base64 等）。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>App</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android应用唯一性</title>
    <link href="/post/Android%E5%BA%94%E7%94%A8%E5%94%AF%E4%B8%80%E6%80%A7/"/>
    <url>/post/Android%E5%BA%94%E7%94%A8%E5%94%AF%E4%B8%80%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>说到应用唯一性，下面三个关键词，有何区别和联系呢？</p><ul><li>包名</li><li>applicationId</li><li>签名</li></ul><h2 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h2><h3 id="定义简介"><a href="#定义简介" class="headerlink" title="定义简介"></a>定义简介</h3><p>包名指的是软件包名称（代码命名空间）。就是我们平常写代码 import 的 package。</p><h3 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 包名">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;<br>    xmlns:tools=&quot;http://schemas.android.com/tools&quot;<br>    package=&quot;com.example.myapp&quot;&gt;<br></code></pre></td></tr></table></figure><h3 id="更改包名"><a href="#更改包名" class="headerlink" title="更改包名"></a>更改包名</h3><p>Android 构建工具使用 package 属性来发挥两种作用：</p><ul><li>它会将此 package 名称用作应用生成的 R.java 类的命名空间。如：com.example.myapp.R</li><li>它会使用此 package 名称解析清单文件中声明的任何相关类名。如：声明为 <activity android:name=".MainActivity"> 的 Activity 将解析为 com.example.myapp.MainActivity</li></ul><p>因此 package 属性中的名称应始终与项目的基础软件包名称匹配，基础软件包中保存着您的 Activity 及其他应用代码。（如果它们未保持同步，您的应用代码将无法解析 R 类，因为它不再位于同一软件包中，并且清单无法识别您的 Activity 或其他组件）</p><p><strong>注意：</strong> 如果未在 build.gradle 文件中定义 applicationId 属性，构建工具会将 AndroidManifest.xml 文件中的软件包名称用作 applicationId。在这种情况下，重构软件包名称也会更改 applicationId。</p><h2 id="applicationId"><a href="#applicationId" class="headerlink" title="applicationId"></a>applicationId</h2><h3 id="定义简介-1"><a href="#定义简介-1" class="headerlink" title="定义简介"></a>定义简介</h3><p>applicationId 是每个应用的唯一应用 Id，看起来就和软件包名称一样。此 ID 可以在设备上和 Google Play 商店中对应用进行唯一标识(实际上，Google Play 商店和 Android 平台会查看包名 package 属性来识别您的应用，构建工具会在编译结束时将 applicationId 复制替换到 APK 的最终清单文件中)。也就是说，上传新版本的应用，applicationId 必须与原始 APK 相同，否则会被认为是两个完全不同的应用。因此发布应用后， <strong>绝不应该更改 applicationId</strong> 。</p><h3 id="配置示例-1"><a href="#配置示例-1" class="headerlink" title="配置示例"></a>配置示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applicationId">android &#123;<br>    defaultConfig &#123;<br>        applicationId &quot;com.example.myapp.XXX&quot;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>PS：</strong> 如果需要在清单文件中引用 applicationId，可以在任何清单属性中使用 ${applicationId} 占位符，在编译期间，Gradle 会将此标记替换为实际的 applicationId。</p><h3 id="命名规则限制"><a href="#命名规则限制" class="headerlink" title="命名规则限制"></a>命名规则限制</h3><ul><li>必须至少包含两段（一个或多个圆点）</li><li>每段必须以字母开头</li><li>所有字符必须为字母数字或下划线[a-zA-Z0-9_]</li></ul><h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><h3 id="定义简介-2"><a href="#定义简介-2" class="headerlink" title="定义简介"></a>定义简介</h3><p>Android 要求所有 APK 必须先使用证书进行数字签署，然后才能安装。这个签署的过程就是我们说的签名。</p><ul><li>公钥证书（也称为数字证书或身份证书），包含公钥/私钥对的公钥，以及标识密钥所有者的一些其他元数据（例如名称和位置）。证书的所有者持有对应的私钥。</li><li>在签署 APK 时，签署工具会将公钥证书附加到 APK，用于创建此证书的密钥称为应用签名密钥。</li><li>密钥库，一种包含一个或多个私钥的二进制文件。</li><li>每个应用在其整个生命周期内必须使用相同证书，以便用户能够以应用更新的形式安装新版本。</li></ul><h3 id="配置示例-2"><a href="#配置示例-2" class="headerlink" title="配置示例"></a>配置示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs 签名配置">android &#123;<br>    ...<br>    defaultConfig &#123; ... &#125;<br>    signingConfigs &#123;<br>        release &#123;<br>            // You need to specify either an absolute path or include the<br>            // keystore file in the same directory as the build.gradle file.<br>            storeFile file(&quot;my-release-key.jks&quot;)<br>            storePassword &quot;password&quot;<br>            keyAlias &quot;my-alias&quot;<br>            keyPassword &quot;password&quot;<br>        &#125;<br>    &#125;<br>    buildTypes &#123;<br>        release &#123;<br>            signingConfig signingConfigs.release<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>debug 模式下，Android Studio 会在$HOME/.android/debug.keystore 中自动创建调试密钥库和证书，并设置密钥库和密钥密码。</p><p>在 Android Studio 生成密钥：</p><center><p><img src="/assert/img/app/appuniqueness/keystore-example.png" alt="New Key Store"></p></center><p>密钥库：</p><ul><li>Key store pat：选择创建密钥库的位置。</li><li>Password： 为密钥库创建并确认安全的密码。</li></ul><p>密钥：</p><ul><li>Alias：密钥标识名。</li><li>Password：为密钥创建并确认安全的密码。此密码应当与为密钥库选择的密码不同。</li><li>Validity (years)：以年为单位设置密钥的有效时长。密钥的有效期应至少为 25 年，以便您可以在应用的整个生命期内使用相同的密钥签署应用更新。</li><li>Certificate：为证书输入一些关于自己的信息。此信息不会显示在应用中，但会作为 APK 的一部分包含在证书中。</li></ul><h3 id="keytool-命令行签名工具"><a href="#keytool-命令行签名工具" class="headerlink" title="keytool 命令行签名工具"></a>keytool 命令行签名工具</h3><p>keytool 位于 JDK 的 bin/ 目录中。</p><ul><li>生成签名 keytool -genkey -v -keystore my-release-key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias my-alias</li><li>查看签名 jks keytool -list -v -keystore my-release-key.jks -storepass my-storepass</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>applicationId 是应用的唯一标识。发布应用后 <strong>绝不应该更改 applicationId</strong> 。</li><li>尽管 applicationId 和包名在设置时完全一样，但 <strong>applicationId 和包名彼此无关，两者更改互不影响</strong> 。</li><li>applicationId 过去直接关联到代码的软件包名称；所以，有些 Android API 会在其方法名称和参数名称中使用“package name”一词，但这实际上是指 applicationId，如 <strong>Context.getPackageName() 方法返回的是 applicationId</strong> 。</li><li>无论何时都不需要在应用代码以外分享代码的真实软件包名称。对外暴露的只有 applicationId。</li><li>构建工具会在 <strong>编译结束时将 applicationId 复制替换到 APK 的最终清单文件中</strong> ，编译系统利用原始值包名（设置 R 类的命名空间并解析清单类名称）后，它会舍弃该值（包名）并将其替换为 applicationId。</li><li>个人推荐 applicationId 和包名一致或者以包名为前缀。</li><li>Android 要求所有 APK 必须先使用证书进行数字签署，然后才能安装。</li><li>Android Studio 默认会自动生成 debug 签名，签名在$HOME/.android/debug.keystore。</li></ol><p>综上所述，不同的 APP，applicationId 一定不相同，包名和签名可以相同也可以不相同。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>App</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android存储目录</title>
    <link href="/post/Android%E5%AD%98%E5%82%A8%E7%9B%AE%E5%BD%95/"/>
    <url>/post/Android%E5%AD%98%E5%82%A8%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<ul><li>问：三个概念，你弄清楚了吗？<br>内存：Memory<br>内部存储：InternalStorage<br>外部存储：ExternalStorage</li><li>答：说到这三个概念，就不得不说一下平时我们选购手机的参数 6G+128G、8G+256G 等，这里的 6G 和 8G 指的是手机内存（手机运行时存储），而 128G 和 256G 指的是手机存储空间（由内部存储的空间和外部存储的空间构成）。PS：所以如果追求手机的运行速度，内存买大一点。可以理解为手机内存是操场，而手机存储空间是教室，要想学生们跑得快自然操场得大一些，教室的大小只决定了可以容纳多少学生。</li></ul><ol><li>你了解 Android 手机的存储目录吗？</li><li>你知道 Android 手机 App 应用数据都存放在哪了吗？</li><li>你知道 Android 手机存储存在的隐私安全问题吗？</li></ol><p>那么开始今天的故事。</p><h2 id="虚拟世界"><a href="#虚拟世界" class="headerlink" title="虚拟世界"></a>虚拟世界</h2><p>Android 存储目录的<strong>化身</strong>——A 州 M 社区。</p><p>众所周知，A 州是一座正在蓬勃发展的城市。M 社区是 A 州引以为傲的设施完备的高档社区（各家各户都是<strong>独门独幢</strong>），有几户大户人家住在 M 社区，<strong>陶钱豹</strong>陶家、<strong>魏欣</strong>魏家、<strong>窦银</strong>窦家等是其中翘楚。</p><center><p><img src="/assert/img/persistence/storage/storage_sample.png" alt="M社区鸟瞰图"></p></center><ul><li>M 社区总占地 30 万平方米,<strong>公共区域面积大</strong>，绿化率高。住宅区是各家各户<strong>私有区域</strong>（有围墙大门），未经主人允许不得擅自闯入。除此之外，社区设有专门的停车区来实现人车分离，当然停车区也属于<strong>私有区域</strong>，与住宅绑定。私有区域都有尊贵的户主标识。</li><li>除了私有区域，社区还拥有相册公园、音乐游泳馆、图片图书馆等<strong>九大公共区域</strong>，由物业统一管理，各家各户共享资源。</li><li>如果有一户人家搬出社区，物业会对这户人家的<strong>私有区域</strong>（包括住宅区和停车区）进行打扫，保证不会残留垃圾，给下一户人家良好的居住体验，同时也会保留上一户人家在公共区域所留下的记录和贡献（这是社区的共享资源）。</li><li>社区公共区域虽然受物业管辖，但限制不大，各家各户几乎可以自由地使用和享受公共资源，所以公共区域的文明建设就要靠对社区居民的自觉性了。</li></ul><p>把目光拉回到现实来。</p><h2 id="现实世界"><a href="#现实世界" class="headerlink" title="现实世界"></a>现实世界</h2><p>小米 5 真机文件存储目录：</p><center> <p><img src="/assert/img/persistence/storage/mi5_file.png" alt="MI5文件存储"></p></center><p>附上包含针对开发者的 Android 存储目录 Api 整理：</p><center><p><img src="/assert/img/persistence/storage/storage_summary.png" alt="Android存储目录总结"></p></center><ul><li><p>内部存储根目录：/data</p></li><li><p>内部存储私有目录根目录：/data/user/0/包名(如 com.taobao.taobao)</p></li><li><p>内部存储普通文件私有目录：/data/user/0/包名(如 com.taobao.taobao)/files</p></li><li><p>内部存储缓存文件私有目录：/data/user/0/包名(如 com.taobao.taobao)/cache</p></li><li><p>外部存储根目录：/storage/emulated/0</p></li><li><p>外部存储私有目录根目录：/storage/emulated/0/Android/data/包名(如 com.taobao.taobao)</p></li><li><p>外部存储普通文件私有目录：/storage/emulated/0/Android/data/包名(如 com.taobao.taobao)/files</p></li><li><p>外部存储缓存文件私有目录：/storage/emulated/0/Android/data/包名(如 com.taobao.taobao)/cache</p></li></ul><div align=center><img width="270" height="480" src="/assert/img/persistence/storage/data_clear.png"/></div> <!--![QQ清理数据](/assert/img/persistence/storage/data_clear.png)--><p>清理数据的两个选项：</p><ol><li>清理数据：会清理所有私有目录（内部存储私有目录根目录和外部存储私有目录根目录）</li><li>清理缓存：会清理所有缓存文件目录（内部存储缓存文件私有目录和外部存储缓存文件私有目录）</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文基于 Android4.4 及以上系统说明，因为 Android4.4 以下存储目录有细微区别，这里不做探讨。</p><ol><li>Android 存储目录主要分为<strong>内部存储私有目录</strong>、<strong>外部存储私有目录</strong>和<strong>外部存储公共目录</strong>。</li><li>Android 手机 App 应用的数据中<strong>与应用相关</strong>的缓存数据等（这些数据会随着应用卸载一起删除）一般存储在<strong>外部存储私有目录</strong>，在外部存储私有目录不可用的情况下才考虑内部存储私有目录（内部存储空间较少，比较珍贵）；Android 手机 App 应用的数据中<strong>与应用无关</strong>的数据（例如保存的照片，这些数据不会随着应用卸载一起删除）存储在<strong>外部存储公共目录</strong>或外部存储自定义的其他目录下。</li><li>Android 手机存储对外部公共存储部分的限制较少，存在隐私安全隐患。（据说你在“猫西”上搜索耳机商品，它会将这个隐私信息存储到你手机的外部存储，然后你在打开“明日底线”的时候会读取这个隐私信息，给你推送耳机的广告）</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>造成当前 Android 存储目录使用混乱的局面有多种因素。<strong>一是</strong>谷歌在 Android<strong>系统层面</strong>没有杜绝这种情况的发生；<strong>二是</strong>国内 Android<strong>开发者水平良莠不齐</strong>，有像我这样的菜鸟（哭）程序员对 Android 存储目录不甚了解，复制粘贴网上的模板代码就会导致对存储目录的胡乱使用，也有<strong>明知不可为而为之</strong>的“黑心”程序员，故意利用 Android 存储目录“漏洞”来达到不可告人的目的。<br>最后，提醒各位，作为开发者，还是要<strong>恪守底线</strong>；作为 Android 用户，要<strong>加强隐私安全意</strong>识，不要随意下载未知来源的 App，多加注意各类 App 所需的<strong>应用权限</strong>（它们可能在背后偷偷利用你所赋予的权限干你不知道的事）。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>持久化</tag>
      
      <tag>存储目录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android特有集合类浅析</title>
    <link href="/post/Android%E7%89%B9%E6%9C%89%E9%9B%86%E5%90%88%E7%B1%BB%E6%B5%85%E6%9E%90/"/>
    <url>/post/Android%E7%89%B9%E6%9C%89%E9%9B%86%E5%90%88%E7%B1%BB%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<ul><li>ArrayMap</li><li>ArraySet</li><li>SparseArray</li><li>SparseIntArray</li><li>SparseBooleanArray</li><li>SparseLongArray</li></ul><h2 id="设计这些-Android-特有的集合类的意义"><a href="#设计这些-Android-特有的集合类的意义" class="headerlink" title="设计这些 Android 特有的集合类的意义"></a>设计这些 Android 特有的集合类的意义</h2><p>为什么要设计这些 Android 特有的集合类呢?</p><p>主要目的： 优化内存占用。在移动设备端内存资源很珍贵，Java 原本的集合类为实现快速查询带来了很大内存的浪费。</p><h2 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a>ArrayMap</h2><h3 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h3><p>代替 HashMap&lt;Object,Object&gt;，且 key 唯一。</p><h4 id="HashMap-实现方式"><a href="#HashMap-实现方式" class="headerlink" title="HashMap 实现方式"></a>HashMap 实现方式</h4><p>我们先来简单回忆下 HashMap，HashMap 是用散列表（数组+链表）实现：</p><p><img src="/assert/img/androidmap/hashmap.jpg" alt="HashMap"></p><h4 id="HashMap-碰撞冲突解决方式"><a href="#HashMap-碰撞冲突解决方式" class="headerlink" title="HashMap 碰撞冲突解决方式"></a>HashMap 碰撞冲突解决方式</h4><p>HashMap 用<strong>链地址法</strong>解决 hashCode 冲突，这就是链表的设计目的，碰撞冲突就用头插法在对应 key 的链表插入 value。</p><p>顺便提一下解决碰撞冲突的常用四个方法：</p><ol><li>链地址法</li><li>再 Hash 法</li><li>开放地址法(线性探测,二次探测,伪随机探测)</li><li>建立公共溢出区</li></ol><h4 id="HashMap-扩容机制"><a href="#HashMap-扩容机制" class="headerlink" title="HashMap 扩容机制"></a>HashMap 扩容机制</h4><p>HasMap 默认初始容量 16，加载因子 0.75。<br>HasMap 扩容机制：元素个数超过数组容量 *负载因子，扩大为 2 倍。</p><h4 id="HashMap-总结"><a href="#HashMap-总结" class="headerlink" title="HashMap 总结"></a>HashMap 总结</h4><p>HashMap 的存取速度都是相对比较快的，在一般情况下都能实现<strong>O(1)</strong>的速度。但是代价是什么呢？<br>但是从初始容量和负载因子都可以看出，这种快速的读是通消耗更多内存来换取的(<strong>空间换时间</strong>)。</p><h3 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h3><p>对比上面回忆的 HashMap 特征来看 ArrayMap。</p><h4 id="ArrayMap-实现方式"><a href="#ArrayMap-实现方式" class="headerlink" title="ArrayMap 实现方式"></a>ArrayMap 实现方式</h4><p>ArrayMap 是用双数组实现：</p><p>一个 int[]数组，用于保存每个 item 的<strong>hashCode</strong>.<br>一个 Object[]数组，保存 key/value 键值对。容量是上一个数组的<strong>两倍</strong>。</p><p><img src="/assert/img/androidmap/arraymap.jpg" alt="ArrayMap"></p><h4 id="ArrayMap-解决碰撞冲突方式"><a href="#ArrayMap-解决碰撞冲突方式" class="headerlink" title="ArrayMap 解决碰撞冲突方式"></a>ArrayMap 解决碰撞冲突方式</h4><p>ArrayMap 会对 key<strong>从小到大排序</strong>，使用<strong>二分法查询</strong>key 对应在数组中的下标。<br>先对存储 hashCode 的 int[]数组使用<strong>二分查找法</strong>得到相应的 index，通过 index 换算，可以得到 Object[]数组的<strong>key 下标（index*2）</strong>和<strong>value 下标（index*2+1）</strong>。</p><p>那么如果出现 hashCode 冲突，该怎么办呢？<br>ArrayMap 采用自己的<strong>开放地址法</strong>来解决碰撞冲突。</p><p>以 put 一个键值对 key/value 为例子：</p><p><img src="/assert/img/androidmap/arraymap_put.jpg" alt="ArrayMap进行put"></p><p>hashCode 碰撞时会发生这样的情景， 存储 hashCode 的 int[]数组<strong>二分查找</strong>后得到的 index 不为负数（因为如果该 hashCode 存储过数据，index 必然大于等于 0，也就是能在 int[]数组中查找到值），且同时根据 index 换算后得到的 key 下标和 value 下标在 Object[]数组也已存有数据。<br>ArrayMap 会以当前换算好的 key 下标为<strong>中心点</strong>，<strong>向后和向前遍历</strong>，查询对比是否有<strong>相同 key 值</strong>。<br>相同则说明重复 put 了；向后和向前遍历都没有找到相同 key 值的，最后将在向后遍历的最后一个下标后插入当前 key/value。</p><h4 id="ArrayMap-扩容机制"><a href="#ArrayMap-扩容机制" class="headerlink" title="ArrayMap 扩容机制"></a>ArrayMap 扩容机制</h4><p>ArrayMap 默认容量为 0。</p><p>ArrayMap 扩容机制：</p><ol><li>如果容量大于等于 8，则扩容一半</li><li>否则容量大于等于 4，则扩容到 8</li><li>否则扩容到 4</li><li>扩容时只需要数组拷贝工作，不需要重建哈希表</li></ol><p>为什么 4 是扩容默认的 size， 因为 4 是相对效率较高的大小。</p><h4 id="ArrayMap-总结"><a href="#ArrayMap-总结" class="headerlink" title="ArrayMap 总结"></a>ArrayMap 总结</h4><p>从存储方式和扩容机制可以看出，ArrayMap 将内存的使用率提高了很多，但是读取的复杂度却是<strong>O(lgN)</strong>（因为二分法查找）。在数据量不是很大（<strong>千级以内</strong>）的时候，使用 ArrapMap 可以优化内存，并且存取速度几乎是不受什么影响的。</p><p>尚未提及的一点是，ArrayMap 在删除元素时，如果集合剩余元素少于一定阈值，还有<strong>收缩（shrunk）</strong>功能。（等以后研究一下后补上）</p><p>可以看出 ArrayMap 和 HashMap 大体上是时间和空间的权衡罢了。</p><h2 id="ArraySet"><a href="#ArraySet" class="headerlink" title="ArraySet"></a>ArraySet</h2><h3 id="设计目的-1"><a href="#设计目的-1" class="headerlink" title="设计目的"></a>设计目的</h3><p>代替 HashSet,只保存 value，value 唯一</p><h3 id="设计原理-1"><a href="#设计原理-1" class="headerlink" title="设计原理"></a>设计原理</h3><p>和 ArrayMap 类似，不做展开。</p><h2 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h2><h3 id="设计目的-2"><a href="#设计目的-2" class="headerlink" title="设计目的"></a>设计目的</h3><p>代替 HashMap&lt;Integer,Object&gt;，SparseArray 只能在 key 为 int 的时候才能使用，注意是 int 而不是 Integer。<br>这样做就是为了进步一优化 ArrayMap，避免装箱拆箱的操作，从而节省内存和提高效率。</p><h3 id="设计原理-2"><a href="#设计原理-2" class="headerlink" title="设计原理"></a>设计原理</h3><p>原理和 Arraymap 基本一致，也是基于双数组和二分查找，这里就不展开。</p><h2 id="SparseIntArray"><a href="#SparseIntArray" class="headerlink" title="SparseIntArray"></a>SparseIntArray</h2><h3 id="设计目的-3"><a href="#设计目的-3" class="headerlink" title="设计目的"></a>设计目的</h3><p>代替 HashMap&lt;Integer,Integer&gt;，进一步优化 SparseArray，避免 value 为 Integer 的时候的装箱拆箱操作。</p><h2 id="SparseBooleanArray"><a href="#SparseBooleanArray" class="headerlink" title="SparseBooleanArray"></a>SparseBooleanArray</h2><h3 id="设计目的-4"><a href="#设计目的-4" class="headerlink" title="设计目的"></a>设计目的</h3><p>代替 HashMap&lt;Integer,Boolean&gt;，进一步优化 SparseArray，避免 value 为 Boolean 的时候的装箱拆箱操作。</p><h2 id="SparseLongArray"><a href="#SparseLongArray" class="headerlink" title="SparseLongArray"></a>SparseLongArray</h2><h3 id="设计目的-5"><a href="#设计目的-5" class="headerlink" title="设计目的"></a>设计目的</h3><p>代替 HashMap&lt;Integer,Long&gt;，进一步优化 SparseArray，避免 value 为 Long 的时候的装箱拆箱操作。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>数据结构</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈二维码②与世浮沉</title>
    <link href="/post/%E6%B5%85%E8%B0%88%E4%BA%8C%E7%BB%B4%E7%A0%81%E2%91%A1%E4%B8%8E%E4%B8%96%E6%B5%AE%E6%B2%89/"/>
    <url>/post/%E6%B5%85%E8%B0%88%E4%BA%8C%E7%BB%B4%E7%A0%81%E2%91%A1%E4%B8%8E%E4%B8%96%E6%B5%AE%E6%B2%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>上次我们讲到二维码比条形码<strong>更优秀</strong>，可以承载更多信息等；也讲到了我们平常所说的二维码是<strong>QR Code</strong>，是<strong>狭义的二维码</strong>。后文所说的二维码除特殊说明外，也都指的是 QR 码。<br>忘了的同学或者没看过上一篇的同学可以点<a href="/2019/02/22/浅谈二维码①身世谜题/index.html#一、引言">这里</a>。</p><center><p><img src="/assert/img/qrcode/life/wxscan.jpg" alt="扫一扫"></p></center><p>这个界面想必大家都很熟悉，那么扫二维码的这一过程到底发生了什么呢，作为社交和移动支付“宠儿”的二维码是如何与世浮沉的呢，今天我们来了解一下。</p><h2 id="二、二维码识别基本过程"><a href="#二、二维码识别基本过程" class="headerlink" title="二、二维码识别基本过程"></a>二、二维码识别基本过程</h2><h3 id="简易流程图"><a href="#简易流程图" class="headerlink" title="简易流程图"></a>简易流程图</h3><p>我随意画了一张简陋的流程图，你们也随意看一下吧~<br>（普通的迪斯科要普通地摇，随意的流程图要随意地看）</p><div align=center><img width="400" height="800" src="/assert/img/qrcode/life/qrcodeProcess.jpg"/></div><p><strong>好了，你应该看懂了吧，那本文到此为止，散了吧！（哎哎哎，你不会真的走了吧，后面还有精彩的，嘿嘿~）</strong></p><p><strong>我们以一张彩色二维码图为例子。（里面承载了一串文本信息，不信你可以扫一扫试试，没毒的，死不了，放心吧，哈哈~）</strong><br><strong>不正经警告！</strong> 下面将以第一人称视角来描述，欢迎来到戏精表演现场。</p><p>嗨，大家好，我来自二维码种族，是一位地下工作者，我的使命是传递信息，虽然我长得很美，但我很害羞。什么？你不相信？那我先收起我的矜持，给你发张我的自拍照，我大概长这样子：</p><div align=center><img width="150" height="150" src="/assert/img/qrcode/life/qrcodeBeautiful.png"/></div><p>–怎么样，我美吗？<br>–美爆！！！<br>–(窃喜<del>~</del>)</p><h3 id="关键步骤阐述"><a href="#关键步骤阐述" class="headerlink" title="关键步骤阐述"></a>关键步骤阐述</h3><p>因为珍贵的信息被藏在了我的身体里，为了完成传递信息的使命，我要经历许多“磨难”，不过我相信我可以的。<br>古有云，天降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤……<br>这次地下任务和我接头的是一位外科医生（好像叫“扫一扫”的家伙），他高超的手术技术能将藏在了我的身体的信息取出来。</p><h4 id="1-读取图像，将原始图像变成黑白图像"><a href="#1-读取图像，将原始图像变成黑白图像" class="headerlink" title="1. 读取图像，将原始图像变成黑白图像"></a>1. 读取图像，将原始图像变成黑白图像</h4><p>为了让外科医生方便地取出我身体里的珍贵信息，我要舍弃我美丽的容颜，剥去华丽的外衣，换上病号服，做好手术前的准备。</p><table><thead><tr><th align="center">原本美丽的我（原始图像）</th><th align="center">花容失色的我（灰度图像）</th><th align="center">以身殉道的我（二值化图像或称黑白图像）</th></tr></thead><tbody><tr><td align="center"><div align=center><img width="150" height="150" src="/assert/img/qrcode/life/qrcodeBeautiful.png"/></div></td><td align="center"><div align=center><img width="150" height="150" src="/assert/img/qrcode/life/qrcodeBeautifulGray.png"/></div></td><td align="center"><div align=center><img width="150" height="150" src="/assert/img/qrcode/life/qrcodeBeautiful2value.jpg"/></div></td></tr></tbody></table><h4 id="2-判断黑白图像中是否存在二维码"><a href="#2-判断黑白图像中是否存在二维码" class="headerlink" title="2. 判断黑白图像中是否存在二维码"></a>2. 判断黑白图像中是否存在二维码</h4><p>他和我接头的时候小心翼翼，会确认我的身份，观察我的头和双手、摸摸我的肩膀、骨架，以初步确认我到底是不是他的接头人。<br>确认之后，他才开始和我聊起天来。从聊天中我发现这个外科医生对我们二维码种族的身体构造十分了解，简直比我自己还了解我的身体。他还向我介绍相关的知识。<br>他说，他见到过许多二维码，都是方方正正的，一共有 40 种尺寸（Version）,最小的尺寸是 21 x 21 的正方形，最大的尺寸是 177 x 177 的正方形，每加一个尺寸长和宽都会增加 4。<br>他还给我画了两张图，向我解释刚刚为什么要观察摸索我的那几个部位。</p><h5 id="基本构造图"><a href="#基本构造图" class="headerlink" title="基本构造图"></a>基本构造图</h5><div align=center><img width="300" height="300" src="/assert/img/qrcode/life/qrcodeBeautiful45.png"/></div><div align=center><img width="600" height="360" src="/assert/img/qrcode/life/qrcode-format.png"/></div><h6 id="定位图案"><a href="#定位图案" class="headerlink" title="定位图案"></a>定位图案</h6><ul><li>位置探测图形、位置探测图形分隔符: 用于对二维码的定位，对每个 QR 码来说，位置都是固定存在的，只是尺寸规格会有所差异。</li><li>定位图形: 辅助定位，尺寸过大了后需要有根标准线，不然扫描的时候可能会扫歪了。</li><li>校正图形: 尺寸规格确定，校正图形的数量和位置也就确定了。</li></ul><h6 id="功能性数据"><a href="#功能性数据" class="headerlink" title="功能性数据"></a>功能性数据</h6><ul><li>格式信息: 表示改二维码的纠错级别，分为 L、M、Q、H；</li><li>版本信息: 即二维码的尺寸规格，QR 码符号共有 40 种尺寸规格的矩阵（一般为黑白色），从 21x21（版本 1），到 177x177（版本 40），每一版本符号比前一版本 每边增加 4 个模块。</li></ul><h6 id="数据码和纠错码"><a href="#数据码和纠错码" class="headerlink" title="数据码和纠错码"></a>数据码和纠错码</h6><ul><li>数据和纠错码字: 实际保存的二维码信息，和纠错码字（用于修正二维码损坏带来的错误）。</li></ul><p><strong>只要了解二维码种族的基本构造，就可以通过鉴别头和双手（三个位置探测图形）、肩膀（定位图形）、骨架（校正图形）来初步判断来者是否是二维码了。</strong></p><h4 id="3-通过解码，读取二维码承载信息，并做相应处理"><a href="#3-通过解码，读取二维码承载信息，并做相应处理" class="headerlink" title="3. 通过解码，读取二维码承载信息，并做相应处理"></a>3. 通过解码，读取二维码承载信息，并做相应处理</h4><p>之后这位外科医生给我打了全麻，我昏睡了过去，等我醒来，他已经拿到了藏在我体内的信息。<br>后来他给我解释他用了一种名为“解码”的高超手术，还说如果我感兴趣，可以教我。（不，我不感兴趣！）<br>（解码可以简单理解为将已加密的信息，通过对应的解密方法，还原出原本的信息，暂时不深入探讨。）<br>最后，他将信息不知道到交给了谁（扫描二维码的使用者和调用方），不过这已经不是我需要关心的了，我已经完成了我的使命。<br>不过后来，我听到“滴”的一声。听说那天是情人节，阿珍收到了阿强的 520 元转账。</p><h2 id="三、走出二维码认知误区"><a href="#三、走出二维码认知误区" class="headerlink" title="三、走出二维码认知误区"></a>三、走出二维码认知误区</h2><ul><li><strong>二维码就是微信、支付宝等应用吗？</strong></li></ul><p>非也，虽然平常我们一看到二维码就习惯用微信或者支付宝去扫，但是<strong>微信和支付宝也只是二维码的使用者</strong>。<br>二维码是独立存在的，它并不依赖某一个<strong>特定的应用</strong>而存在。<strong>通用的信息</strong>，例如文本信息，普通的网页链接等，一般的扫一扫程序都能扫出来；</p><ul><li><strong>为什么有的二维码只能微信扫才能扫出来，有的二维码只能支付宝扫才能才出来呢？</strong></li></ul><p>那是因为这样的二维码往往承载的不是通用的信息而是<strong>特殊的链接信息</strong>，需要程序做出对应的处理。<br>比如我的微信的个人二维码实际承载的信息是这样的“ <a href="http://weixin.qq.com/cgi-bin/readtemplate?check=false&amp;t=weixin_getdownurl_sms&amp;s=download&amp;from=100&amp;stype=10037102">http://weixin.qq.com/cgi-bin/readtemplate?check=false&amp;t=weixin_getdownurl_sms&amp;s=download&amp;from=100&amp;stype=10037102</a> ”，这种携带了微信特有信息的链接用支付宝当然扫不出来了。<br>实际就是每个二维码的用户（微信、支付宝等）在上面流程图中最后一步对二维码扫描结果的相应处理（显示文本、跳转链接）都有着自己不同的一套处理机制。</p><ul><li><strong>二维码有一个正面，需要正面才能扫？</strong></li></ul><p>二维码没有所谓的正面，从 360° 都可以扫描，甚至镜面反转后都可以扫描，这都归功于二维码的三个定位点，三个定位点可以确定一个二维码，甚至扫描的时候图像有倾斜都可以通过算法复原后扫描。</p><h2 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a>四、结语</h2><p>经过上面的介绍，二维码扫描的基本过程想必大家已经有了初步了解，那么对于二维码具体的编解码过程又是怎样的呢？（教练，orz，我想做手术）那么<strong>预知后事如何，请听下回分解</strong>！（啪，拍案！）</p><hr><p><strong>浅谈二维码系列文章</strong></p><ul><li><a href="/2019/02/22/浅谈二维码①身世谜题/index.html#一、引言">浅谈二维码 ① 身世谜题</a></li><li><a href="/2019/02/22/浅谈二维码②与世浮沉/index.html#一、引言">浅谈二维码 ② 与世浮沉</a></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>二维码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二维码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈二维码①身世谜题</title>
    <link href="/post/%E6%B5%85%E8%B0%88%E4%BA%8C%E7%BB%B4%E7%A0%81%E2%91%A0%E8%BA%AB%E4%B8%96%E8%B0%9C%E9%A2%98/"/>
    <url>/post/%E6%B5%85%E8%B0%88%E4%BA%8C%E7%BB%B4%E7%A0%81%E2%91%A0%E8%BA%AB%E4%B8%96%E8%B0%9C%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p><strong>二维码在如今的生活中随处可见，移动支付、社交 App 等都可以见到二维码的身影。今天我们就来了解一下二维码。</strong></p><table><thead><tr><th align="center">二维码足迹</th><th align="center">二维码足迹</th></tr></thead><tbody><tr><td align="center"><div align=center><img width="150" height="150" src="/assert/img/qrcode/baseinfo/qrcodeShy.png"/></div></td><td align="center"><div align=center><img width="150" height="150" src="/assert/img/qrcode/baseinfo/qrcodeBeautiful.png"/></div></td></tr><tr><td align="center"><div align=center><img width="150" height="150" src="/assert/img/qrcode/baseinfo/mywx.jpg"/></div></td><td align="center"><div align=center><img width="300" height="200" src="/assert/img/qrcode/baseinfo/qrcodeCat.png"/></div></td></tr><tr><td align="center"><div align=center><img width="300" height="200" src="/assert/img/qrcode/baseinfo/qrcodeGif.gif"/></div></td><td align="center"></td></tr></tbody></table><h2 id="二、什么是二维码"><a href="#二、什么是二维码" class="headerlink" title="二、什么是二维码"></a>二、什么是二维码</h2><p><strong>二维码的身世谜题：我们日常说的二维码究竟是何方神圣？</strong></p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>二维码 ，又称<strong>二维条码</strong>。说到二维条码，不得不先说一下<strong>一维条码</strong>。<br>所谓的一维条码指的就是条形码（没错，就是你能在许多商品包装上，书本背后能看到的条形码）或称条码（barcode），而条形码是将<strong>宽度不等</strong>的多个黑条和空白，按照一定的编码规则排列，用以表达一组信息的图形标识符。如下图：</p><center><p><img src="/assert/img/qrcode/baseinfo/barcode.jpg" alt="条形码"></p></center><p>二维码是在一维条码的基础上<strong>扩展出另一维</strong>而来的具有可读性的条码。</p><h3 id="进阶知识"><a href="#进阶知识" class="headerlink" title="进阶知识"></a>进阶知识</h3><p>二维条码的种类很多，常见的二维条码有：</p><ul><li>QR 码</li><li>PDF417 码</li><li>汉信码</li><li>EZ 码</li><li>Aztec Code</li><li>QuickMark</li><li>Data Matrix</li></ul><p>（注意!大波二维码图片空袭警告!）</p><table><thead><tr><th align="center">二维码种类</th><th align="center">二维码种类</th></tr></thead><tbody><tr><td align="center"><div align=center><img width="230" height="280" src="/assert/img/qrcode/baseinfo/qrcode.jpg"/></div></td><td align="center"><div align=center><img width="220" height="120" src="/assert/img/qrcode/baseinfo/pdf417.jpg"/></div></td></tr><tr><td align="center"><div align=center><img width="180" height="200" src="/assert/img/qrcode/baseinfo/汉信码.jpg"/></div></td><td align="center"><div align=center><img width="220" height="240" src="/assert/img/qrcode/baseinfo/ezcode.jpg"/></div></td></tr><tr><td align="center"><div align=center><img width="200" height="250" src="/assert/img/qrcode/baseinfo/azteccode.jpg"/></div></td><td align="center"><div align=center><img width="280" height="210" src="/assert/img/qrcode/baseinfo/quickmarkcode.jpg"/></div></td></tr><tr><td align="center"><div align=center><img width="230" height="290" src="/assert/img/qrcode/baseinfo/datamatrix.jpg"/></div></td><td align="center"></td></tr></tbody></table><p>其实我们平常所说的二维码<strong>只是二维码的一种</strong>，即 QR 码（快速响应码 Quick Response Code）。也就是说我们<strong>平常所说的二维码是狭义的二维码</strong>，广义的二维码还包括了上述除了 QR 码的其他种类的二维码等。</p><p>既然如此，我们着重介绍的就是 QR 码（后文所说的二维码除特殊说明外，都指的是 QR 码）。</p><h2 id="三、为什么使用二维码"><a href="#三、为什么使用二维码" class="headerlink" title="三、为什么使用二维码"></a>三、为什么使用二维码</h2><p>我就奇了怪了：你二维码为什么这么优秀？我就要用你？我为什么不用你的<strong>爸爸——条形码</strong>？</p><h3 id="存储信息容量较大"><a href="#存储信息容量较大" class="headerlink" title="存储信息容量较大"></a>存储信息容量较大</h3><p>传统的条形码只能处理 30 位左右的信息量，与此相比，QR 码可处理条形码的几十倍到几百倍的信息量。</p><center><p><img src="/assert/img/qrcode/baseinfo/qrcodestore.jpg" alt="QR码存储容量"></p></center><h3 id="表示信息形式丰富"><a href="#表示信息形式丰富" class="headerlink" title="表示信息形式丰富"></a>表示信息形式丰富</h3><p>相比只能记录字母和数字的条形码，二维码还可以记载更复杂的数据，比如图片链接、网络链接等。</p><h3 id="空间利用率较高"><a href="#空间利用率较高" class="headerlink" title="空间利用率较高"></a>空间利用率较高</h3><p>QR 码使用纵向和横向两个方向处理数据，如果是相同的信息量，QR 码所占空间为条形码的十分之一左右。</p><h2 id="容错能力较强"><a href="#容错能力较强" class="headerlink" title="容错能力较强"></a>容错能力较强</h2><p>二维码具备“纠错功能”，即使部分编码变脏或破损，也可以恢复数据（最高可以到 30%面积破损仍可被读取）。</p><center><p><img src="/assert/img/qrcode/baseinfo/qrcodeerrorlevel.jpg" alt="二维码纠错能力"></p></center><h3 id="360°-无死角男神女神"><a href="#360°-无死角男神女神" class="headerlink" title="360° 无死角男神女神"></a>360° 无死角男神女神</h3><p>二维码从 360° 任一方向均可快速读取。其奥秘就在于 QR 码中的 3 处定位图案，可以帮助 QR 码不受背景样式的影响，实现快速稳定的读取。</p><center><p><img src="/assert/img/qrcode/baseinfo/myGod.gif" alt="myGod"></p></center><h2 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a>四、结语</h2><p><strong>以上是二维码的简单介绍，你也可以去<a href="https://www.qrcode.com">二维码官网</a>了解更多。</strong></p><center><p><img src="/assert/img/qrcode/baseinfo/wxscan.jpg" alt="扫一扫"></p></center><p>这个界面想必大家都很熟悉，那么你对扫二维码的这一过程感不感到好奇呢？那么<strong>预知后事如何，请听下回分解</strong>！（啪，拍案！）</p><hr><p><strong>浅谈二维码系列文章</strong></p><ul><li><a href="/2019/02/22/浅谈二维码①身世谜题/index.html#一、引言">浅谈二维码 ① 身世谜题</a></li><li><a href="/2019/02/22/浅谈二维码②与世浮沉/index.html#一、引言">浅谈二维码 ② 与世浮沉</a></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>二维码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二维码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简析LRU</title>
    <link href="/post/%E7%AE%80%E6%9E%90LRU/"/>
    <url>/post/%E7%AE%80%E6%9E%90LRU/</url>
    
    <content type="html"><![CDATA[<h1 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h1><p>最近最少使用算法。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><ul><li><p>-要求查找快，插入快，删除快，有顺序之分。哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表。</p></li><li><p>按顺序插入 ，所以需要双向链表。</p></li><li><p>LinkedHashMap，使用 accessOrder=true 基于顺序访问，元素访问后被移动到末尾。</p></li></ul><h2 id="自己动手实现-LRU"><a href="#自己动手实现-LRU" class="headerlink" title="自己动手实现 LRU"></a>自己动手实现 LRU</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> key, val;<br>    <span class="hljs-keyword">public</span> Node next, prev;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.key = k;<br>        <span class="hljs-keyword">this</span>.val = v;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleList</span> </span>&#123;<br>    <span class="hljs-comment">// 在链表头部添加节点 x，时间 O(1)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(Node x)</span></span>;<br><br>    <span class="hljs-comment">// 删除链表中的 x 节点（x 一定存在）</span><br>    <span class="hljs-comment">// 由于是双链表且给的是目标 Node 节点，时间 O(1)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node x)</span></span>;<br><br>    <span class="hljs-comment">// 删除链表中最后一个节点，并返回该节点，时间 O(1)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">removeLast</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 返回链表长度，时间 O(1)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;<br>    <span class="hljs-comment">// key -&gt; Node(key, val)</span><br>    <span class="hljs-keyword">private</span> HashMap&lt;Integer, Node&gt; map;<br>    <span class="hljs-comment">// Node(k1, v1) &lt;-&gt; Node(k2, v2)...</span><br>    <span class="hljs-keyword">private</span> DoubleList cache;<br>    <span class="hljs-comment">// 最大容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cap;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.cap = capacity;<br>        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        cache = <span class="hljs-keyword">new</span> DoubleList();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!map.containsKey(key))<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> val = map.get(key).val;<br>        <span class="hljs-comment">// 利用 put 方法把该数据提前</span><br>        put(key, val);<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">// 先把新节点 x 做出来</span><br>        Node x = <span class="hljs-keyword">new</span> Node(key, val);<br><br>        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;<br>            <span class="hljs-comment">// 删除旧的节点，新的插到头部</span><br>            cache.remove(map.get(key));<br>            cache.addFirst(x);<br>            <span class="hljs-comment">// 更新 map 中对应的数据</span><br>            map.put(key, x);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (cap == cache.size()) &#123;<br>                <span class="hljs-comment">// 删除链表最后一个数据</span><br>                Node last = cache.removeLast();<br>                map.remove(last.key);<br>            &#125;<br>            <span class="hljs-comment">// 直接添加到头部</span><br>            cache.addFirst(x);<br>            map.put(key, x);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LruCache"><a href="#LruCache" class="headerlink" title="LruCache"></a>LruCache</h2><p>Android SDK 里有提供。</p><h2 id="DiskLruCache"><a href="#DiskLruCache" class="headerlink" title="DiskLruCache"></a>DiskLruCache</h2><p>Android SDK 里没有提供，AOSP 源码有。</p><p>很多文件操作都采用了事务的处理方式，即修改文件前先写入一个同名的 tmp 文件，当所有内容写完后再将 tmp 文件的扩展名去掉以覆盖原有文件，这样做的好处就是不会因为应用的异常退出或 Crash 而出现数据损坏，保证了原有文件的完整性。</p><p>DiskLruCache 在操作文件的时候使用 journal 文件 来记录操作日志。</p><p>journal 头：</p><ul><li>第一行是固定的字符串“libcore.io.DiskLruCache”，标志着使用的是 DiskLruCache 技术。</li><li>第二行是 DiskLruCache 的版本号。</li><li>第三行是应用程序的版本号。</li><li>第四行是 valueCount</li><li>第五行是一个空行。</li></ul><p>DIRTY 脏数据行 正在写入<br>CLEAN 洗净脏数据行 写入成功 行末尾加上该条缓存数据的大小，以字节为单位。<br>REMOVE 移除脏数据行 写入失败</p><p>READ 读取数据行</p><p>每一行 DIRTY 的 key，后面都应该有一行对应的 CLEAN 或者 REMOVE 的记录，否则这条数据就是“脏”的。<br>redundantOpCount 变量来记录用户操作的次数，每执行一次写入、读取或移除缓存的操作，这个变量值都会加 1，当变量值达到 2000 的时候就会触发重构 journal 的事件，这时会自动把 journal 中一些多余的、不必要的记录全部清除掉，保证 journal 文件的大小始终保持在一个合理的范围内。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>简析</tag>
      
      <tag>LRU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《大话设计模式》之工厂方法模式</title>
    <link href="/post/%E8%AF%BB%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <url>/post/%E8%AF%BB%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="一、模式概述"><a href="#一、模式概述" class="headerlink" title="一、模式概述"></a>一、模式概述</h2><p><strong>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法是一个类的实例化延迟到其子类。</strong></p><h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图"></a>UML 图</h3><p><img src="/assert/img/designmodel/justtalk/factorymethod/factorymethod-1.png" alt="工厂方法模式结构图"></p><p><img src="/assert/img/designmodel/justtalk/factorymethod/factorymethod-2.png" alt="工厂方法模式实现"></p><ul><li><p>抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在 java 中它由抽象类或者接口来实现。</p></li><li><p>具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。在 java 中它由具体的类来实现。</p></li><li><p>抽象产品角色：它是具体产品继承的父类或者是实现的接口。在 java 中一般有抽象类或者接口来实现。</p></li><li><p>具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在 java 中由具体的类来实现。</p></li></ul><p><strong>这样整个工厂和具体的产品都没有修改的变化，只有扩展的变化，这就完全符合了开闭原则。</strong></p><h2 id="二、模式优缺点"><a href="#二、模式优缺点" class="headerlink" title="二、模式优缺点"></a>二、模式优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>克服了简单工厂违背开放-封闭原则的缺点，又保留了封装对象创建过程的优点,降低客户端和工厂的耦合性，所以说“工厂模式”是“简单工厂模式”的进一步抽象和推广。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>每增加一个产品，相应的也要增加一个子工厂，加大了额外的开发量。</p><h2 id="三、模式适用场景"><a href="#三、模式适用场景" class="headerlink" title="三、模式适用场景"></a>三、模式适用场景</h2><ul><li>情况一：如果一个对象拥有很多子类，那么创建该对象的子类使用工厂模式是最合适的，不但可以面向接口的编程，为维护以及开发带来方便。</li><li>情况二：如果创建某个对象时需要进行许多额外的操作，如查询数据库然后将查询到的值赋予要创建的对象(单例初始化时使用比较多),或是需要许多额外的赋值等等。如果查看 JDK 源码中，会发现许多成员变量在对象构造时，通过工厂方法进行创建的。因为这些成员变量本身的创建也很复杂。不可能创建对象时，在该对象的构造方法里创建成员变量然后再赋值给该成员变量。而且使用工厂模式也提高了代码的重用性。</li></ul><h2 id="四、模式总结"><a href="#四、模式总结" class="headerlink" title="四、模式总结"></a>四、模式总结</h2><p>对简单工厂模式的进一步抽象和封装。在简单工厂的基础上多抽象了一个工厂父类，用来生成不同的工厂类。工厂方法把简单工厂的内部逻辑判断迁移到了客户端来进行。<br><strong>使用工厂方法模式足以应付我们可能遇到的大部分业务需求。但是当产品种类非常多时，就会出现大量的与之对应的工厂类，这不应该是我们所希望的。所以我建议在这种情况下使用<a href="/2016/01/22/读《大话设计模式》之简单工厂模式/index.html#一、模式概述：">简单工厂模式</a>与工厂方法模式相结合的方式来减少工厂类：即对于产品树上类似的种类（一般是树的叶子中互为兄弟的）使用<a href="/2016/01/22/读《大话设计模式》之简单工厂模式/index.html#一、模式概述：">简单工厂模式</a>来实现。<br>当然特殊的情况，就要特殊对待了：对于系统中存在不同的产品树，而且产品树上存在产品族（下一节将解释这个名词）。那么这种情况下就可能可以使用<a href="/2016/03/10/读《大话设计模式》之抽象工厂模式/index.html#一、模式概述：">抽象工厂模式</a>了。</strong></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>《大话设计模式》</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(三)自定义View实践之自定义属性</title>
    <link href="/post/(%E4%B8%89)%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/"/>
    <url>/post/(%E4%B8%89)%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="一、定义与声明"><a href="#一、定义与声明" class="headerlink" title="一、定义与声明"></a>一、定义与声明</h2><p>在资源文件夹 values 下新建 attr.xml 文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;string&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;textColor&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;color&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;textSize&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;dimension&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">declare-styleable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CodeView&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">attr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;textColor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">attr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;textSize&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">attr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">declare-styleable</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中 CodeView 是自定义 styleable 名，可以随意取<br>format 有以下几种：</p><ol><li>reference：参考某一资源 ID</li><li>color：颜色值</li><li>boolean：布尔值</li><li>dimension：尺寸值</li><li>float：浮点值</li><li>integer：整型值</li><li>string：字符串</li><li>fraction：百分数</li><li>enum：枚举值</li><li>flag：位或运算</li></ol><h2 id="二、具体使用"><a href="#二、具体使用" class="headerlink" title="二、具体使用"></a>二、具体使用</h2><p>具体的解析需要自行来做对应的修改（以我自己写的 parseAttr 方法为例子）：<br>自定义 View 的构造器中调用 parseAttr()自定义解析并处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">View</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CodeView</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(context, <span class="hljs-keyword">null</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CodeView</span><span class="hljs-params">(Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(context, attrs, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CodeView</span><span class="hljs-params">(Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs, <span class="hljs-keyword">int</span> defStyleAttr)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context, attrs, defStyleAttr);<br>        parseAttr(context, attrs);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解析自定义属性</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 调用方上下文</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> attrs 属性集</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseAttr</span><span class="hljs-params">(Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;<br>        TypedArray attributes = context.obtainStyledAttributes(attrs, R.styleable.CodeView);<br>        <span class="hljs-keyword">int</span> num = attributes.getIndexCount();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>            <span class="hljs-keyword">int</span> attr = attributes.getIndex(i);<br>            <span class="hljs-keyword">switch</span> (attr) &#123;<br>                <span class="hljs-keyword">case</span> R.styleable.CodeView_text:<br>                    mText = attributes.getString(attr);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> R.styleable.CodeView_textColor:<br>                    <span class="hljs-comment">//默认设置为黑色</span><br>                    mTextColor = attributes.getColor(attr, Color.BLACK);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> R.styleable.CodeView_textSize:<br>                    <span class="hljs-comment">//默认设置为16sp，TypeValue也可以把sp转化为px</span><br>                    mTextSize = attributes.getDimensionPixelSize(attr, (<span class="hljs-keyword">int</span>) TypedValue<br>                            .applyDimension(TypedValue.COMPLEX_UNIT_SP, <span class="hljs-number">16</span>, getResources()<br>                            .getDisplayMetrics()));<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        attributes.recycle();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>自定义View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(二)自定义VIew理论之View工作流程</title>
    <link href="/post/(%E4%BA%8C)%E8%87%AA%E5%AE%9A%E4%B9%89VIew%E7%90%86%E8%AE%BA%E4%B9%8BView%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
    <url>/post/(%E4%BA%8C)%E8%87%AA%E5%AE%9A%E4%B9%89VIew%E7%90%86%E8%AE%BA%E4%B9%8BView%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><p>View 的工作流程主要是指 measure、layout、draw 这三大流程，即测量、布局、绘制。measure 确定 View 的测量宽高；layout 确定 View 的最终宽高和四个顶点的位置；draw 则将 View 绘制到屏幕上。</p><h2 id="二、measure-过程"><a href="#二、measure-过程" class="headerlink" title="二、measure 过程"></a>二、measure 过程</h2><h3 id="1-View-的-measure-过程"><a href="#1-View-的-measure-过程" class="headerlink" title="1. View 的 measure 过程"></a>1. View 的 measure 过程</h3><p>由 measure()方法来完成，measure()方法是 final 类型的方法，因此不能被重写。而 measure 方法会去调用 onMeasure()方法，因此只需要看 onMeasure()的实现即可。具体可以参看上一节相关内容。</p><h3 id="2-ViewGroup-的-measure-过程"><a href="#2-ViewGroup-的-measure-过程" class="headerlink" title="2. ViewGroup 的 measure 过程"></a>2. ViewGroup 的 measure 过程</h3><p>除了完成自己的 measure 外，递归地调用子元素的 measure 方法</p><h3 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. 注意事项</h3><p>View 的 measure 过程完成以后就可以通过 getMeasuredWidth/Height 方法来获取 View 的测量宽高。但是在某些极端情况下，系统可能需要多次 measure 过程才能最终确定 View 的测量宽高，因此在这种情况下获取的 View 的测量宽高可能是不准确的。最好在 onLayout()方法中去获取 View 的测量宽高。</p><h2 id="三、layout-过程"><a href="#三、layout-过程" class="headerlink" title="三、layout 过程"></a>三、layout 过程</h2><p>ViewGroup 通过 layout()方法确定子元素的位置，当位置确定以后在 onLayout()方法中遍历所有子元素的 layout()方法，如此递归。<br>  layout()方法的大致流程：首先通过 setFrame()方法来设置四个顶点的位置，即初始化 mLeft、mRight、mTop、mBottom 这四个值。View 的四个顶点确定了，那么 View 在父容器的位置就确定了；然后调用 onLayout()方法，这个方法的作用是父容器确定子元素的位置。和 onMeasure()方法类似，onLayout()的具体实现同样和具体的布局有关，所以 View 和 ViewGroup 均没有实现 onLayout()方法。</p><h2 id="四、draw-过程"><a href="#四、draw-过程" class="headerlink" title="四、draw 过程"></a>四、draw 过程</h2><ol><li>绘制背景 background.draw(canvas)</li><li>绘制自己(onDraw)</li><li>绘制 Children(dispatchDraw)</li><li>绘制装饰(onDrawScrollBars)</li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>自定义View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(一)自定义View理论之View绘制原理</title>
    <link href="/post/(%E4%B8%80)%E8%87%AA%E5%AE%9A%E4%B9%89View%E7%90%86%E8%AE%BA%E4%B9%8BView%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86/"/>
    <url>/post/(%E4%B8%80)%E8%87%AA%E5%AE%9A%E4%B9%89View%E7%90%86%E8%AE%BA%E4%B9%8BView%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><p>自定义 View 是 Android 进阶之路不可避免的难关。此刻下定决心攻克这个难关，以此为证。在学习绘制自定义 View 之前先来思考一下系统是如何绘制出这些 View 的。<br>推荐《Android 群英传》、《Android 开发艺术探索》这两本书，本系列文中很多都来源于这两本的阐述。</p><h2 id="二、View-的测量"><a href="#二、View-的测量" class="headerlink" title="二、View 的测量"></a>二、View 的测量</h2><p>设想这么一个游戏：一个人蒙着眼睛，另一个人通过说话来指示蒙着眼睛的人去画他想画图案。比如你会指导他在画板左上角水平竖直都为 10 厘米处开始画一个边长为 10 厘米的正方形，那么他大致就能画准确。而如果你只告诉他画一个矩形，那么他就画不准确了。事实上，Android 就是那个蒙着眼睛的人，我们需要细致地高速他怎么绘制。<br>生活中，画一个图形必须知道他的大小和位置。同样，Android 系统在绘制 View 前也必须对 View 进行测量，即告诉系统该画一个多大的 View，这个过程在 onMeasure()方法中进行。<br>  Android 系统为我们提供了一个设计短小精悍却功能强大的类—— <strong>MeasureSpec</strong>，来帮助我们绘制 View。<br>  <strong>MeasureSpec</strong>是一个 32 位的 int 值，高 2 位表示测量的模式，低 30 位表示测量的大小。位运算是为了提高效率。<br><strong>测量的模式：</strong><br>  <strong>EXACTLY</strong>：精确模式(当 View 宽高设置为具体数值或者指定为 match_parent)<br>  <strong>AT MOST</strong>：最大值模式(当 View 宽高设置为指定为 wrap_content)<br>  <strong>UNSPECIFIED</strong>：不指定测量大小模式(通常自定义 View 才会用到)</p><p>自定义 View 测量，重写 onMeasure()方法。<br>系统的 super.onMeasure()在最终会调用 setMeasureDimension(int measuredWidth， int measuredHeight)方法将测量的宽高值设置进去，从而完成测量工作。所以在重写 onMeasure()方法后，最终要做的工作就是把测量后的宽高值作为参数设置给 setMeasureDimension()方法。</p><p>模板如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">View</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;<br>        setMeasuredDimension(measureSize(widthMeasureSpec, <span class="hljs-number">200</span>), measureSize(heightMeasureSpec,<br>                <span class="hljs-number">200</span>));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测量View尺寸</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> measureSpec 要测量的Spec</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> defaultSize 默认View大小</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> View尺寸</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">measureSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> measureSpec, <span class="hljs-keyword">int</span> defaultSize)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> result = defaultSize;<br>        <span class="hljs-keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);<br>        <span class="hljs-keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);<br><br>        <span class="hljs-keyword">switch</span> (specMode) &#123;<br>            <span class="hljs-keyword">case</span> MeasureSpec.UNSPECIFIED:<br>                result = defaultSize;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MeasureSpec.AT_MOST:<br>                result = Math.min(result, specSize);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MeasureSpec.EXACTLY:<br>                result = specSize;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、View-的绘制"><a href="#三、View-的绘制" class="headerlink" title="三、View 的绘制"></a>三、View 的绘制</h2><p>测量好 View 后，我们就可以重写 onDraw()方法，在 Canvas 对象上来绘制图案了。无论多复杂、精美的控件，它都可以拆分成一个个小小的图形单元。而那些具体的图形单元的绘制就只需要调用系统的 API 来完成，这里就不详细展开了。</p><h2 id="四、ViewGroup-的测量"><a href="#四、ViewGroup-的测量" class="headerlink" title="四、ViewGroup 的测量"></a>四、ViewGroup 的测量</h2><p>ViewGroup 的宽高指定为 warp_content 时，需要遍历子 View，获得所有子 View 的大小，从而来决定自己的大小。其他模式则会通过具体的指定值来设置自身的大小。</p><h2 id="五、ViewGroup-的绘制"><a href="#五、ViewGroup-的绘制" class="headerlink" title="五、ViewGroup 的绘制"></a>五、ViewGroup 的绘制</h2><p>ViewGroup 通常情况下不需要绘制，因为它本身没有需要绘制的东西。如果不是指定了 ViewGroup 的背景颜色，那么 ViewGroup 的 onDraw()方法都不会被调用。GroupView 会使用 dispatchDraw()方法来绘制其子 View，其过程同样是通过遍历子 View，并调用子 View 的绘制方法来实现绘制。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>自定义View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《大话设计模式》之观察者模式</title>
    <link href="/post/%E8%AF%BB%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/post/%E8%AF%BB%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="一、模式概述"><a href="#一、模式概述" class="headerlink" title="一、模式概述"></a>一、模式概述</h2><p><strong>定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有的观察者对象爱，使他们能够自动更新自己。</strong></p><h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图"></a>UML 图</h3><p><img src="/assert/img/designmodel/justtalk/observer/observer-1.png" alt="观察者模式结构图"></p><p><img src="/assert/img/designmodel/justtalk/observer/observer-2.png" alt="观察者模式"></p><h2 id="二、模式优缺点"><a href="#二、模式优缺点" class="headerlink" title="二、模式优缺点"></a>二、模式优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个具体观察者，它只知道它们都有一个共同的接口。<strong>(依赖倒转原则的体现)</strong></li><li>观察者模式支持<strong>广播通讯</strong>。被观察者会向所有的登记过的观察者发出通知，</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会<strong>花费很多时间</strong>。</li><li>如果在观察者和观察目标之间有<strong>循环依赖</strong>的话，观察目标会触发它们之间进 行循环调用，可能导致系统崩溃。</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li></ol><h2 id="三、模式适用场景"><a href="#三、模式适用场景" class="headerlink" title="三、模式适用场景"></a>三、模式适用场景</h2><p>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</p><h2 id="四、模式总结"><a href="#四、模式总结" class="headerlink" title="四、模式总结"></a>四、模式总结</h2><p>观察者模式定义了对象之间的一对多关系。多个观察者监听同一个被观察者，当该被观察者的状态发生改变时，会通知所有的观察者。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>《大话设计模式》</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《大话设计模式》之备忘录模式</title>
    <link href="/post/%E8%AF%BB%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <url>/post/%E8%AF%BB%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="一、模式概述"><a href="#一、模式概述" class="headerlink" title="一、模式概述"></a>一、模式概述</h2><p><strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在改对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</strong></p><h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图"></a>UML 图</h3><p><img src="/assert/img/designmodel/justtalk/memento/memento-1.png" alt="备忘录模式"><br>Originator（发起人）：负责创建一个备忘录 Memento，用以记录当前时刻它的内部状态，并可以使用备忘录恢复内部状态。Originator 可根据需要决定 Memento 存储 Originator 的哪些内部状态。<br>Memento（备忘录）：负责存储 Originator 对象的内部状态，并可防止 Originator 以外的其他对象访问备忘录。备忘录有两个接口，Caretaker 只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。Originator 能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。<br>Caretaker（管理者）：负责保存好备忘录，不能对备忘录的内容进行操作或检查。</p><h2 id="二、模式优缺点"><a href="#二、模式优缺点" class="headerlink" title="二、模式优缺点"></a>二、模式优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>可以把复杂的对象内部信息对其他的对象屏蔽起来。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>如果状态数据很大很多，那么在资源消耗上，备忘录对象会非常耗内存。</p><h2 id="三、模式适用场景"><a href="#三、模式适用场景" class="headerlink" title="三、模式适用场景"></a>三、模式适用场景</h2><p>功能比较复杂的，但需要维护或记录属性历史的类，或者需要保存的属性只是众多属性中的一小部分时。</p><h2 id="四、模式总结"><a href="#四、模式总结" class="headerlink" title="四、模式总结"></a>四、模式总结</h2><p>备忘录模式可以做到较好的封装来实现“恢复现场”的效果，但有时候内存的消耗会比较大。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>《大话设计模式》</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《大话设计模式》之适配器模式</title>
    <link href="/post/%E8%AF%BB%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/post/%E8%AF%BB%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="一、模式概述"><a href="#一、模式概述" class="headerlink" title="一、模式概述"></a>一、模式概述</h2><h3 id="将一个类的接口转换成客户希望的另外一个接口"><a href="#将一个类的接口转换成客户希望的另外一个接口" class="headerlink" title="将一个类的接口转换成客户希望的另外一个接口"></a>将一个类的接口转换成客户希望的另外一个接口</h3><p>适配器的意思就是使得一个东西适合另一个东西的东西。如，不同国家有不同标准的电压（110V、220V），于是就需要电源适配器。</p><h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图"></a>UML 图</h3><p><img src="/assert/img/designmodel/justtalk/adapter/adapter-1.png" alt="适配器模式结构图"><br>Target：客户所期待的接口。（目标可以是具体的或抽象的类，也可以是接口）<br>Adaptee：需要适配的类。<br>Adapter：适配器类。（通过在内部包装一个 Adaptee 对象，把源接口转换成目标接口）<br>Client：客户端。</p><h2 id="二、模式优缺点"><a href="#二、模式优缺点" class="headerlink" title="二、模式优缺点"></a>二、模式优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>能解决接口不匹配的问题，客户端能统一调用统一接口。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>不够优雅，实则是无奈之举，有“亡羊补牢”的感觉。</p><h2 id="三、模式适用场景"><a href="#三、模式适用场景" class="headerlink" title="三、模式适用场景"></a>三、模式适用场景</h2><p>1.系统的数据和行为都正确，但接口不符的情景。 2.希望复用一些类，但接口又与复用环境要求不一致的情景。 3.双方都不太容易修改接口的情景。</p><h2 id="四、模式总结"><a href="#四、模式总结" class="headerlink" title="四、模式总结"></a>四、模式总结</h2><p>接口统一实则应该在设计阶段就完成。接口不统一，首先应该考虑重构统一接口，在双方都不太容易修改的时候再使用适配器模式适配。事后控制不如事中控制，事中控制不如事前控制。（扁鹊三兄弟的故事）</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>《大话设计模式》</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《大话设计模式》之状态模式</title>
    <link href="/post/%E8%AF%BB%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <url>/post/%E8%AF%BB%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="一、模式概述"><a href="#一、模式概述" class="headerlink" title="一、模式概述"></a>一、模式概述</h2><p><strong>在很多情况下，一个对象的行为取决于它的一个或多个变化的属性，这些属性我们称之为状态，这个对象称之为状态对象</strong><br>对于状态对象而言，它的行为依赖于它的状态。<br>这样的一个对象，当它在于外部事件产生互动的时候，其内部状态就会发生改变，从而使得他的行为也随之发生改变<br><strong>所谓状态模式就是允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</strong></p><p>没图说个文明你我他。</p><h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图"></a>UML 图</h3><p><img src="/assert/img/designmodel/justtalk/state/state-1.png" alt="状态模式结构图"><br>1.State 类：抽象状态类，定义一个接口封装与 Context 状态相关的行为(所以依赖 Context 类)。<br>2.ConcreteState 类：具体状态类，实现一个具体的状态的行为。<br>3.Context 类：具体的实例，他定义当前的状态，持有 State 状态类(所以是聚合关系)。</p><h2 id="二、模式优缺点"><a href="#二、模式优缺点" class="headerlink" title="二、模式优缺点"></a>二、模式优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 2.将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>1、状态模式的使用必然会增加系统类和对象的个数。<br>2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。<br>3、状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</p><h2 id="三、模式适用场景"><a href="#三、模式适用场景" class="headerlink" title="三、模式适用场景"></a>三、模式适用场景</h2><p>1、对象的行为依赖于它的状态并且可以根据它的状态改变而改变它的相关行为。<br>2、代码中包含大量与对象状态有关的条件语句</p><h2 id="四、模式总结"><a href="#四、模式总结" class="headerlink" title="四、模式总结"></a>四、模式总结</h2><p>我的理解就是状态模式利用实例类和状态类之间的关系来代替过多 的 if else 状态转换逻辑，实现拓展性、可维护性。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>《大话设计模式》</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《大话设计模式》之抽象工厂模式</title>
    <link href="/post/%E8%AF%BB%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/post/%E8%AF%BB%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="一、模式概述"><a href="#一、模式概述" class="headerlink" title="一、模式概述"></a>一、模式概述</h2><p><strong>提供一个创建一系列相关或互相依赖的接口，而无需指定它们具体的类。</strong></p><p>先来认识下什么是产品族： 位于不同产品等级结构中，功能相关联的产品组成的家族。</p><h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图"></a>UML 图</h3><p><img src="/assert/img/designmodel/justtalk/abstractfactory/abstractfactory-1.png" alt="抽象工厂模式"></p><ul><li><p>抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在 java 中它由抽象类或者接口来实现。</p></li><li><p>具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。在 java 中它由具体的类来实现。</p></li><li><p>抽象产品角色：它是具体产品继承的父类或者是实现的接口。在 java 中一般有抽象类或者接口来实现。</p></li><li><p>具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在 java 中由具体的类来实现。</p></li></ul><h2 id="二、模式优缺点"><a href="#二、模式优缺点" class="headerlink" title="二、模式优缺点"></a>二、模式优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1、 抽象工厂模式隔离了具体类的生产，使得客户并不需要知道什么被创建。<br>2、 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。<br>3、 增加新的具体工厂和产品族很方便，无须修改已有系统，符合开闭原则。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p><strong>增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对开闭原则的支持呈现倾斜性。</strong><br>如果需要增加新的产品树，那么就要新增三个产品类，并且要修改三个工厂类。这样大批量的改动是很丑陋的做法。<br><strong>所以可以用简单工厂配合反射来改进抽象工厂。</strong></p><h2 id="三、模式适用场景"><a href="#三、模式适用场景" class="headerlink" title="三、模式适用场景"></a>三、模式适用场景</h2><p>1、 系统中有多个产品族，而系统一次只可能消费其中一族产品<br>2、 同属于同一个产品族的产品以其使用。<br>当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。</p><h2 id="四、模式总结"><a href="#四、模式总结" class="headerlink" title="四、模式总结"></a>四、模式总结</h2><p>提供一个创建一系列相关或互相依赖的接口，而无需指定它们具体的类。<br>抽象工厂模式的用意为：给客户端提供一个接口，可以创建多个产品族中的产品对象。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>《大话设计模式》</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《大话设计模式》之简单工厂模式</title>
    <link href="/post/%E8%AF%BB%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/post/%E8%AF%BB%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="一、模式概述"><a href="#一、模式概述" class="headerlink" title="一、模式概述"></a>一、模式概述</h2><p><strong>简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式</strong><br><strong>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。</strong></p><h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图"></a>UML 图</h3><p><img src="/assert/img/designmodel/justtalk/simplefactory/simplefactory-1.png" alt="简单工厂模式UML图"></p><ul><li>工厂（Creator）角色：简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。</li><li>抽象产品（Product）角色：简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。</li><li>具体产品（Concrete Product）角色：是简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。</li></ul><h2 id="二、模式优缺点"><a href="#二、模式优缺点" class="headerlink" title="二、模式优缺点"></a>二、模式优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>工厂类是整个模式的关键.包含了必要的逻辑判断,根据外界给定的信息,决定究竟应该创建哪个具体类的对象.通过使用工厂类,外界可以从直接创建具体产品对象的尴尬局面摆脱出来,仅仅需要负责“消费”对象就可以了，而不必管这些对象究竟如何创建及如何组织的．明确了各自的职责和权利。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。</li><li>当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；</li></ol><h2 id="三、模式适用场景"><a href="#三、模式适用场景" class="headerlink" title="三、模式适用场景"></a>三、模式适用场景</h2><ul><li>工厂类负责创建的对象比较少；</li><li>客户端只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心；</li><li>由于简单工厂很容易违反高内聚责任分配原则，因此一般只在很简单的情况下应用。</li></ul><h2 id="四、模式总结"><a href="#四、模式总结" class="headerlink" title="四、模式总结"></a>四、模式总结</h2><p>简单工厂模式使客户端与具体的产品对象解耦。工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类。但是这就造成了工厂类违背了开闭原则，工厂类有修改的变化。<br><strong>它的缺点在<a href="/2017/02/11/读《大话设计模式》之工厂方法模式/index.html#一、模式概述：">工厂方法模式</a>得到一定的克服。</strong></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>《大话设计模式》</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
