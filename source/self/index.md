---
title: self
date:
layout:
export_on_save:
  puppeteer: ["pdf", "png"]
---

## 专业技能

### 熟悉 Kotlin 协程，并了解其原理

优势：

消除了并发任务之前协作的难度。

假设有一个需求，需要请求两个网络接口，将数据合并后再显示到界面。
最合理的做法是并行请求后再融合数据后展示界面。

1. 回调式（Java Callbacks）

   回调式开发，不仅是多了缩进，还限制了能力。回调式开发要做这种工作很困难，不得不妥协，将并行请求改成了串行请求，性能差了一倍。

2. 响应式（RxJava）

   可以使用 zip 函数。有一定的学习曲线。

3. 协程（Kotlin Coroutines）

   使用命令式的风格写出异步代码，简洁可读性强。

suspend 关键字：表示非阻塞时挂起，只起到标记作用。协程挂起恢复是由编译器完成的。

- Kotlin 协程是一个线程框架。方便，在同一个代码块能进行多次切换。
- 挂起就是可以自动切换来的切线程。
- 非阻塞式指的是可以用看起来阻塞的代码写出非阻塞的操作。

原理：

核心关注编译器。

编译器对挂起函数的第一个改变就是对函数签名的改变，这种改变被称为 CPS（Continuation Passing Style 续体传递风格）变换，将内部要执行的逻辑封装到一个闭包里面，然后再返回给调用者。

续体（Continuation）是一个抽象概念，指包装了协程在挂起之后应该继续执行的代码。目的是保存挂起点。它携带上下文。上下文可以添加拦截器、异常处理器。

一个挂起函数会被编译成一个实现了 Continuation 接口的匿名类，其中一个函数 resumeWith 实现为状态机，每一个续体对应一个状态。当函数运行到每个挂起点时，状态就会切换。

协程的挂起和 Java 的 NIO 机制是类似的，我们在一个线程中执行了一个原本会阻塞线程的任务，但是这个调用者线程没有发生阻塞，这是因为它们有一个专门的线程来负责这些任务的流转，也就是说，当我们发起多个阻塞操作的时候，可能只会阻塞这一个专门的线程，它一直在等待，谁的阻塞结束了，它就把回调再分派过去，这样就完成了阻塞任务与阻塞线程的多对一，而不是以前的一对一，所以挂起也好，NIO 也好，本质上都没有彻底消灭阻塞，但是它们都使阻塞的线程大大减少，从而避免了大量的线程上下文状态切换以及避免了大量线程的产生，从而在 IO 密集型任务中大大提高了性能。

### 熟悉 Jetpack 套件中的 Lifecycle、LiveData、ViewModel，并了解其原理

### 熟悉 Glide 、 OkHttp 、 LeakCanary 等知名开源库，并阅读过部分源码

[Glide](/post/简析Glide.md)

[OkHttp](/post/简析OkHttp.md)

[LeakCanary](/post/简析LeakCanary.md)

### 掌握 MVC/MVP/MVVM 架构，并对其有一定的理解

### 了解 Flutter，有过相关业务页面开发经验

### 了解 CI / CD ，有一定的持续化集成实战经验
